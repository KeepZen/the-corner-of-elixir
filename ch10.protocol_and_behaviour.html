<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>协议与行为 - 角落里的长生不老药</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 目录</a></li><li class="chapter-item expanded "><a href="ch01.intruction.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="ch02.plus_and_minus.html"><strong aria-hidden="true">3.</strong> 加和减</a></li><li class="chapter-item expanded "><a href="ch03.pattern_match.html"><strong aria-hidden="true">4.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="ch04.parenthese.html"><strong aria-hidden="true">5.</strong> 括号</a></li><li class="chapter-item expanded "><a href="ch05.new_constructor.html"><strong aria-hidden="true">6.</strong> 定制新结构</a></li><li class="chapter-item expanded "><a href="ch06.async_programe.html"><strong aria-hidden="true">7.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="ch07.pipe.html"><strong aria-hidden="true">8.</strong> 管道操作符</a></li><li class="chapter-item expanded "><a href="ch08.error_handle.html"><strong aria-hidden="true">9.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="ch09.module.html"><strong aria-hidden="true">10.</strong> 模块</a></li><li class="chapter-item expanded "><a href="ch10.protocol_and_behaviour.html" class="active"><strong aria-hidden="true">11.</strong> 协议与行为</a></li><li class="chapter-item expanded "><a href="ch11.macro.html"><strong aria-hidden="true">12.</strong> 如何理解宏</a></li><li class="chapter-item expanded "><a href="ch12.process.html"><strong aria-hidden="true">13.</strong> 进程</a></li><li class="chapter-item expanded "><a href="chx.cold_knowledge.html"><strong aria-hidden="true">14.</strong> 附录 冷知识</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">角落里的长生不老药</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="第十章-协议与行为"><a class="header" href="#第十章-协议与行为">第十章 协议与行为</a></h1>
<h2 id="如何选择"><a class="header" href="#如何选择">如何选择</a></h2>
<p>就像 <code>case</code> 和 <code>cond</code> 一度让我感觉选择困难一样,
面对协议和行为, 我往往也难以做出抉择.</p>
<p>但是这种困难和语言无关, 因为它不是语义方面的的问题, 而是系统设计知识不足带来的.</p>
<p>可以这样理解, 协议就是 OOP 编程中的接口 (Java) 或者纯抽象类(C++);
而行为就是一般的抽象类. 至少协议和行为解决的问题与 OOP
中接口与抽象类解决的问题是一样的.</p>
<p>接口和协议可以看作一个系统的 API 接口, 使用者只需要关心系统提供了那些功能,
而不用关心这些功能是如何实现的.</p>
<p>抽象类或行为可以看作是可供 DIY 的产品. 基础的功能, 行为(<code>Behavior</code>)
已经为我们定义好了, 系统各个部分交互的规则也已经完成了,
但是具体的业务需求部分, 需要用户自己 DIY.</p>
<p>如果代码最主要的目的, 是简化系统的调用, 那么应该使用协议及其实现.
如果代码提供的服务, 需要支持定制化的开发, 那么就应该使用协议.</p>
<h2 id="协议到底是什么"><a class="header" href="#协议到底是什么">协议到底是什么</a></h2>
<p>首先在底层, 协议和协议的实现到底是什么?</p>
<p>Erlang 中根本没有协议这样的语法概念. Elixir 运行在 Erlang 的虚拟机中,
所以 Elixir 是用了 Erlang 中的概念为我们抽象出了协议这一新概念.</p>
<p>和协议关系最密切的概念就是行为, 就像上一节描述的那样, 这两个概念密切到我不知道如何选择.
现在又知道, 协议是高级的概念, 那么可以肯定, 协议的概念一定构建在行为的基础上.</p>
<p>行为是模块的属性, 是模块发出的声明: 实现了某个模块中所有的 <code>@callback</code> 属性.</p>
<p>而一个理想的协议模块, 除了实现的动态调度的相关函数外, 没有其他函数.
那么协议这个概念本质上, 就是 Elixir 帮助我们更简单的完成对行为的动态调度.</p>
<h2 id="协议与模块"><a class="header" href="#协议与模块">协议与模块</a></h2>
<p>在前面的模块的章节中, 我们已经知道了 <code>defprotocol</code> 和 <code>defimpl</code> 宏的调用,
和 <code>defmodule/2</code> 的调用一样, 在编译后会产生编译模块, 反映到文件系统中就是 <code>.beam</code> 文件.
我们还知道, <code>defmodule/2</code> 是支持嵌套定义的, 那么这就意味着, <code>defprotocol</code> 和
<code>defimpl</code> 除了定义在顶层的作用域外, 还可以嵌套在 <code>defmodule/2</code> 的上下文中.</p>
<p>现在让我们定义一个 <code>Corner.Addable</code> 协议.</p>
<pre><code class="language-elixir">defmodule Corner do
  defprotocol Addable do
    def add(a, b)
  end

  defimpl Addable, for: [Integer, Float] do
    def add(a, b), do: a + b
  end
end
</code></pre>
<p>首先, 用 <code>elixirc</code> 来编译这段代码, 得到 4 个 <code>.beam</code> 文件,
分别是: <code>Elixir.Corner.beam</code>,<code>Elixir.Coner.Addable.beam</code>,
<code>Elixir.Coner.Addable.Integer</code> 和 <code>Elixir.Corner.Addable.Float</code>.</p>
<p>也就是说, 如果在模块内使用 <code>defprotocol</code>, 那么它的变化类似于 <code>defmodule/2</code>,
最后产生的模块名会添加外部模块前缀. 而协议的实现代码,
实际上是定义在 <code>Protocol.Type</code> 这样的模块中的, 而不再添加外部模块的前缀.</p>
<p>例如下面的代码第 5 ~ 10 行,
我们在 <code>TimeSpan</code> 模块的定义的上下文中, 为 <code>TimeSpan</code> 类型实现 <code>Coner.Addable</code> 协议.
这新的实现, 是位于模块 <s>Corner.TimeSpan.</s>Corner.Addable.Corner.TimeSpan 中,
这里没有添加外部模块的前缀 <strong>Corner.TimeSpan</strong>.</p>
<p>也就是说, <code>defimpl Protocol, for: Type</code> 无论在哪里, 都一样展开为 <code>Protocol.Type</code>,
而不会因为嵌套在其他模块结构中, 而添加新的前缀.</p>
<pre><code class="language-elixir">defmodule Corner.TimeSpan do
  defstruct hour: 0, min: 0, second: 0
  alias Corner.{Addable, TimeSpan}

  defimpl Addable, for: __MODULE__ do
    def add(a, b) do
      %{hour: h1, min: m1, second: s1} = a
      %{hour: h2, min: m2, second: s2} = b
      # %__MODULE__{hour: h1 + h2, min: m1 + m2, second: s1 + s2}
      %TimeSpan{hour: h1 + h2, min: m1 + m2, second: s1 + s2}
    end

    IO.inspect(__MODULE__, label: &quot;__MODULE__&quot;)
  end
end
</code></pre>
<p>在这种模块嵌套的代码中, 要特别留意上下文. 请注意上面的代码片段中的 <code>__MODULE__</code>,
在不同的上下文中, 其展开结果是不一样的.
第 5 行的 <code>__MODULE__</code> 展开为 <code>Corner.TimeSpan</code> 在意料之中.
但是第 12 行的 <code>__MODULE__</code> 展开是什么呢? 或者说,
第 8 行的最终的语义和第 9 行一样吗? 通过控制台的输出,
我们知道是第 13 行的 <code>__MODULE__</code> 展开为 <code>Corner.Addable.Corner.TimeSpan</code>.
因此不难推测, 注释掉的第 9 行, 其语义与第 10 行的是不同的.
虽然上面的讨论已经知道 <code>defimpl</code> 是要定义一个新的模块,
但是我第一次编码的时候, 还是犯了第 9 行这样的错.</p>
<p>因为 <code>defprotocol</code> 和 <code>defimpl</code> 实际上是要创建模块,
除了 <code>defprotocol</code> 对核心模块的少数几个宏做了限制外<sup class="footnote-reference"><a href="#protocol">1</a></sup>,
大部分的功能并没有限制, 所以就像我们可以在 <code>defmodule/2</code> 的上下文中执行
<code>def*</code> 以外的其他表达式那样, 在 <code>defprotocol</code> 和 <code>defimpl</code> 上下文中也可以这样做.</p>
<div class="footnote-definition" id="protocol"><sup class="footnote-definition-label">1</sup>
<p>见 Elixir 协议模块源码的 第<a href="https://github.com/elixir-lang/elixir/blob/7e4fbe657dbf9c3e19e3d2bd6c17cc6d724b4710/lib/elixir/lib/protocol.ex#L684">690~703</a> 行.</p>
</div>
<p>现在我们知道了, <code>defimpl</code> 可以嵌套到 <code>defmodule/2</code> 中, 那么 <code>defimpl</code>
内部可以嵌套 <code>defimpl</code> 调用吗?
或者再推广一下: <code>defimpl</code> 都可以在什么样的上下文中调用呢?</p>
<p>以前的章节中, 我们见到的 <code>defimpl</code> 调用的上下文有:</p>
<ul>
<li>顶层作用域</li>
<li><code>defmodule/2</code> 作用域</li>
</ul>
<p>剩下的作用还有如下几个:</p>
<ul>
<li><code>defprotoc</code></li>
<li><code>defimpl</code></li>
<li><code>def</code>, <code>defp</code>, <code>defmacro</code> <code>defmacop</code></li>
</ul>
<p>首先, 不可以直接在 <code>defprotoc</code> 的上下文中, 使用 <code>defimpl</code> 为正在定义的协议提供实现.</p>
<pre><code class="language-elixir">defprotocol Addable2 do
  def add(a, b)

  defimpl Addable2, for: Integer do
    def add(a, b) do
      a + b
    end
  end
end
</code></pre>
<p>编译这段代码, 得到了编译错误.
错误是 <code>defimpl</code> 引发的, 错误的原因是不能加载模块 <code>Addable2</code>.
这说明, 调用 <code>defimpl</code> 的时候, 会加载 <code>:for</code> 选项指定的模块.
现在还没有完成 <code>Addable2</code> 模块的定义, 所以加载这个模块自然是失败的.</p>
<p>但是我们可以在协议定义的上下文中, 为其他协议提供实现吗? 答案是可以的.</p>
<pre><code class="language-elixir">defprotocol Corner.Addable2 do
  # def add1(a)
  defimpl Corner.Addable, for: String do
    Kernel.def(add(a, b), do: a &lt;&gt; b)
  end

  Kernel.def say_hello() do
    IO.puts(&quot;Hello&quot;)
  end
end

Corner.Addable2.say_hello()
</code></pre>
<p>但是要注意第 4 行, 这里使用 <code>Kernel.def</code> 远程方法调用的语法来调用 <code>def/2</code>,
因为在 <code>defprotocol</code> 上下文中, 特意排除了核心模块 <code>def/2</code> 的导入.</p>
<p>在实验上面的代码片段前, 我以为 <code>defprotocol</code> 上下文中, 必须有 <code>def/1</code> 语句,
但是现在明白, 不是的. 起初还以为, <code>defprotocl</code> 上下文中, 不可以定义自己的函数,
现在发现, 可以使用远程方法调用的语法, 用 <code>Kernel.def/2</code> 来定义自己的函数;
就像上面的代码第 7~9 行中那样.</p>
<p>最后强调一下: 虽然可以像上面的代码片段那样, 用 <code>defprotocol</code> 来定义模块,
但是绝对不推荐这样做.</p>
<p><strong>结论</strong>: 在 <code>defprotcoc</code> 定义的上下文中, 不能为正在定义的协议的提供实现.
或者说, 宏调用 <code>defimpl Protocol,...</code>, 中的 <code>Protocol</code> 对应的模块必须是闭合的.</p>
<p>那么 <code>defimpl</code> 可以嵌套自己吗?</p>
<pre><code class="language-elixir">defimpl Corner.Addable, for: Tuple do
  def add(a, b) do
    Tuple.append(a, b)
  end

  defimpl Corner.Addable, for: BitString do
    def add(a, b) do
      a &lt;&gt; b
    end
  end
end
</code></pre>
<p><strong><code>defimpl</code> 中可以嵌入 <code>defimpl</code>; <code>defimpl</code> 在 <code>defimpl</code> 调用的上下文中,
与在顶层的作用域上下文中, 没有区别</strong>.</p>
<p>这还真的出乎我的意料. 但是这样做, 除了让代码变得丑陋外, 一点其他用处也没有.</p>
<p><code>def</code> 和 <code>defp</code> 是用来在模块中定义函数的. 函数不可以嵌套定义,
所以我预计, 在 <code>def</code> 上下文中, 是不可以调用 <code>defimpl</code> 的.
但是还是让我们实验一下吧.</p>
<pre><code class="language-elixir">defmodule EmbedImplToFun do
  def fun() do
    defimpl Addable, for: Tuple do
      def add(a, b) do
        Tuple.concat(a, b)
      end
    end
  end
end
</code></pre>
<p>又超出了预期了, 居然可以!</p>
<p>那么可以预期, 在 <code>def</code> 中也是可以调用 <code>defmodule/2</code>.</p>
<p>Elixir 中不允许命名函数嵌套, 但是知道了上面的知识,
我们就可以让函数返回模块, 然后在模块中定义命名函数,
以这种迂回的方式来实现函数的嵌套.</p>
<p>详细讨论见<a href="./ch12.cold_knowledge.html">冷知识章节</a>.</p>
<h2 id="协议对函数的限制与辅助"><a class="header" href="#协议对函数的限制与辅助">协议对函数的限制与辅助</a></h2>
<p>让我们再回到对协议的讨论上来.</p>
<p>协议看起来足够的简单. 似乎 <code>defprotocol</code> 只是作了限制的 <code>defmodule/2</code>: 其上下文中,
只能使用 <code>def/1</code> 宏.</p>
<p>但是实际上不是这么简单的.</p>
<p>首先协议对其中的定义函数是有限制的: 协议中的函数, 不可以为零元函数.
所以在 <code>defprotocol</code> 上下文中使用的 <code>def/1</code> 是重新定义的, 而不是导入的
<code>Kernel.def/1</code>. 当我们在协议中定义零元函数的时候, 会引发编译错误.</p>
<pre><code class="language-elixir">defprotocol ZeroArityFun do
  def sayHi()
end
</code></pre>
<p>上面我们展示了, <code>defprotocol</code> 对 <code>def/1</code> 的限制;
接下来, 我们会看到协议对函数也有辅助:
协议会对其中定义的函数的第一个参数做类型检查.</p>
<pre><code class="language-elixir">defprotocol Corner.Protocol do
  def sub_one(a)
  def add_one(a)
end

alias Corner.Protocol

defimpl Protocol, for: Integer do
  def sub_one(a) do
    IO.puts(&quot;sub_one(i)&quot;)
    a - 1
  end

  def add_one(a) do
    a + 1
  end
end

defimpl Protocol, for: Float do
  def sub_one(a) do
    IO.puts(&quot;sub_one(f)&quot;)
    a - 1
  end

  def add_one(a), do: a + 1
end

defimpl Protocol, for: BitString do
  def sub_one(&lt;&lt;_::utf8, rest::binary&gt;&gt;) do
    rest
  end

  def add_one(a), do: a &lt;&gt; &quot;one&quot;
end

Protocol.sub_one(1)
Protocol.sub_one(1.0)
Protocol.sub_one(&quot;Hello&quot;)
Protocol.add_one(1) |&gt; IO.inspect(label: &quot;add_one(1)&quot;)
Protocol.add_one(1.0) |&gt; IO.inspect(label: &quot;add_one(1.0)&quot;)
Protocol.add_one(&quot;One + &quot;) |&gt; IO.inspect(label: &quot;add_one(\&quot;One + \&quot;)&quot;)
</code></pre>
<p>实际上, 协议对函数的辅助, 只是实现对模块的动态调度的自然结果;
而对函数的限制, 则是实现动态调度的必然要求.</p>
<p>协议实际帮助我们消弭模块名, 来实现函数的动态调度.
但是 Elixir 动态调度只能通过模式匹配来完成.
函数调用的匹配包括一下内容的匹配:</p>
<ol>
<li>模块名</li>
<li>函数名</li>
<li>参数模式, guard 子句</li>
</ol>
<ul>
<li>协议要动态调度, 就是要消除模块之间的差异的, 所以在这里, 模块不能作为动态调度的依据了.</li>
<li>协议的实现中, 函数名都是一样的, 所以它自然也不能用作动态调度的依据.</li>
<li>零元函数, 因为没有参数, 所以最后可以用来区分不同函数的因子, 也不再有用.</li>
</ul>
<p>这就是协议上下文中要求 <code>def/1</code> 定义的函数, 必须至少含有一个参数的原因.</p>
<p>上面我们看到了, 协议的确做到了对协议实现模块的动态调度. 但是它是如何做到的呢?</p>
<h2 id="协议动态调度"><a class="header" href="#协议动态调度">协议动态调度</a></h2>
<p>Elixir 协议模块文档的<a href="https://hexdocs.pm/elixir/Protocol.html#module-reflection">反射章节</a>,
告诉我们: 每个协议模块, 都会包含了以下三个用来完成, 协议及其实现模块的反射操作的函数:</p>
<ol>
<li><code>__protocol__/1</code> 返回这个协议模块的相关的元信息.</li>
<li><code>impl_for/1</code> 返回给定数据的处理模块, 或者返回 <code>nil</code>.</li>
<li><code>impl_for!/1</code> 和上面的函数类似, 但是如果没有找到对应的实现的话, 会引发异常.</li>
</ol>
<p>所以通过 <code>impl_for</code> 或 <code>impl_for!</code> 可以完成对实现模块的动态调用.
比如我们上面定义的 <code>Corner.Addable</code> 协议,
<code>defprotocol</code> 对应的模块中, <code>add/2</code> 函数就可以非常简单的这样来实现<sup class="footnote-reference"><a href="#generater">2</a></sup>:</p>
<pre><code class="language-elixir">defmodule Corner.Addable do
  #...
  def add(a,b) do
    m = impl_for!(a)
    m.add(a,b)
  end
end
</code></pre>
<div class="footnote-definition" id="generater"><sup class="footnote-definition-label">2</sup>
<p>这是我的猜测, 所以 <code>defpotocol</code> 真正产生的代码和这里的代码肯定不一样.</p>
</div>
<p>但是 <code>impl_for</code> 和 <code>impl_for!</code> 又是如何完成它们的工作的呢?</p>
<p>前面我们已经知道, 协议的实现模块的模块名都是以协议模块的模块名为前缀的.
要完成 <code>impl_for</code> 和 <code>impl_for!</code> 可以分成两步走:</p>
<ol>
<li>在运行时获取所有的模块, 并依据模块名筛选出以协议名为前缀的模块.
但是这样找出的模块不能保证就一定是协议的实现.</li>
<li>探测这些找到的模块的元信息, 来确认模块是否的确是协议的实现.</li>
</ol>
<p>那么第一个关键就是如何在运行时获取系统中的模块呢?
Erlang 的标准库的 <code>:code</code> 模块提供了这样两个函数:</p>
<ol>
<li><code>all_available/0</code></li>
<li><code>all_loaded/0</code></li>
</ol>
<p>顾名思义, 这两个函数: 第一个用来获取所有的可以加载到系统中的模块;
第二个用来获取所有加载到系统中的模块.</p>
<p>知道了这些知识, 第一步就不难完成了.</p>
<p>接下来我们探索一下, <code>defprotocl</code> 和 <code>defimpl</code> 如何配合,
以便可以通过模块的元信息来确认某个模块是协议的实现的.
协议的实现模块, 有一个 <code>:__protocol__</code> 属性, 其值为:
<code>[protocol: Protocol, for: Type]</code>.
我们可以通过 <code>ProtoclImpl.__info__(:attributes)</code> 或
<code>Module.module_info(:attributes)</code>来获模块的所有的属性.
这两个函数返回的都是关键字列表, 因此我们可以通过 Access 行为来获取 <code>:__protocol__</code>
对应的值. 下面的代码, 获取了 <code>Corner.Addable.Integer</code> 模块的
<code>:__protocol__</code> 属性的值:</p>
<pre><code class="language-elixir">Corner.Addable.Integer.module_info(:attributes)[:__protocol__]
</code></pre>
<p>所以第二步也就非常清楚了.</p>
<ol>
<li>根据数据, 判断对应的模块. 我想相应的代码, 大概是这样的:
<pre><code class="language-elixir">def data_to_module(d) do
  cond do
    is_tuple(d) -&gt; Tuple
    is_atom(d) -&gt; Atom
    is_list(d) -&gt; List
    is_bitstring(d) -&gt; BitString
    is_integer(d) -&gt; Integer
    is_float(d) -&gt; Float
    is_function(d) -&gt; Function
    is_pid(d) -&gt; PID
    is_map(d) -&gt; Map
    is_port(d) -&gt; Port
    is_reference(d) -&gt; Reference
    is_struct(d) -&gt; :struct
    _ -&gt; Any
  end
end
</code></pre>
</li>
<li>根据协议实现的 <code>:__protoco__</code> 属性值, 来找到合适的处理模块, 代码大概是这样:
<pre><code class="language-elixir">def filter([protocol: pro, for: mod ], d) do
  t = data_to_module(d)
  if t == :struct and %mod{} = d do
    true
  else
    mod == t
  end
end
</code></pre>
</li>
</ol>
<p>那么 <code>imp_for</code> 和 <code>impl_for!</code> 大概就是这样的:</p>
<pre><code class="language-elixir">def impl_for(d) do
  :code.all_loaded()
  |&gt; Enum.map(&amp;elem(&amp;1,0))
  |&gt; Enum.filer(&amp;by_module_name_prfix(&amp;1,__MODULE__))
  |&gt; Enum.find(nil, &amp;filter(&amp;1.module_info(:attributes)[:__impl__], d))
end
def impl_for!(d) do
  t = impl_for(d)
  if t, do: t, else: raise Protocol.UndefinedError, d
end
</code></pre>
<h2 id="elixir-的实现"><a class="header" href="#elixir-的实现">Elixir 的实现</a></h2>
<p>在我自己构思以上的实现后, 我发现, 我能看懂 Elixir 的 <code>impl_for</code> 的实现了.
其源码在于<a href="https://github.com/elixir-lang/elixir/blob/v1.13.1/lib/elixir/lib/protocol.ex#L817">protocol.ex 的第 817 ~ 877行</a>.</p>
<p>如果把其中的宏展开的话, 代码是这样的:</p>
<pre><code class="language-elixir">defmacrop any_impl_for()do
  if @fallback_to_any do
    quote do: unquote(__MODULE__.Any).__impl__(:target)
  else
    nil
  end
end

@spec impl_for(term) :: atom | nil
def impl_for(data)

# What is this _v_ ?
def impl_for(%struct{}) do
  struct_impl_for(struct)
end

def impl_for(data) when is_integer(data) do
  # Note this one.....................v
  target = Module.concat(__MODULE__, Integer)
  try do
      target.__impl__(:target)
  rescue
    UndefinedFunctionError -&gt; any_impl_for
  end
end
def impl_for(data) when is_float(data) do
  # Note this one.....................v
  target = Module.concat(__MODULE__, Float)
  try do
    target.__impl__(:target)
  rescue
    UndefinedFunctionError -&gt; any_impl_for
  end
end

...

def impl_for(_) do
  any_impl_for
end
defp struct_impl_for(struct) do
  target = Module.concat(__MODULE__, struct)
  try do
    target.__impl__(:target)
  rescue
    UndefinedFunctionError -&gt; any_impl_for
  end
end
</code></pre>
<p>这样的实现, 确实高明. 宏的代码共 60 行; 每个基础类型, 展开后 8 行代码,
全部基础类型的 <code>impl_for</code> 子句就有: $8\times 11 = 88$ 行.
我这里的代码所以短, 是因为我只对 Integer 和 Float 做了展开,
其他 9 个基本类型的账号, 都用 <code>...</code> 代替的缘故.</p>
<p>通过查看 Elixir 的源码, 还可以知道, 每个协议的实现模块中都有一个
<code>__impl__(:target)</code> 函数. 这是 <code>defimpl</code> 与 <code>defprotocol</code>
打的配合, 为的是消除命名冲突.</p>
<p>Elixir 的实现, 时间复杂度为 O(0), 而我的实现, 实际复杂多为 O(1). 😳</p>
<p>在上面的代码片段的第 11 行, 有一个不常见的语法.
对一个结构对象 <code>struct_obj</code> 来说, <code>%s{} = struct_obj</code>,
那么变量 <code>s</code> 中绑定的内容就是 <code>struct_obj</code> 结构所在模块的名字.</p>
<pre><code class="language-elixir">defmodule Corner.Point do
  defstruct x: 0, y: 0
end

alias Corner.Point, as: P
obj = %P{}
%module{} = obj
module == Corner.Point # true
</code></pre>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="ch09.module.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch11.macro.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="ch09.module.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="ch11.macro.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    <script type="text/javascript" src="theme/mermaid.min.js"></script>
    <script type="text/javascript" src="theme/mermaid-init.js"></script>


</body>

</html>