<!DOCTYPE html>
<html lang="encn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="The Corner of Elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第十一章 如何理解宏 — The Corner of Elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-4173292633.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="https://keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
The Corner of Elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch11.macro.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第十一章 如何理解宏</span>
</h1>

<h2 id="宏与语言分类" class="section-heading">
  <a href="#宏与语言分类" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">宏与语言分类</p>
  </a>
  宏与语言分类
</h2>
<p>宏是什么? 这似乎是一个非常容易掌握的概念. 我的理解是这样的:
宏是写给编译器的指令. 这个定义非常宽泛, 从 C 这样的最简单的文本替换宏,
到 Lisp 这样的对抽象语法树做处理的宏, 都可以涵盖.</p><p>这样的理解不能说错误, 但是取没有抓住宏的本质.
我发现, 这就是为什么, 我现在学习 Elixir 的时候,
时常遇到困惑的一个根本原因.</p><p>所以如此, 和我的知识储备有关系.
我学习和熟练掌握的编程语言中, 宏在其中要么基本上没有地位(Python, Javascript),
要么只有非常非常小的作用(C, C++). 所以对宏的理解,
才会一直停留在概念的阶段.</p><p>按照我们的定义, 宏只能是编译型语言中才会出现的概念.
因为解释性的语言, 没有编译器的存在.
当然了, 我知道也理解, 现在大部分的解释器,
实际上也是要做编译器要做的工作的. 所以理论上, 也应该有宏的.
但是对于解释性的语言来说, 要区分宏和普通的代码是困难的.
因为代码的执行和宏的执行, 概念上有先后的两个动作,
对于解释性的语言, 从外部观察时, 这两个动作是难以区分的.
但是对于编译型的语言, 因为编译代码和运行程序可以做到时间上间断,
所以可以清楚区分它们.</p><p>例如, 同样的关于外部代码的导入的语法,
C/C++ 中以 <code class="inline">#include</code> 的形式出现, 通过预处理,
我们可以清楚的体会到宏的存在.</p><p>反观 Javascript 中, 以 <code class="inline">import</code> 语句的形式出现的相同功能,
不难想象, Javascript 解释器与 C 编译器做了大量的相同的工作.
但是 Javascript 解释器为 <code class="inline">import</code> 语句做的工作, 从系统外部难以观察出来,
如果不考虑程序的执行的副作用的话.</p><p>不那么严格的解释, 可以认为解释性语言, 解释器对源码是解释执行的.
而编译型的语言, 编译器是要编译源码的. 通常情况下,
<strong>编译</strong> 我理解就是做翻译, 把源码中的文本翻译成中央处理器(CPU)
或者虚拟机(VM) 可以理解的内容.</p><p>这样的理解对于普通的代码是没有问题的, 但是当考虑宏的时候,
编译器对宏做的事情就不能这样理解了.
普通的代码, 对编译器来说, 是要处理的数据; 但宏不是编译器要处理的数据,
而是其待执行的指令. 编译器对宏, 正像解释器对源码做的一样: 解释并执行它们.</p><p>拿一个社会生活的场景来对比一下, 也许就更清楚了.</p><p>一个对翻译品质有担当的翻译者, 在翻译的时候往往会和作者沟通;
如果两人关系更密切的话, 译者甚至拿到的翻译底本, 直接就有原作者的批注.
这些批注是写给译者的, 用来提醒译者原文的正确意图的.
这些内容(批注或者作者的答复), 虽然不是原书的内容,
但是它们对译文来说, 是必要的, 因为它们确确实实的影响译文的呈现,
进而影响读者对原文的理解. 在这里, 译者就是编译器; 原始的书稿内容是常规的代码;
作者的批注和答复, 就是宏; 译文就是编译后的目标码; 读者就是 CPU 或 VM.</p><p>在 C/C++ 以及 Erlang 这些语言中, 宏能完成的工作是非常少的,
大部分的工作还是要编译器完成的.
这正像是, 虽然作者可以答复译者的咨询, 或在书稿中做注释, 但主要的工作还是要由译者完成.
但是这样的意象在处理 Elixir 这样的宏的时候, 就不适用了.</p><p>例如, 对于 BEAM 虚拟机的最基本的编译单元--- ---<strong>模块</strong>来说.
在 Elixir 中, 我们必须使用宏 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a>.
它和 Erlang 中的 <code class="inline">-module(MODULE_NAME).</code> 做的工作完全不是一个数量级的.
<code class="inline">-module(MODULE_NAME).</code> 只是标记了模块的名字, 并没有涉及到模块的正文.
<a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 不一样, 它不但包含了模块的名字, 而且包含了模块正文.
所以脚注的意象在这里就不合适了. Elixir 宏的合适意象应该汉语屋的故事<a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a>.
译者对原文的翻译是智慧型的劳动; 汉语屋中的人做的却是机械的工作.</p><p>从语言学的角度来看, C/C++, Erlang 的宏不能构成一个图灵完备的语言,
或者至少设计的初衷不是把它们当作一个图灵完备的语言来设计的<a href="#fn:2" id="fnref:2" class="footnote" title="see footnote">2</a>.
但是 Elixir 中的宏是图灵完备的, 从这个角度来看
Elixir 的编译器实际上就是宏的解释器.
写常规的 Elixir 代码, 大量的是对内建宏的调用, 这就像是我们在其他语言中调用标准库一样;
而定义自己的宏, 也就是说元编程, 才像是用编程语言来完成编程任务,
只是元编程的任务是对编译器的功能进行扩增或修改.</p><h2 id="宏与编译器" class="section-heading">
  <a href="#宏与编译器" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">宏与编译器</p>
  </a>
  宏与编译器
</h2>
<p>Elixir 的编译器是 <code class="inline">elixirc</code>. 我们现在来探索一下编译器.</p><pre><code class="makeup elixir" translate="no"><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="8525259651-1">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p" data-group-id="8525259651-1">)</span></code></pre><p>把上面的代码保存到名为 hello-word.ex 文件中, 然后我们在命令行中输入
<code class="inline">elixirc hello-world.ex</code>, 然后我们就看到了 &quot;Hello, World!&quot;, 但是在当前的目录下面,
并没有产生 <code class="inline">hello_world.beam</code> 文件.</p><p>上面的代码片段, 以及它的运行的结果, 告诉我们, 在模块外的作用域中,
代码直接在编译时运行(输出 &quot;Hello World&quot;),
而不是把编译的结果保存到字节码文件中(所以没有 <code class="inline">.beam</code> 文件).</p><p>模块的外的代码, 编译器直接解释执行; 模块内的代码, 编译器是如何处理的呢?</p><pre><code class="makeup elixir" translate="no"><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6281388055-1">(</span><span class="s">&quot;Say hello outside Module!&quot;</span><span class="p" data-group-id="6281388055-1">)</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyModule</span><span class="w"> </span><span class="k" data-group-id="6281388055-2">do</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6281388055-3">(</span><span class="s">&quot;Say Hello in MyModule But not in function&quot;</span><span class="p" data-group-id="6281388055-3">)</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">hello</span><span class="w"> </span><span class="k" data-group-id="6281388055-4">do</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6281388055-5">(</span><span class="s">&quot;Say Hello in MyModule.hello()&quot;</span><span class="p" data-group-id="6281388055-5">)</span><span class="w">
  </span><span class="k" data-group-id="6281388055-4">end</span><span class="w">
</span><span class="k" data-group-id="6281388055-2">end</span></code></pre><p>把上面的代码保存到 <code class="inline">my_module.ex</code> 文件中, 然后使用 <code class="inline">elixirc my_module.ex</code>
命令来编译我们的文件. 在编译的过程中, 我们可以看到第 1 行和第 4 行的输出.
在当前目录下, 还看到了编译器产生的 <code class="inline">Elixir.MyMoule.beam</code> 文件.</p><p>这说明, <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 的第二个参数, <code class="inline">do</code>...<code class="inline">end</code> 块,
在 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 被调用的时候, 得到了执行.
其中的 IO 输出语句(第 4 行) 在编译时执行了,
所以我们在编译器的标准输出中, 看到了它的输出内容.
最后产生的 <code class="inline">Elixir.MyModule.beam</code> 文件,
则说明编译器还把其他的内容编译成了字节码.</p><p>现在我们启动 <code class="inline">iex</code>. 输入 <code class="inline">MyModule.hello()</code>,
按下回车后, 第 7 行的输出语句就显示出来了.
这说明, 我们的 <code class="inline">hello/0</code> 函数的确被编译到了字节码文件中.</p><p>在模块中, 不但可以调用 <code class="inline">def*</code> 这些宏, 还可以执行其他语句, 这还是让我十分的惊讶的.
因为 C++ 和 Java 的背景知识, 不由自主的总是把 Elixir 的模块和类的概念联系到一起.
但是在类的定义的作用域中, 基本上只可以使用赋值语句, 而且 <code class="inline">=</code> 的右值还必须是编译时常量,
其他控制结构, 或者函数调用都是不允许的. C 语言的全局作用域中, 基本上也是这样的要求.
即使在亲缘关系最近的 Erlang 中, 基本上也是一样.
控制结构, 函数调用, 都只能在函数的定义中使用.</p><p>如果一定要在其他语言中寻找对应物的话, 那么可能就是 Java 的静态块了.
Elixir 在 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 上下文中, <code class="inline">def*</code> 外的其他语句的执行情况,
和 Java 中, 对静态块处理还是有不同的: Java 中的静态块是编译到字节码中的,
且每次字节码被加载的时候, 都要被执行的.</p><p>而 <em>Elixir <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 上下文中, `def</em>` 之外的代码, 都是在编译时被解释执行了,
并<strong>没有</strong>被保存到字节码中*.</p><p>这一点我们可以通过启动 <code class="inline">iex</code> 的时候, 并没有看到代码片段中第 4 行的输出而得到确认.
或者, 我们可以可以使用 Elang 提供的库函数 <code class="inline">:beam.chunks/2</code>,
来查看编译后的代码的抽象码(字节码对应的汇编语言), 以此来更直观的证实我们的结论.</p><p>在 iex 中输入 <code class="inline">:beam_lib.chunks('Elixir.MyModule',[:abstract_code])</code>,
我们就看到了 <code class="inline">Elixir.MyModule.beam</code> 中保存的字节码对应的抽象码.</p><p>观察输出的抽象码, 不难发现, 其中的确有我们这里定义的 <code class="inline">hello/0</code> 函数;
而且真的找不到第 1 行和第 3 行相关的代码.
这全面的证实了我们上面对编译器的分析.</p><h2 id="宏与函数" class="section-heading">
  <a href="#宏与函数" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">宏与函数</p>
  </a>
  宏与函数
</h2>
<p>开始学习 Elixir 的时候, 最不习惯的是控制结构中的逗号和冒号.
比如 <code class="inline">defimpl ProtocolName, for: Integer do...</code>,
协议名后面的 <code class="inline">,</code> 为什么是必须的呢? 还有 Elixir 中, <code class="inline">for</code> 明明是一个保留字,
为什么这里还必须用关键字的语法糖呢?</p><p>所以会有这些疑问在于, 初学 Elixir, 把 Elixir 中, 用作控制结构的宏,
当作是其他语言的保留字了. 只有认识到宏不是保留字, 而是特殊的函数,
才能更好的理解上面的问题.</p><p>宏是被编译到字节码中的, 我们还知道,
Erlang 中只有模块属性和函数可以被编译到字节码中.
所以 Elixir 宏一定是特殊函数. 不然它不能被编码到字节码中.</p><p>认识到宏是特殊函数, 那么对宏的调用自然必须遵守对一般函数调用的规则.
这其中最重要的规则就是: 调用函数时, 当参数个数多于一个的时候,
参数之间是用 <code class="inline">,</code> 做分隔符的.
这实际上就解释了为什么宏调用的时候, 当宏的参数个数多余一个的时候,
会有 <code class="inline">,</code> 了.</p><p>在我最初的理解中, 我认为关键字列表语法糖 <code class="inline">do:</code> 是对保留字 <code class="inline">do</code> 的模仿.
但是认识到宏调用本质上也是函数调用, 那么这个理解就应该反转过来了,
关键字列表 <code class="inline">[do: ...]</code> 是合法的数据, 但是 <code class="inline">do</code> 保留字不是数据,
函数 (以及宏) 接受的应该是合法的数据,
所以 <code class="inline">do</code> 实际上的工作就是要创建 <code class="inline">[do: ...]</code>
这样的关键字列表.</p><p>如果宏也是函数, 为什么它那么特殊, 必须导入(<code class="inline">import</code>) 或请求 (<code class="inline">require</code>) 后,
才能调用宏呢? 或者换个角度来说: 宏是如何特殊于普通函数的?
请求(<code class="inline">require</code>) 又是如何帮助我们突破这种特殊性的?</p><p>让我们用实验来探索.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Explore.MacroDef</span><span class="w"> </span><span class="k" data-group-id="5933226383-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assign_one</span><span class="p" data-group-id="5933226383-2">(</span><span class="n">a</span><span class="p" data-group-id="5933226383-2">)</span><span class="w"> </span><span class="k" data-group-id="5933226383-3">do</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="5933226383-4">(</span><span class="s">&quot;assign_one running, a: </span><span class="si" data-group-id="5933226383-5">#{</span><span class="n">inspect</span><span class="p" data-group-id="5933226383-6">(</span><span class="n">a</span><span class="p" data-group-id="5933226383-6">)</span><span class="si" data-group-id="5933226383-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="5933226383-4">)</span><span class="w">

    </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w">
      </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5933226383-7">do</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="5933226383-8">(</span><span class="s">&quot;after the assign_one&quot;</span><span class="p" data-group-id="5933226383-8">)</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="5933226383-9">(</span><span class="n">a</span><span class="p" data-group-id="5933226383-9">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="k" data-group-id="5933226383-7">end</span><span class="w">

    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="5933226383-10">(</span><span class="s">&quot;assign_one ending&quot;</span><span class="p" data-group-id="5933226383-10">)</span><span class="w">
    </span><span class="n">ast</span><span class="w">
  </span><span class="k" data-group-id="5933226383-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">bar</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="w">
</span><span class="k" data-group-id="5933226383-1">end</span><span class="w">

</span><span class="nc">Explore.MacroDef</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="5933226383-11">(</span><span class="ss">:functions</span><span class="p" data-group-id="5933226383-11">)</span></code></pre><p>上面的代码中, 在模块中, 定义了 <code class="inline">assign_one/1</code> 宏 和 <code class="inline">bar/0</code> 函数.
调用 <code class="inline">module_info(:funstions)</code> 可以看到模块的导出的所有函数.</p><ol><li><code class="inline">module_info/0-1</code> 是所有的 Elixir/Erlang 模块都有的函数.</li><li><code class="inline">__info__/1</code> 是 Elixir 的 Module 行为提供的, 所有的 Elixir 模块都实现了这个行为.</li><li><code class="inline">bar/0</code> 是模块中定义的公开方法</li><li><code class="inline">Macro-assign_one/2</code> 看起来是和我们的宏定义中 <code class="inline">assign_one</code> 相关.</li></ol><p>这首先证实了, Elixir 宏是特殊的 Erlang 函数. 接下来,
我们来看看 <code class="inline">require</code> 帮我们做了哪些工作.</p><p>首先我们看看 require 之后, 代码的效果.
然后我们设法不用 require , 达到同样的效果.
如果我们能做到, 而且确切的知道, 做到同样的效果的确切步骤,
那么大概 <code class="inline">require</code> 就是帮助我们做这些事情的.
当我们对 <code class="inline">require</code> 的运行机制有了大约的了解后,
也许可以帮助我们更轻松的阅读 Elixir 的源码, 从而真正的理解 <code class="inline">require</code>.</p><pre><code class="makeup elixir" translate="no"><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7536176482-1">(</span><span class="s">&quot;Beign&quot;</span><span class="p" data-group-id="7536176482-1">)</span><span class="w">
</span><span class="kn">alias</span><span class="w"> </span><span class="nc">Explore.MacroDef</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">M</span><span class="w">
</span><span class="n">b_reqs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">requires</span><span class="w">

</span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7536176482-2">do</span><span class="w">
  </span><span class="nc">M</span><span class="o">.</span><span class="n">assign_one</span><span class="p" data-group-id="7536176482-3">(</span><span class="no">nil</span><span class="p" data-group-id="7536176482-3">)</span><span class="w">
</span><span class="k" data-group-id="7536176482-2">rescue</span><span class="w">
  </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7536176482-4">(</span><span class="n">e</span><span class="p" data-group-id="7536176482-4">)</span><span class="w">
</span><span class="k" data-group-id="7536176482-2">end</span><span class="w">

</span><span class="kn">require</span><span class="p" data-group-id="7536176482-5">(</span><span class="nc">M</span><span class="p" data-group-id="7536176482-5">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7536176482-6">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;require return&quot;</span><span class="p" data-group-id="7536176482-6">)</span><span class="w">
</span><span class="nc">M</span><span class="o">.</span><span class="n">assign_one</span><span class="p" data-group-id="7536176482-7">(</span><span class="n">a</span><span class="p" data-group-id="7536176482-7">)</span><span class="w">
</span><span class="n">binding</span><span class="p" data-group-id="7536176482-8">(</span><span class="p" data-group-id="7536176482-8">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7536176482-9">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;binding&quot;</span><span class="p" data-group-id="7536176482-9">)</span><span class="w">

</span><span class="p" data-group-id="7536176482-10">(</span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">requires</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">b_reqs</span><span class="p" data-group-id="7536176482-10">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7536176482-11">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;The diff of __ENV__.requires&quot;</span><span class="p" data-group-id="7536176482-11">)</span></code></pre><p>上面的代码运行后, 控制台的输出结果不难预测.
但是去掉第 12 的注释后, 控制台的输出是这样的:</p><pre><code class="makeup elixir" translate="no"><span class="n">assign_one</span><span class="w"> </span><span class="n">running</span><span class="p">,</span><span class="w"> </span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0797520351-1">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0797520351-2">[</span><span class="ss">line</span><span class="p">:</span><span class="w"> </span><span class="mi">12</span><span class="p" data-group-id="0797520351-2">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="0797520351-1">}</span><span class="w">
</span><span class="n">assign_one</span><span class="w"> </span><span class="n">ending</span><span class="w">
</span><span class="s">&quot;Beign&quot;</span><span class="w">
</span><span class="p" data-group-id="0797520351-3">%</span><span class="nc" data-group-id="0797520351-3">UndefinedFunctionError</span><span class="p" data-group-id="0797520351-3">{</span><span class="w">
  </span><span class="ss">arity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="ss">function</span><span class="p">:</span><span class="w"> </span><span class="ss">:assign_one</span><span class="p">,</span><span class="w">
  </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w">
  </span><span class="ss">module</span><span class="p">:</span><span class="w"> </span><span class="nc">Export.MacroDef</span><span class="p">,</span><span class="w">
  </span><span class="ss">reason</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="w">
</span><span class="p" data-group-id="0797520351-3">}</span><span class="w">
</span><span class="kn">require</span><span class="w"> </span><span class="ss">return</span><span class="p">:</span><span class="w"> </span><span class="nc">Export.MacroDef</span><span class="w">
</span><span class="k">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">assign_one</span><span class="w">
</span><span class="ss">binding</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0797520351-4">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b_reqs</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0797520351-5">[</span><span class="nc">Application</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel.Typespec</span><span class="p" data-group-id="0797520351-5">]</span><span class="p" data-group-id="0797520351-4">]</span><span class="w">
</span><span class="nc">The</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="ss">requires</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0797520351-6">[</span><span class="nc">Export.MacroDef</span><span class="p" data-group-id="0797520351-6">]</span></code></pre><p>为什么宏调用的输出会先于第 1 行的输出呢?</p><p>这时因为宏的调用是在 Elixir 的编译器中运行的,
Elixir 编译器<strong>把普通的函数调用编译为字节码</strong>;
而<strong>对宏调用, 则在编译时执行宏调用, 然后把宏调用返回的 ast 编译为字节码</strong>.
编译结束后, 这些字节码, 交给 Erlang 运行时系统 (Erlang Runtime System, ERTS)
来执行的这些字节码.</p><p>因此, 输出中的 1, 2 行是 Elixir 编译器的输出结果,
其他的则是 ERTS 执行字节码的结果.</p><p>如果我们把上面代码中第 5 行中的 <code class="inline">nil</code> 改为其他的变量, 像第 12 行中那样,
那么编译器会报错, 提示变量不存在.
而调用 <code class="inline">require</code> 后, 第 12 行代码中, <code class="inline">a</code> 被转化为了 ast: <code class="inline">{:a, [line: 12], nil}</code>.
这是 <code class="inline">require</code> 在编译时做的工作.</p><p>观察输出, 可以知道 <code class="inline">require</code> 返回请求的模块名 (输出的 11 行),
而且修改了运行时的环境(输出的倒数第二行). 这是 <code class="inline">require</code> 对运行时的影响.</p><p>现在只剩下最后一点了. 我们定义的 <code class="inline">assign_one</code> 是一个一元的宏, 但是
<code class="inline">MACRO-assing_one</code> 是一个二元的函数. 所以, <code class="inline">require</code> 除了帮助我们把 <code class="inline">a</code>
转化为 ast 外, 还自动为我们提供了第一个参数.</p><p>这个参数就是当前的执行环境, 也就是 <code class="inline">__ENV__</code> 的值. 下面, 让我们看看,
不借助 <code class="inline">require</code>, 如何来调用宏.</p><pre><code class="makeup elixir" translate="no"><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="2837155266-1">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M</span><span class="o">.</span><span class="s">&quot;MACRO-assign_one&quot;</span><span class="p" data-group-id="2837155266-2">(</span><span class="bp">__ENV__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2837155266-3">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2837155266-4">[</span><span class="p" data-group-id="2837155266-4">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="2837155266-3">}</span><span class="p" data-group-id="2837155266-2">)</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2837155266-5">(</span><span class="s">&quot;MARCO-assign_one have run.&quot;</span><span class="p" data-group-id="2837155266-5">)</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2837155266-6">(</span><span class="s">&quot;Now run the ast in ERTS.&quot;</span><span class="p" data-group-id="2837155266-6">)</span><span class="w">

  </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="2837155266-7">(</span><span class="n">ast</span><span class="p" data-group-id="2837155266-7">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">elem</span><span class="p" data-group-id="2837155266-8">(</span><span class="mi">1</span><span class="p" data-group-id="2837155266-8">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="2837155266-9">(</span><span class="p" data-group-id="2837155266-9">)</span><span class="w">
</span><span class="k" data-group-id="2837155266-1">end</span><span class="w">

</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2837155266-10">(</span><span class="s">&quot;before call fun.()&quot;</span><span class="p" data-group-id="2837155266-10">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2837155266-11">(</span><span class="s">&quot;=========================&quot;</span><span class="p" data-group-id="2837155266-11">)</span><span class="w">
</span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="2837155266-12">(</span><span class="p" data-group-id="2837155266-12">)</span></code></pre><p>上面的代码的输出为:</p><pre><code class="makeup elixir" translate="no"><span class="n">before</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="7615503349-1">(</span><span class="p" data-group-id="7615503349-1">)</span><span class="w">
</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">===</span><span class="o">=</span><span class="w">
</span><span class="n">assign_one</span><span class="w"> </span><span class="n">running</span><span class="p">,</span><span class="w"> </span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7615503349-2">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7615503349-3">[</span><span class="p" data-group-id="7615503349-3">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="7615503349-2">}</span><span class="w">
</span><span class="n">assign_one</span><span class="w"> </span><span class="n">ending</span><span class="w">
</span><span class="nc">MARCO</span><span class="o">-</span><span class="n">assign_one</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">run</span><span class="o">.</span><span class="w">
</span><span class="nc">Now</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">ERTS</span><span class="o">.</span><span class="w">
</span><span class="k">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">assign_one</span><span class="w">
</span><span class="p" data-group-id="7615503349-4">[</span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="7615503349-4">]</span></code></pre><p>注意这里的输出顺序.
可以看出, 这完全是 ERTS 对字节码执行的结果.</p><p>在匿名函数 <code class="inline">fun</code> 的定义中:</p><ol><li>我们执行了 <code class="inline">MACRO-sign_one/2</code> 函数, 它返回了 <code class="inline">ast</code>, 这模拟的是 Elixir
编译器对宏的调用.</li><li>把 <code class="inline">ast</code> 交给 <code class="inline">Code.eval_quote</code> 执行.
这是模拟 REST 对字节码的执行. REST 执行字节码后, 会影响 REST 的环境.
<code class="inline">Code.eval_quote</code> 返回一个二元元组, <code class="inline">{value, binding}</code>,
<code class="inline">value</code> 是 ast 代码运行的最终结果, <code class="inline">bingding</code> 表示代码运行后, 环境的状态.</li></ol><p>上面的步骤缺少了对 ast 的编译. <code class="inline">Code.compile_quote</code> 可以用来编译 ast,
但是如果 ast 对应的代码不是一个模块, 那么 <code class="inline">Code.compile_quote</code> 就只是执行这些 ast,
而不是把他们编译为字节码. 并且 <code class="inline">Code.compile_quote</code>
还抛弃了执行 ast 对环境造成的影响.</p><p>所以, 在 Erlang 的环境中, 没有办法使用 Elixir 宏提供的便利.</p><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>百度百科词条<a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4/3581768">≪中文房间≫</a></p></li><li id="fn:2"><a class="reversefootnote" href="#fnref:2" title="return to article">&amp;#x21A9;</a><p>有关 C 语言宏的图灵完备性的讨论见 <a href="https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete">https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete</a></p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch10-protocol_and_behaviour.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第十章 协议与行为
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch12-process.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第十二章 进程
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
