searchNodes=[{"doc":"","ref":"readme.html","title":"主页","type":"extras"},{"doc":"如果想阅读中文版本请点击 这里 . Read in English, click here .","ref":"readme.html#the-corner-of-the-elixir","title":"主页 - The Corner of the Elixir","type":"extras"},{"doc":"","ref":"index_cn.html","title":"目录","type":"extras"},{"doc":"第一章 前言 第二章 加和减 第三章 模式匹配 第四章 括号 第五章 定制新结构 第六章 异步编程 第七章 管道操作符 第八章 错误处理 第九章 模块 第十章 协议与行为 第十一章 如何理解宏 第十二章 进程 附录 冷知识","ref":"index_cn.html#the-corner-of-elixir","title":"目录 - The Corner of Elixir","type":"extras"},{"doc":"","ref":"ch01-intruction.html","title":"第一章 前言","type":"extras"},{"doc":"Elixir 是一个非常优秀的编程语言. 一方面, 非常容易就能对这个语言有一个基本的理解; 但是另一方面, 用它来完成实际的工作的时候, 却又总时时感到手不应心, 磕磕巴巴. 我想这应该不是我一个人的感觉. 大概很多人和我一样, 感觉 Elixir 的知识琐碎, 难以对其有系统性的把握. C++ 以语法丰富而著称, 虽然我不敢自信满满的说自己对 C++ 的所有语法都掌握, 但是掌握了最基本的语法, 就可以完成绝大部分的编程工作了. Elixir 的情况不同, 即使我读完三四本 Elixir 教程后, 写 Elixir 的代码, 还是感觉茫然不知所措. 所以会如此, 首先是因为 Elixir 的文档还不够完善. Elixir 这个语言, 背后没有大公司的支持, 现在的官方学习教程, 只介绍了这个语言最重要的概念, 距离作为全面的教程还差很远. 这一点和 Java 的官方教程对比的话就非常的清楚. 其次, 和 Elixir 的血统相关. Elixir 主要从 Erlang 和 Ruby 获自己的设计灵感. 当前 Elixir 社区的主要参与者, 也同时是这两个社区的活跃者, 所以 Elixir 社区的文档中, 存在大量的关于 Erlang 或者 Ruby 的隐形知识, 这进一步的加大了学习 Elixir 的难度. 从语言基因来说, 虽然 Elixir 是 Erlang 和 Ruby 的孩子, 但它毕竟是一个独立的语言. 我的很多困惑, 其实就是因为拿 Elixir 的特性与 Erlang 或 Ruby 硬类比而产生的. 还有一些是则是对 Elixir 特性来源的错误的识别, 比如本来来自 Ruby 的语法概念, 却错误认作了 Erlang 的, 或者反过来. 第三种是错误的预期, 比如 Erlang 或 Ruby 的特色语法, 却认为 Elixir 中也一样工作. 这些错误, 不是因为知道的少, 而是因为知道的多而引发的概念混乱. 这种情况, 在学习别的语言的时候, 或多或少都会有所表现. 但在学习 Elixir 的时候所以特别明显, 可能和我原来的知识背景有关. 我最熟悉的编程语言, 都来自同一个语言家族(也就是 C 语言家族), 其中的语法变异比较小. 但是无论是 Erlang 还是 Ruby, 与 C 语言家族之间的语法的差距都相当大. 而且, Erlang 和 Ruby 之间的差异也非常大. 这使得学习 Elixir 的时候新概念的密度非常高. 再次, Elixir 社区中, 对专业词汇的选择独具风格. 这种风格, 有些是受语言基因的影响, 比如应用程序, 客户端, 服务器等等概念, 在 Erlang 中的所指, 本来就和其他语言中的不同. 这种不同使得阅读相关文档后, 不能第一时间吸收, 把握其本质. 还有一些不是来源于概念的继承, 只能归结为社区的风格. 比如 Socket 在 Phoenix 中所指就和其他领域所指不同, 当然这些相对来说容易克服. 最后, 文档不完善, 概念的密集高, 语汇选择的独特, 所有这些因素综合在一起, 其结果就是各种概念的相关资料分散在不同的地方. 学习的材料来源的分散, 使得学习相关特性时, 自然就是零散而不是系统的. 这进一步的加剧了, 学习 Elixir 不系统的感觉.","ref":"ch01-intruction.html#%E5%AD%A6%E4%B9%A0-elixir-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E9%9A%BE","title":"第一章 前言 - 学习 Elixir 为什么那么难","type":"extras"},{"doc":"我喜欢 Elixir, 不但因为 OTP 平台提供的程序自愈功能, 还因为 Elixir 语法的优雅与务实: 作为一个函数式编程语言, 第一不关心范畴论, 第二不强调 Point-free style 1 . 而这些是我以往以其他语言为工具, 学习函数式编程的过程中, 遇到的最大障碍. 范畴论固然让我迷惘, 我总是记不得各种函子到底有什么对应的函数, 这还可以归结为自己没有用心记忆; 但更让我沮丧的是 Point-free style. Point-free style 让我感觉惊艳, 在学习函数式编程之前, 从来没想过代码可以这样的若合符节. 这样的代码, 在我的智力理解范围之内, 因此总感觉自己也可以做到. 幻想使用这样的编码方式, 应该容易让人进入心流状态. 但现实是, 我写的代码基本上做不到 Point-free. 因为在写函数的时候, 不能预期使用者会如何调用我的代码. 所以当我试图让自己的写的函数也可以做到 Point-free 的时候, 非但没有体会到心流, 感受的反而是沮丧和无力. 答案就在哪里, 似乎就在眼前, 已经看到它的脚步, 甚至嗅到了它的味道, 但是就是不能把它抓住. 因此, 我总是怀疑自己理解和掌握不了函数式编程. 学习 Elixir, 让我感觉不到那么多的压力. 大部分时间, 感觉不到自己在函数式编程. 但是使用 Elixir 的时候, 我也遇到了很多困惑的地方, 有些是因为函数式编程范式的限制, 有些是 Elixir 语言设计的原因, 或者说是自己对 Elixir 语言的理解的问题. 所以这本书, 首先是写给我自己的, 是我自己使用 Elixir 的心智调适笔记. 有些编程的任务, 使用非函数的式的语言来处理, 解决方案简单直接, 非常明了. 但是如何把对应的方案迁移到 Elixir, 却需要仔细的思考如何来做. 写这本书, 就是希望它能帮助我, 让我能够对 Elixir 有系统性的把握, 从而帮助我, 在使用 Elixir 的时候, 可以像使用其他的非函数式编程语言那样, 能快速的找到相应的解决方案, 或者至少缩短这种思考的时间. 当然, 也希望这本书, 可以帮助正在适应 Elixir 的读者.","ref":"ch01-intruction.html#%E6%9C%AC%E4%B9%A6%E7%9A%84%E7%BC%98%E8%B5%B7","title":"第一章 前言 - 本书的缘起","type":"extras"},{"doc":"Elixir 的发展很快, 我写作的时候, 使用的是 Elixir 的 1.13.1 版本. 如果后续的 Elixir 版本有更新, 本书讨论的情形依旧发生改变, 本书的后续版本也会相应的更新. &amp;#x21A9; Point-free Style 是说通过组合新函数, 不涉及到函数参数的情况下, 完成新函数的定义.","ref":"ch01-intruction.html#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E","title":"第一章 前言 - 版本说明","type":"extras"},{"doc":"","ref":"ch02-plus_and_minus.html","title":"第二章 加和减","type":"extras"},{"doc":"使用 Elixir 编程的时候, 第一个让我困惑的地方就是加减运算符了. - 和 + 运算符号如此简单, 大部分情况下, 我们都不到会意识有什么问题存在. 但是在 Elixir 中, 我不止一次在这个地方被编译器无情的打脸. 而且刚开始, 挨打了还莫名其妙. ( 1 - 1 ) |&gt; IO . inspect ( label : &quot;1 -1&quot; ) a = 1 ( 1 - a ) |&gt; IO . inspect ( label : &quot;1 -a&quot; ) a - 1 在上面的代码示例, 是我学习 Elixir 中, 按照书籍示例的代码, 在 IEx 中输入的. 当我按照书中的代码, 输入 a - 1 时, 不小心写成了 a -1 , 就像上面的片段中最后一行那样. IEx 居然抛出了错误. 这出乎我的意料. 我完全想象不出, 为什么这里会有错误. 首先, 我知道变量 a 的值为 1, 难道 Elixir 中 1 - 1 不等于 0, 而是抛出错误? 我快速的在 IEx 中输入 1 - 1 , 当然没有问题了. 那会不会什么时候, 变量 a 的值类型改变了呢? a 的值不是数值 1, 而是字符串 &quot;1&quot; ? 于是我又加入调试语句, IO.inspect(a,label: &quot;a&quot;) . a 的值的确是数值 1, 那么我就更困惑了, 那怎么会出错呢? 困惑中, 我再试了一下, 这次输成了 1 - a , 居然得到了正确答案 0. 仔细比较后发现, 出错的代码, 变量在减号的后面, 那么改回去, a - 1 , 怎么又正确了? 灵异事件? 当时, 我刚开始学习 Elixir, 还有很多的内容等待我去学习, 既然正确了, 我就没有仔细追究背后的原因. 等我开始用 Elixir 写更长代码后, 当这个问题再次出现的时候, 错误提示更加莫名奇妙了. 但是总是和 - 或 + 相关, 而且最后问题的解决往往也就只是在 - 或 + 之前加一个空格. 但是为什么呢? 为什么会出现这样的问题呢? 因为不知道错误的原因, 所以即使了解了该如何解决, 还是让我非常的疑惑. 直到有一天我认真的阅读了编译器的错误提示. &quot;a -1&quot; looks like a function call but there is a variable named &quot;a&quot; . If you want to perform a function call , use parentheses : a ( - 1 ) If you want to perform an operation on the variable a , use spaces around the unary operator 如果不是因为理解了 &quot;a - 1&quot; 看起来像函数调用, 但是存在一个变量命名为 &quot;a&quot; , 那么这段提示就算我很早就注意到, 也依然是不知所云的. 为什么? 但是为什么会是这个样子呢? 其他编程语言, 写 a -1 不都没问题的吗? 这是几个知识点组合起来引发的迷惑. 1. Elixir 中函数调用时可以省略小括号 这就是为什么, 在 IEx 中, 我们可以像使用 shell 命令那样使用 cd , r h 等等函数的原因. 函数定义在模块中, 当被导入到其他环境后, 可以不带模块名, 而直接使用函数名来调用. 对于整数除法来说, 可以使用 div(1, 2) 来代替 Kernel.div(1,2) , 进一步地, 函数调用的小括号也是可以省略的, 省略小括号后, 就成了 div 1, 2 . 函数调用可以省略括号, 为什么要这样做呢? 我认为有以下两个原因. 零元无副作用的函数来实际上和常量一样. Elixir 和 Erlang 中, 也正是如此来使用零元无副作用的函数的. 比如 :math.pi . 如果必须加上小括号, 像 :math.pi() 的话, 就太不像常量了. Elixir 中使用宏来做元编程, 调用宏的时候不写括号, 代码的可读性更强. 不带括号, 使得宏调用, 看起来像是其他语言中的关键字. 对比一下: 不带括号的宏调用看起来更像关键字 加上括号的宏调用更像函数调用 import Module, only: [fun1: 1] import(Module, only: [fun1: 1]) 2. 操作符 - 身兼二职 -/2 是减法操作符. -/1 是取反操作符. 3. 变量和函数名使用的标识符规则一样 让我们再来看一下, a -1 引发的编译错误: ( CompileError ) : &quot;a -1&quot; looks like a function call but there is a variable named &quot;a&quot; . If you want to perform a function call , use parentheses : ` a ( + 1 ) ` If you want to perform an operation on the variable a , use spaces around the unary operator 看起来是因为编译器优先把标识符 a 解释为函数, 而实际上它是一个变量, 所以才引发错误的. 可是为什么编译器不首先把标识符解释为变量呢? 这样, 就可以把 a -1 解释为对 a 减去 1, 而不是以 -1 为参数来调用函数 a . 答案是编译器实际上就是优先把标识符解释为变量的, 但是有些时候, 编译器不能区分变量和函数. 首先, 让我来证明, 编译器的确是优先把小写字母开头的标识符解释为变量的.","ref":"ch02-plus_and_minus.html#%E9%97%AE%E9%A2%98%E7%9A%84%E6%8F%8F%E8%BF%B0","title":"第二章 加和减 - 问题的描述","type":"extras"},{"doc":"首先, 我们导入一个零元函数 :math.pi/0 , 然后再定义一个同名的变量 pi , 让我们看看, 使用标识符 pi 的时候, 得到的 :math.pi 的返回值, 还是我们自定义的变量的值. import :math , only : [ pi : 0 ] pi |&gt; IO . inspect ( label : &quot;before define variable pi&quot; ) pi = &quot;This is variabel pi!&quot; pi |&gt; IO . inspect ( label : &quot;after define variable pi&quot; ) 在定义变量 pi 之前, 我们使用标识符 pi , 用到的是当然是导入的零元函数. 但当我们定义变量 pi 之后, 再使用标识符 pi , 得到的是变量 pi 的值. 那么有没有可能是变量 pi 遮盖 (shadow) 了函数 :math.pi/0 ? 或者说, 如果先定义变量, 后导入零元函数, 编译器会不会把标识符 pi 解释为对函数 :math.pi/0 的调用呢? 当前的 IEx 环境中, 已经导入了 pi/0 函数, 如果读者跟随我的思路, 在你的 IEx 中实验的话, 那么你的环境中, 也已经导入了 pi/0 . 为了清晰起见, 让我们定义一个新的变量 e 和零元函数 e/0 , 来实验我们最新的假设. e = &quot;var e&quot; defmodule TempModule do def e , do : :math . exp ( 1 ) end import TemModule e |&gt; IO . inspect ( ) 输出为: &quot;var e&quot; . 因此, 我们可以得出结论, 同名的零元函数和变量, 出现在同一个上下文的时候, 无论变量和函数出现的顺序如何, 编译器都优先把标识符解释为变量.","ref":"ch02-plus_and_minus.html#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BC%98%E5%85%88%E8%A2%AB%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%8F%98%E9%87%8F","title":"第二章 加和减 - 标识符优先被解释为变量","type":"extras"},{"doc":"前面的章节, 我们说, 零元函数被同名的变量覆盖的了. 实际上不是的. 零元函数, 依旧是可访问的, 只是当有同名的变量存在的时候, 对零元函数的调用就不能省略小括号了. 例如下面的代码: pi |&gt; IO . inspect ( label : &quot;pi&quot; ) pi ( ) |&gt; IO . inspect ( label : &quot;pi() still is&quot; ) 其输出为: pi : &quot;This is variabel pi!&quot; pi ( ) still is : 3.141592653589793 对于有元函数来说, 函数没有不覆盖, 就更加清楚了. 我们以 Kernel.abs/1 为例, 核心模块 Kernel 中的函数都是默认导入的, 当我们定义了 abs 的变量后, 上下文中, 就同时出现了同名的变量和函数 --- --- abs . 但是像下面的代码所展示的那样: 当我们需要一个变量的时候, 获得就是一个变量; 当我们需要一个函数的时候, 获得就是一个函数. abs = - 2 abs |&gt; abs |&gt; IO . inspect ( label : &quot;abs |&gt; abs&quot; ) IO . inspect ( abs / 3 , label : &quot;abs/3&quot; ) IO . inspect ( 1 / abs , label : &quot;1/abs&quot; ) IO . inspect ( &amp; abs / 1 , label : &quot;&amp;abs/1&quot; ) IO . inspect ( abs - 9 , label : &quot;abs -9&quot; ) 上面的片段中, 第1, 3, 7 和 8 行中的 abs 都是变量, 而 4, 9 和 10 行的 abs 都是函数名. 看起来编译器是可以区分变量和函数的. 但是, 不总是这样的. 有时候, 代码是有歧义的, 这时编译器不能确定标识符到底是函数还是变量.","ref":"ch02-plus_and_minus.html#%E5%87%BD%E6%95%B0%E5%85%B6%E5%AE%9E%E6%B2%A1%E6%9C%89%E8%A2%AB%E8%A6%86%E7%9B%96","title":"第二章 加和减 - 函数其实没有被覆盖","type":"extras"},{"doc":"如果遇到这样的代码: abs - abs , 那么这两个 abs 怎么区分呢? 显然是有两种解释的: 两个 abs 都是变量, 那么结果自然是 0; 第一个 abs 是函数, 第二个 abs 是变量, 那么返回的结果应该是变量 abs 的绝对值, 也就是 2. 答案是 0. 也就是说操作符 - 把两边操作数都当作是变量. 但是这样的代码 abs -abs 呢? 也依然有两种解释, 实际上这一次因为 - 和第二个 abs 之间没有空格, 更应该优先把 - 解释为对变量 abs 的取反. 如果这样解释的话, 那么第一个 abs 解释成什么呢? 似乎只能解释为函数, 那么结果应该是 2. 但是实际上, 编译器抛出了一个错误. ( CompileError ) :&quot;abs -abs&quot; looks like a function call but there is a variable named &quot;abs&quot; . If you want to perform a function call , use parentheses : ` abs ( - abs ) ` If you want to perform an operation on the variable abs , use spaces around the unary operator 为什么, 编译器不优先把 -abs 作为一个整体, 来解释为对 abs 的取反操作呢? 因为在别的语法环境中, -abs 作为整体解释, 会出现问题. abs-abs 怎么解释呢? 优先把 -abs 作为一组来解析, 得到的是一个数值. 那么把第一个 abs 解释为函数, 合乎语法; 把两个 abs 都解释为变量,语法也是正确的. 可是两个语义完全不同. 实际上编译器在这种情况下, 把两个 abs 都解释为变量. abs -abs -abs 呢? 如果两个 -abs 都解释为对变量取反, 而把第一个 abs 解释为函数, 那么整个表达式等价于 abs(2 2) 还是 abs(2) 2 ? 但是无论 abs(2 2) 还是 abs(2) 2 都不是 Elixir 的正确语法. 要想 abs -abs -abs 有意义, 只能把两个 -abs 做不同的解释才行. 把 abs -abs -abs 解释为 (abs) - abs(-abs) , 是可行的, 但是对编译器的实现来说来说, 完成这样的结束, 需要的实现太复杂了. 把 abs -abs -abs 解释为 (abs - abs) - abs 就彻底放弃了对 -abs 优先解释. 综合起来看, 只好放弃对 -abs 的优先解释, 而把 -abs 解析为两个符号(token): - 与 abs . 为什么报错 上面的分析, 我们看到, 只能把 -abs 解释为 - 和 abs 两个符号. 但是这样处理后, 为什么当编译器遇到 abs -abs 的时候会报错呢? 这是因为, 有时候, 我们写 -abs 的时候, 我们的真实的意图就是要对 abs 取反. 如果编译器一律把 x -abs 解释为 x 减去 abs , 那么代码有可能实际上违背了我们的真实意图. 抛出错误, 强迫程序员明确 - 的意义, 可以使得 Elixir 代码更强壮, 这符合 Erlang 的 &quot;Let it crash&quot; 哲学. 在编译时奔溃好过在运行时奔溃. 最后一点, 我们的分析中, 表达式 token -token1 中, token 和 token1 都是标识符; 但是实际上, 只要 token 是标识符, token1 无论是数值字面量还是标识符, 这个表达式都会引发这里讨论的问题. 我们可以用以下表格来总结表达式的各种情形: 表达式 语法正误 解释 x-y 正确 当 - 两边的符号与 - 之间都没有空白时, 解释器把 - 解释为减法 1 -1 正确 数字是不能作为函数名的, 所以 - 只能解释为减法. 1 -a 正确 无论 a 是表达式, 还是变量, 都必须把 - 解释为在减号, 整个表达式才正确 a -1 错误 表达式存在歧义, 既可以用作解释为函数调用 a(-1) ; 又可以解释为变量 a 减去 1. a -b 错误 同上. 表中 x , y 表示可以是数字也可以是变量标识符; a 和 b 表示变量标识符; 1 代表任意的数值字面量.","ref":"ch02-plus_and_minus.html#%E6%AD%A7%E4%B9%89%E4%BB%A3%E7%A0%81","title":"第二章 加和减 - 歧义代码","type":"extras"},{"doc":"这章的标题是 ≪加和减≫ , 但是, 到目前为止, 我们的分析只涉及到了 - . 我不是跑题了, 而是因为 + 存在的问题, 和 - 本质是一样的. -/1 在编程中承担了有意义的工作; +/1 不一样. +/1 在 Elixir 中真正的意义, 在编程实践中, 几乎用不到. 你能想象到 +/1 的实际意义吗? 首先, 如果 b 是一个数字, +b 并不返回 b 的绝对值. 从 C 到 Javascirpt, ..., 到 Erlang 再到 Elixir, 都是如此. 这还真是一个有趣的现象, 这样一个赘疣一样的语法弥因 (Meme), 怎么就在编程语言设计的领域中扩散开的? Elixir 继承自 Erlang, +/1 在 Elixir 中就是调用的 Erlang +/1 1 . Erlang 又从哪里继承的, 我就不得而知了. 但是这个赘疣源远流长. 在最早的高级编程语言 Fortran 和 Lisp 中就有它的身影. 在 Lisp 中, + 是一个不定参数的函数, 在定义 + 的时候, 以 0 为初始值, 对所有参数作累加操作, 根本就不需要对单参数的情形作特殊处理. 在 Fortran 中, 为什么也有它的身影, 我就不得而知. 也许是出于与 -/1 的对称考虑? 对于非操作符前缀的语言, 我认为 +/1 就是一个赘疣, 乍看无关痛痒, 后期的发展, 有可能危害生命. 我建议编程语言的设计者: 在自己设计的编程语言中, 消灭 +/1 ; 如果非要为 +/1 保留一席之地, 那么就给它分配一个有意义的工作; 比如拿来作 取绝对值 的操作符. 在 Javascirpt 中 +/1 找到了自己的一席之地: 可以用来完成字符串到数值的转化. a = &quot;123&quot; console . log ( + a + 1 ) //124 Elixir 是强类型语言, +/1 不提供这个功能. 那么 Elixir 中 +/1 的用途是什么呢? 我能想到的唯一用途就是: 检查一个值是否为数值类型, 如果是, 返回其值; 如果不是, 则抛出错误. 也就是说, +/1 可以这样定义: def + ( m ) do if is_number ( m ) do m else message = &quot;bad argument in arithmetic expression: +( \#{ inspect m } )&quot; raise ArithmeticError , message end end 但是在 Elixir 和 Erlang 中, 抛出错误不是一个常规的编程操作, 所以, 我从来没见过有人用过这个语法. 如果 Elixir 中取消了 +/1 的定义, 只把 + 解释为加法, 那么 a +1 , a +b , 这些表达式中的语法歧义就消除了. - 引发错误是不得已; + 引发的错误, 是赘疣恶化的结果. 你同意吗? &amp;#x21A9; 见 Elixir 核心模块 源码 1347~1349 行 .","ref":"ch02-plus_and_minus.html#%E5%8A%A0","title":"第二章 加和减 - 加","type":"extras"},{"doc":"","ref":"ch03-pattern_match.html","title":"第三章 模式匹配","type":"extras"},{"doc":"模式匹配完成以下的两个工作: 确认数据具有某种模式 以某种模式, 从数据中提取信息 在其他语言中, 这两个功能有着清晰的分界, 但是在 Elixir 中, 有清晰分界的情况是少数的, 大部分是两个功能混合在一起的.","ref":"ch03-pattern_match.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E4%BD%9C%E7%94%A8","title":"第三章 模式匹配 - 模式匹配的作用","type":"extras"},{"doc":"Elixir 特意提供了一个专门完成模式检查工作的宏 match?/2 . 这个宏返回的是一个布尔值. true = match? ( { :ok , b } , { :ok , 1 } ) :b not in ( binding ( ) |&gt; Keyword . keys ( ) ) false = match? ( { :ok , _ } , :error ) 上面的代码, 第 1 行表明, 当 match? 第一个参数作为模式, 可以匹配第二个值得时候, 返回值是 true . 第 2 行, 通过检查 binding() , 确认即使匹配成功, 这个宏也并不在环境中引入新的变量. binding/1 是一个宏, 返回指定的上下文函数的绑定值. biding/0 返回当前环境中的绑定情况. 这个函数返回的是一个 Keyword. 代码 binding()|&gt;Keyword.keys() 返回了当前的上下文中所有的变量 (以原子表示). 第 3 行, 展示了当 match? 的两个参数匹配失败的时候, 返回 false 而不是引发一个异常. 和 match?/2 完成的工作非常相似, 但是只专注于字符串匹配的是操作符 =~ . =~ 返回的也是布尔值. true = &quot;hello&quot; =~ &quot;hello&quot; true = &quot;hello&quot; =~ ~r/hel.{2}/ 对参数的要求, Kerner.match?/2 和匹配操作符 = 一样, 第一个参数作为模式, 第二个参数作为需要匹配的值. 字符匹配操作符 Kernel.=~/2 与它们不一样. =~/2 的第一个参数是要匹配的数据 --- --- 具体说是字符串, 第二个参数是模式: 字符串或者正则表达式. 这是一点小不同. 其实, 我更希望能够使用操作符, 来完成更多的模式确认的工作. = 在 Elixir 和 Eralng 中已经被命名为模式匹配操作符了, 为了避免混淆, 我把将要定义的 =~/2 宏, 叫做 模式确认操作符 (Pattern Confirm Operater) . 将要定义的模式确认操作符 =~ 除了完成字符串匹配外, 还可以完成其他的模式确认的工作. 如果模式确认操作 =~/2 接受的第一个操作符是字符串, 那么就代理 Kernel.=~/2 函数来执行字符串匹配. 为了和 Kernel.match?/2 的参数顺序保持一致, 我们还支持正则表达式字面量 ( ~r 或 ~R ) 作为第一个参数, 字符串作为第二个参数, 来完成模式确认的工作. 其他情况, 全部有 Kernel.match?/2 来完成. 但是 Kernel.match?/2 有一个小小的问题: 当我们使用一般的变量来作为匹配的模式时, 编译器会给出恼人的警告. 例如 match?([a,b],[1,2]) 会警告: 变量 a 和 b 都没有被使用. 实际上, 就像我们上面已经解释过的, match?([a,b],[1,2]) 根本不向运行时环境引入变量, 那么这样的警告就显得有些古怪. 为什么 match?/2 要给出这样的警告呢? 想想看, 如果首先定义了一个变量, a=[1,2] , 然后期望当 value 的值为 [1,2] 时, match?(a,value) 返回 true . 这样的代码, 正确吗? 因为 match? 接受的第一个参数是一个模式, 而变量是可以匹配任意值的, 所以无论 value 的值是什么内容, match?(a,value) 都会返回 true . 要表达按照变量的值来匹配, 正确语法是 match?(^a,value) . 这就是为什么 match?/2 遇到第一个参数中有不以下划线开头的变量时, 给出警告的原因. 对于这个问题, 模式确认操作符时这样处理的, 模式操作符的第一个参数是一个变量, 那么抛出一个错误. 其他的情况, 在把模式传递给 match?/2 前, 给普通的变量加上下划线前缀, 这样就能最大限度的消除 match?/2 给出的古怪警告. 现在让我们看看如何实现.","ref":"ch03-pattern_match.html#%E6%A8%A1%E5%BC%8F%E7%A1%AE%E8%AE%A4","title":"第三章 模式匹配 - 模式确认","type":"extras"},{"doc":"模式确认操作符, 是要覆盖 Kernel.=~/2 这个函数的. 新定义的宏, 兼容了 Kernel.=~/2 这个函数, 使用者不用关心其使用的 =~/2 到底是 Kernel.=~/2 还是我们定义的宏. 为了方便使用者, 我们在模块中定义 __using__/1 宏. defmodule Corner.PatternConfirmer do defmacro __using__ ( _opt ) do quote do import Kernel , except : [ =~ : 2 ] import Corner.PatternConfirmer , only : [ =~ : 2 ] end end #... end 这样, 在使用的时候, 只需要一个 use 语句 use Corner.PatternConfirmer 就可以完成宏导入的工作. 上面的代码片段是非常常见的 __using__/1 宏的写法. 这个宏完成的实际工作也非常的直观. 可以认为, 它完成了 C 或 Erlang 宏的文本替换的工作: 在编译时, 用 quote do..end 中的两个 import 语句替换了 use Corner.PatternConfirmer . 模式确认操作符 =~/2 定义稍微复杂一点. 根据第一个参数, 也就是我们要确认的模式, 可以分成 4 中情况: 模式为字符串 模式为正则表达式常量 模式为一个单独的变量 其他情况 第一种情况最简单, 我们的宏只需要代理 Kernel.=~/2 函数就可以了. 第二种情况, 稍微复杂一点, 主要是对正则表达式的确认上有一点点的麻烦. 对这两种情况的处理代码为: defmacro left =~ right do cond do is_binary ( left ) -&gt; text_match ( left , right ) ( match? ( { :sigil_r , _ , _ } , left ) or match? ( { :sigil_R , _ , _ } , left ) ) and is_binary ( right ) -&gt; text_pattern_confirm ( left , right ) #... other condtion end end 不难猜到 text_match 和 text_pattern_confirm 的代码: defp text_match ( left , right ) do quote do Kernel . =~ ( unquote ( left ) , unquote ( right ) ) end end @compile online : true defp text_pattern_confirm ( left , right ) do text_match ( right , left ) end text_match 和 text_pattern_confirm 作的工作是一样, 只是参数的位置做了调换. 所以要如此写, 是因为这时两个工作. text_match 完成的是对 Kernel.=~/2 函数的兼容, text_pattern_confirm 是以正则表达式为模式来作模式确认的. 第 3 个情形: 对单独的变量作模式的处理, Kernel.=~/2 是一个函数, 第一个参数只要是字符串类型就可以, 除了使用字符串字面量外, 也可以用绑定了字符串得变量来作为 Kernel.=~/2 的第一个参数. 当模式确认操作符宏 =~/2 的第一个参数是一个变量的时候, 宏运行在编译时, 而 Elixir 是一个动态编程语言, 变量绑定的值是什么类型, 只有在运行时才能知道. 所以宏定义中, 无法更具变量的值作进一步的区分. 为了和 Kernel.=~/2 兼容, 只好把这种情形都用 Kernel.=~/2 处理. 当变量绑定的值不是字符串的时候, Kernel.=~/2 就会抛出异常. 这时单独变量情形的特殊情况. 相关代码如下: defmacro left =~ right do cond do # text_match and regex_confirem match? ( { _atom , _ , _ } , left ) -&gt; text_match ( left , right ) true -&gt; other_pattern_confirm ( left , right ) end end defp other_pattern_confirm ( left , right ) do new_left = Macro . prewalk ( left , &amp; prewalker / 1 ) quote do match? ( unquote ( new_left ) , unquote ( right ) ) end end 最复杂的是对其他模式的处理. 主要的困难在于如何为普通的变量添加下划线前缀. 普通变量是指: 1. 变量不是以 _ 为前缀, 2. 变量不是 pin ( ^ ) 操作符的操作数. 要完成对模式中普通变量的修改, 我们需要对模式的抽象语法树作遍历. 这里使用 Macro.prewalk/2 对抽象语法树, 执行前序遍历. 如果存在 ^a 这样的表达式, 那么执行第一个 prewalker/1 分句, 这个分句是为之后的遍历中区分 ^a 和 a 而作的准备工作. 这个分句为表达式 ^a 中的 a 的抽象语法树, 添加元数据, :exclude , 以标记这个 a 不需要转化为 _a . 相关代码为: @exclude_atoms [ :^ , :%{} , :% , :{} ] defp prewalker ( { atom , meta , args } ) when atom in @exclude_atoms do args = Enum . map ( args , fn { atom , meta , value } -&gt; { atom , [ :exclude | meta ] , value } { atom , other } when atom not in @exclude_atoms -&gt; { atom , prewalker ( other ) } end ) { atom , meta , args } end 第二个 prewalker/1 分句处理标记过的变量, 去掉添加的 :exclude 标记, 还原为起初的样子. defp prewalker ( { atom , [ :exclude | meta ] , value } ) , do : { atom , meta , value } 第三个 prewalker/1 分句处理没有被标记为 :exclude 的变量的抽象语法树. 如果变量名以 _ 为前缀, 那么不用处理; 否则为变量添加 _ 前缀. defp prewalker ( { atom , meta , value } = ast ) when is_atom ( atom ) do if &quot; \#{ atom } &quot; |&gt; String . starts_with? ( &quot;_&quot; ) do ast else atom = &quot;_ \#{ atom } &quot; |&gt; String . to_atom ( ) { atom , meta , value } end end defp prewalker ( ast ) , do : ast 最后一个 prewalker/1 分句对所有其他的抽象语法树, 保持不变, 原样返回. Macro.prewalk/2 在调用第一个分句后, 对其返回的结果, 会继续使用后面的分句作遍历. 后面的三个分句中, 有一个会执行. 这样就完成了对普通变量添加 _ 前缀的工作. 最后, 让我们看看如何使用我们的模式确认操作符 =~ , 首先我们的定义兼容: Kernel.=~/2 . use Corner.PatternConfirmer &quot;hello&quot; =~ ~r/hell/ # true &quot;hello&quot; =~ ~r/wolrd/ # false regex = ~r/hel{1,2}o/ &quot;hello&quot; =~ regex # true &quot;helo&quot; =~ regex #true &quot;world&quot; =~ regex #false str = &quot;hello&quot; regex = ~r/hel{1,2}o/ str =~ regex #true 当我们使用用魔符来创建表达式得时候, 正则表达式, 也可以作为模式确认操作符 =~ 的第一个操作数. ~r/hell/ =~ &quot;hello&quot; #true ~R/hel{1,2}o/ =~ &quot;hello&quot; #true ~R/hel{1,2}o/ =~ &quot;helo&quot; #true 但是传递给模式确认操作符 =~/2 的第一个参数为一个变量的时候, 这个变量的绑定值不是字符串, 而是其他值得时候, 就会抛出错误. a = ~r/hell/ a =~ &quot;hello&quot; #raise FunctionClauseError 最后, 对其他模式的支持: [ a , b ] =~ [ 1 , 2 ] # true a = 1 ; array = { 1 , 2 } { ^ a , b } =~ array #true 1 =~ 1 #true { 1 , _ } =~ { 1 , 2 } #true 1 =~ 2 #false [ 1 , _ ] =~ { 1 , 2 } #false %{ a : a , b : b } = %{ a : :ok , b : :bad } #true","ref":"ch03-pattern_match.html#%E6%A8%A1%E5%BC%8F%E7%A1%AE%E8%AE%A4%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0","title":"第三章 模式匹配 - 模式确认操作符的实现","type":"extras"},{"doc":"与 match?/2 以及 ~= 提供的功能刚好相反, Elixir 中也提供了, 专注于按模式提取数据的语法结构: destructure/2 针对列表 get_in/2 针对 Access 行为 我喜欢 descructure 这个函数, 它让我怀念 Javascript 的解构操作. 可惜 descruture/2 这个函数只支持对列表的解构. 例如下面 Javascript 代码: let [ a , b ] = [ 1 ] console . log ( a ) \\\\ 1 console . log ( b ) \\\\ undefined Elixir 中对应的代码为: destructure ( [ a , b ] , [ 1 ] ) IO . inspect ( a ) # 1 IO . inspect ( b ) #nil Javascript 中的结构, 不但可以应用于数组, 也可以应用于对象. 例如 let { a , b } = { a : 1 } console . log ( a ) \\\\ 1 console . log ( b ) \\\\ undefined 而 Elixir 的 destructure/2 当前版本还不支持其他的类型的解构. Javascript 的解构操作, 对嵌套的支持也很好. let c = null ; [ a , [ b , c ] ] = [ 1 , [ 2 , 3 ] ] console . log ( a ) \\\\ 1 console . log ( b ) \\\\ 2 console . log ( c ) \\\\ 3 let d = null ; [ a , [ b , c , d ] ] = [ 1 , [ 2 , 3 ] ] console . log ( a ) \\\\ 1 console . log ( b ) \\\\ 2 console . log ( c ) \\\\ 3 console . log ( d ) \\\\ undefined 而 Elixir 的 destructure/2 , 即使对列表的解构, 列表中嵌套列表是, 解构操作也不会递归展开. 例如和上面 Javascript 对应的 Elixir 代码, 在当前的版本中, 会抛出 MatchError 错误: c = nil destructure ( [ a , [ b , c ] ] , [ 1 , [ 2 , 3 ] ] ) IO . puts ( a ) #1 IO . puts ( b ) #2 IO . puts ( c ) #3 destructure ( [ a , [ b , c , d ] ] , [ 1 , [ 2 , 3 ] ] ) #抛出错误 和模式确认操作符类似, 我们可以定义一个新的操作符, 来完成按模式提取操作(Extract base Pattern). 这个宏应该是一个二元宏. 以操作符的形式提供可以让代码的可读性更强. 向左箭头 &lt;- 或 &lt;~ 操作符都是我心目中的候选者. 但是 &lt;- 在 for 和 with 结构中承担有一定的功能, 如果以 &lt;- 作为我们的操作符, 那么我们还需要考虑 for 和 with 解构中的 &lt;- 操作符的兼容容问题. 为了少些一些代码, 同时也减少使用者的迷惑, &lt;~ 是我最后的选择. 将要定义的 &lt;~ 操作符要完成按模式提取的操作, 因此把它命名为模式提取操作符 (Pattern Extracter). Elixir 中, 可以用来完成数据组合的有以下几种类型: 列表 元组 map 我们将要定义的模式提取操作符 &lt;~ , 第一个参数是一个模式 pattern ; 第二个参数是一个值 value . pattern 现在不但可以是列表, 还支持元组和 map 字面量. 而且对嵌套模式提取也提供支持. 现在, 让我们分析一下模式提取操作应该完成的功能: 当 pattern 与 value 完全匹配, 那么 pattern 中的变量都会绑定相匹配的值. 当 pattern 匹配 value 的一部分的时候, pattern 中的变量也完成值绑定, 而不是抛出匹配失败 . 就像表达式 destructure([a,b], [1,2,3]) , 完成变量 a 绑定为 1 , b 绑定 2 那样. 当 value 的模式是 pattern 的一部分的时候, 那么 pattern 中多出的变量, 都绑定为 nil , 就像 destructure([a,b,c],[1]) 为变量 a 绑定为 1 , b 和 c 绑定为 nil 那样. 和模式确认操作符 =~/2 类似, 这里我们也根据模式提取操作符 &lt;~ 的模式的不同情形, 分别处理: 列表 元组 map 其他情形 将要定义的模式提取操作符, 需要对嵌套解构作处理, 那么必然的涉及到递归调用. 在实现的时候, 我们使用一个私有函数来完成宏的工作. 所以要这样是因为对宏作递归调用比较的麻烦. 而对函数作递归调用就简单了. 所以整个宏, 就只是对私有函数 my_destructure/2 的调用; 而 my_destructure/2 函数则根据模式的不同情形完成具体的处理工作. defmodule Corner.PatternExtracter do defmacro pattern &lt;~ value do my_destructure ( pattern , value ) end defp my_destructure ( pattern , value ) do cond do is_list ( pattern ) -&gt; destructure_list ( pattern , value ) Ast . is_tuple? ( pattern ) -&gt; destructure_tuple ( pattern , value ) not Ast . is_struct? ( pattern ) and Ast . is_map? ( pattern ) -&gt; destructure_map ( pattern , value ) true -&gt; raise_syntax_error ( pattern ) end end #...other code end 这样的代码, 非常的清晰明了, 基本上不用作解释. Ast 是辅助模块, 用来帮助我们完成对某些抽象语法树的确认工作. 比如这里用到的 Ast.is_tuple?/1 , Ast.is_map?/1 等, 用来检查输入的 ast 是否是对应类型的字面量表达式的抽象语法树. 这里我们并没有支持结构 (struct). 所以不支持结构是因为, 编译阶段无法对结构作做出确认. 模式提取操作符关注的是提取, 结构名无关数据而仅关乎匹配确认, 如果模式中附带了结构形式, 对于数据的提取不会有帮助, 但是数据的结构与模式中提供的结构不一致的时候, 还会引发匹配错误. 与其让这种错误在运行时发生, 不如在编译时就直接报错. 列表, 元组和 map 之外的其他情形, 记录外, 还可以有单个变量表示模式. 单变量模式, 语法上虽然是合法的, 但是其效果应该等同于匹配操作符 = . 如果不是使用错误, 那么就应该使用匹配操作符 = . 此外, 模式的最后一种情形就是 pin 操作符与变量的组合表达式 ^pattern , 这种模式是对 pattern 绑定的值做模式确认的, 在模式确认中或许有意义, 在按模式提取数据是, 完全没有意义. 所以, 其他的情形, 我们的宏抛出错误语法错误. 首先让来看看列表如何实现模式提取的. 对列表来说, Kernel.destructure/2 已经很好的完成了列表中无嵌套结构的模式匹配了. 所以我们最主要的工作就是如何实现列表中嵌套结构的匹配. 例如这样的 [a, [b,c,d]] &lt;~ [1, [2]] . 要实现把变量 a 绑定 1 , b 绑定为 2 , c 和 d 都绑定为 nil . 我们可以把这个表达式转化: destructure([a,mid_var], [1,[2]]) 和 destructure([b,c,d],mid_var) . 所以要做的工作就是识别出列表中的嵌套结构, 并通过中间变量作为桥梁来完成内部嵌套结构的解构. 对应的代码为: defp destructure_list ( pattern , value ) when is_list ( pattern ) do { var_patterns , nest_destructure_ast } = Helpers . split_nest_pattern ( pattern , &amp; my_destructure / 2 ) quote generated : true do destructure ( unquote ( var_patterns ) , unquote ( value ) ) unquote_splicing ( nest_destructure_ast ) end end defmodule Helpers do def split_nest_pattern ( ast , fun ) do { var_patterns , map } = change_composed_pattern_to_variable ( ast ) nest_destruct_ast = Enum . map ( map , &amp; fun . ( elem ( &amp;1 , 0 ) , elem ( &amp;1 , 1 ) ) ) { var_patterns , nest_destruct_ast } end defp change_composed_pattern_to_variable ( ast ) do { patterns , map } = for ele &lt;- ast , reduce : { [ ] , %{ } } do { patterns , map } -&gt; if Ast . is_composed_type? ( ele ) do mid_var = Macro . unique_var ( :var_for_destruct , __MODULE__ ) patterns = [ mid_var | patterns ] map = Map . put ( map , ele , mid_var ) { patterns , map } else { [ ele | patterns ] , map } end end { Enum . reverse ( patterns ) , map } end end 这里最主要的工作由 Helpers.split_nest_pattern/2 完成. 它完成两个工作: 使用中间变量替换 pattern 中的嵌套解构; 对中间变量和替换的嵌套解构做递归解构操作. 第一个工作由 Helpers.change_composed_pattern_to_variable/1 完成. 第二个工作由 Enum.map 这个语句完成, 因为 destructure_list/2 中, 我们传递给 split_nest_pattern/2 的第二个参数就是我们的 my_structure/2 . 对元组的处理和列表的处理非常类似. defp destructure_tuple ( pattern , tuple ) do pattern_size = Ast . tuple_size ( pattern ) { patterns , nest_destruct_ast } = Ast . tuple_to_list ( pattern ) |&gt; Helpers . split_nest_pattern ( &amp; my_destructure / 2 ) pattern = { :{} , [ ] , patterns } quote do tuple = unquote ( tuple ) m = unquote ( __MODULE__ ) . Helpers patch_right = m . make ( tuple , to_size : unquote ( pattern_size ) ) unquote ( pattern ) = patch_right unquote_splicing ( nest_destruct_ast ) end end 这里的区别就是, 我们是使用匹配操作符 = 完成元组的匹配工作的. 要保证元组匹配时不抛出错误, 需要保证匹配操作符 = 两边的元组大小一样. 这个工作由 Helpers.make(tuple,to_size: size) 完成. def make ( tuple , to_size : size ) do diff = tuple_size ( tuple ) - size case diff do 0 -&gt; tuple n when n &gt; 0 -&gt; Tuple . drop ( tuple , n , at : :tail ) n when n &lt; 0 -&gt; Tuple . padding ( tuple , - n , at : :tail ) end end 上面代码中的 Tuple 是 Corner.Tuple 的别名, 是辅助模块. 对 map 的解构处理由 destructure_map(pattern, value) 完成. 这里代码框架与列表以及元组的处理相同. 为了避免匹配操作符 = 抛出匹配错误, 要根据 pattern 构建一个所有的值都为 nil 的对象. 然后把 value 与新创建的 map 合并. 这样相等于为 pattern 中存在, 而 value 中不存在的字段创建了默认值. defp destructure_map ( pattern , value ) do keys = Ast . map_keys ( pattern ) { values , nest_destruct_ast } = Ast . map_values ( pattern ) |&gt; Helpers . split_nest_pattern ( &amp; my_destructure / 2 ) map = Ast . make_map ( keys , values ) default_value = make_default ( pattern ) quote do unquote ( map ) = Map . merge ( unquote ( default_value ) , unquote ( value ) ) unquote_splicing ( nest_destruct_ast ) end end defp make_default ( ast ) do Macro . postwalk ( ast , &amp; variable_to_nil / 1 ) end defp variable_to_nil ( { atom , _ , context } ) when is_atom ( atom ) and context in [ Elixir , nil ] , do : nil defp variable_to_nil ( v ) , do : v 模式提取操作符 &lt;~ 兼容并增强了 Kerner.destructure/2 . import Corner.PatternExtracter [ a , b ] &lt;~ [ 1 , 2 , 3 ] a == 1 # true b == 2 # true array = [ 1 , 2 , 3 ] [ a , b ] &lt;~ array a == 1 #true b == 2 #true [ a , b , c ] &lt;~ [ 1 ] a == 1 #true b == nil #true c == nil #true [ a , [ b , c ] ] &lt;~ [ 1 , [ 2 ] ] a == 1 # true b == 2 # true c == nil # true destructure ( [ a , [ b , c ] ] , [ 1 , 2 ] ) #raise badmatch error 对于元组, 我们可以这样使用: { a , b } &lt;~ { 1 , 2 } a == 1 # true b == 2 # true { a , b } &lt;~ { 1 } a == 1 # true b == nil #true { a } &lt;~ { 1 , 2 } a == 1 #true { a , { b , c } } &lt;~ { 1 , { 2 } , 3 } a == 1 and b == 2 and c == nil # true { a , { b , c } } &lt;~ { 1 , { 2 , 3 , 4 } , 5 } a == 1 and b == 2 and c == 3 #true 当模式为 map 时, 可以像下面的代码那样, 来使用模式提取操作符 &lt;~ : %{ a : a , b : b } &lt;~ %{ a : 1 , c : 3 } a == 1 and b == nil # true map = %{ a : 1 , c : 2 } ; %{ a : a , b : b } &lt;~ map a == 1 and b == nil # true %{ :a =&gt; b } &lt;~ map b == 1 #true %{ a : a , b : %{ b : b } } &lt;~ %{ a : 1 , b : %{ } , c : 3 } a == 1 and b == nil #true 当模式中列表, 元组与 map 混合在一起的时候, 模式提取操作符也可以使用: [ a , { b } , %{ e : e } ] &lt;~ [ 1 , { 2 , :ok } , %{ e : 3 , g : &quot;hello&quot; } ] a == 1 and b == 2 and e == 3 #true 但是当 pattern 的数据类型与 value 的数据类型不匹配的时候, 会发生错误. [ a , b ] &lt;~ { 1 , 2 } # raise error [ a , { b } ] &lt;~ [ 1 , 2 , 3 ] # raise error","ref":"ch03-pattern_match.html#%E6%8C%89%E6%A8%A1%E5%BC%8F%E6%8F%90%E5%8F%96%E4%BF%A1%E6%81%AF","title":"第三章 模式匹配 - 按模式提取信息","type":"extras"},{"doc":"Elixir 中使用最频繁的操作符是匹配操作符 = . 它的工作逻辑如下: 最常见的情形下, 按照 = 左侧的模式, 从右边的数据中提取信息. 但是当左边变量前中出现 pin 操作符 ^ 的时候, = 只完成模式确认的工作: 模式匹配成功了, 返回模式匹配操作符 = 右侧表达式的值; 而如果模式匹配失败了抛出异常. 在 Erlang OTP 25 中引入了一个新特性 maybe, 其中可以使用新的短路操作符 ?= 1 , 叫做条件匹配操作符. 也许不久 Elixir 也会引入. 这个操作符实际上就是 match?/2 和模式匹配操作符 = 的混合体; 当模式匹配成功的时候, 完成变量的值绑定, 模式匹配失败, 返回 ?= 左边的值. 可见操作符 = 和 ?= 都是混合了模式匹配的两种用法. 他们之间的差异在于, 当模式匹配确认失败后如何处理控制流和操作符的返回值.","ref":"ch03-pattern_match.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%93%8D%E4%BD%9C%E7%AC%A6","title":"第三章 模式匹配 - 模式匹配操作符 =","type":"extras"},{"doc":"在执行逻辑操作的时候，有是否支持短路操作的问题, 比如逻辑操作 and 和 or 在 Eixir 和绝大多数的编程语言中, 都是短路操作: 逻辑操作符号 and 只有当左侧表达式的结果为 ture 的时候, 右边的表达式才会求值; 而操作符 or 只有当左边的表达式结果为 false 时, 才会对右边的表达式求值. 但不是并不是所有的编程语言都是这样的, Erlang 中就提供了全路的逻辑操作, 当然也有对应的短路操作符号. Erlang 中的 and 和 or 对逻辑操作符执行全路操作, 也就是说, 在 Erlang 中 and 和 or 的两个操作数的值, 都会被计算一次; 而执行逻辑短路操作的是关键字 and_also or_else . 也就是说 Elixir 中的 and 和 or 对应的是 Erlang 的 and_also 和 or_else . Elixir 中缺少全路的逻辑操作. 短路和全路操作, 对于逻辑结果来说是没有影响的, 有影响的只是副作用. 副作用的存在, 使得逻辑操作符可以用来充当控制结构. 这正是讨论逻辑操作短路与否的原因。 为了进一步的利用逻辑的短路操作做控制结构, Elixir 还提供了接受 boolean_as 类型的 操作符 &amp;&amp; 和 || . C 语言的三目条件表达式 cond ? true_part : false_part , 在 Elixir 中既可以使用 if cond,do: true_part, else: false_part 又可以使用 cond &amp;&amp; true_part || false_part 来模拟. 如果存在多个匹配模式, 以什么样的逻辑来处理这些模式的确认结果呢? Elixir 的控制结构中, 使用的都是 or 的逻辑, 也就是说按照顺序对每个模式一一做确认, 直到发现了确认的模式. 但是当所有的模式全部失败后, 如何处理, 又可以有不同. 就像 = 和 ?= 的差别那样. 我把 = 的选择叫做悲观主义, 而 ?= 的选择叫做乐观主义. 那么控制结构, 可以分成三类: 悲观的 乐观 特殊","ref":"ch03-pattern_match.html#%E9%80%BB%E8%BE%91%E7%9F%AD%E8%B7%AF%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB","title":"第三章 模式匹配 - 逻辑短路与控制结构的分类","type":"extras"},{"doc":"Elixir 的大部分的控制结构都是悲观的: 即所有的模式匹配确认都失败后, 产生错误, 中断控制流. 悲观控制结构包括: 函数分句 case cond 这些控制结构的大体的工作逻辑是这样的: 首先对模式做匹配, 如果不匹配, 接着匹配下一个模式, 如果所有的模式都不匹配, 类似于模式匹配操作符 = 匹配失败那样, 抛出一个错误; 而一旦匹配成功了, 还要完成数据提取的工作, 并执行对应的代码段. 函数分句 函数的分句这种概念, 从编程的效果上看, 非常类似于 C++ 和 Java 中的函数和方法的重载. 重载和函数分局都完成了对代码的动态调度. 但是这里不只是术语的名称的不同, 函数重载和和函数分句之间的差别更多是世界观的差别. 函数的重载可以发生在很多地方, 不只是限制在同一个命名空间中, 而且每个函数实际上也被认为是独立, 可区分的单元, 是编译器为程序员做了根据输入参数的不同区分和正确加载调度对应函数的工作. Elixir 中函数分句只能发生在同一模块中, 而且这些函数应该集中放在一起, 不应该被其他代码分隔开来. 例如下面的代码, 我们故意在 fib/2 的两个分句之间, 定义了一个新的函数 b , 这样的代码编译器会给出警告. defmodule CauseDemod do def fib ( n , acc \\\\ [ 1 , 1 ] ) def fib ( 0 , [ a , _ ] ) , do : a def b ( ) , do : nil def fib ( n , [ a , b ] ) , do : fib ( n - 1 , [ a + b , a ] ) end 从语法基因来说, Erlang 中函数分句, 语法上是不能分开写的. 上面的代码, 对应的 Erlang 版本是这样的: - module ( &#39;Elixir.CauseDemode&#39; ) . - export ( [ fib : 2 , fib : 1 , b : 0 ] ) . fib ( 0 , [ a , _ ] ) -&gt; a ; fib ( n , [ a , b ] ) -&gt; fin ( n - 1 , [ a + b , a ] ) . fib ( n ) -&gt; fib ( n , [ 1 , 1 ] ) . b ( ) -&gt; nil . Erlang 中, . 是语句结束的标志, 所以 Erlang 中是没有办法把函数分句拆散的. 但是 Erlang 中不允许, 不代表 Elixir 中不可以, Elixir 对 Erlang 的语法改进是相当大的, 所以这里所以要给出警告, 绝对不只是为了与 Erlang 语法对应的问题. 而且编译器给出的是警告不是错误, 这本上就说明, 这不是技术实现上的问题. 那么警告的原因是什么呢? 这个要求首先是对函数分句概念呼应. 其次把相关代码紧凑的放在一起, 也使得代码更容易维护. 编程的过程中, 当需要重构代码的时候, 我往往就是在需要重构的代码的前面和后面, 开始自己的函数提取. 这样, 不自觉地又减低了代码的可维护性. 对外的接口代码, 其上下文是抽象层级较高的概念; 而重构抽取的代码, 往往是底层细节的内容. 如果代码的布局上高层和低层的概念交叉在一起, 对于代码的阅读者来说, 其理解的负担无疑是加重的. 所以把函数分句放在一起, 这样的代码布局, 的确是应该提倡的. 如果函数的一个分句处理的任务还是非常的复杂, 需要把其中的代码提取为单独的函数, 怎么处理呢? 如果把函数分句调用的帮助函数, 统统放在整个函数定义的后面或前面, 当有多个这样的帮助函数的时候, 函数之间的依赖关系就不是那么清晰了. 社区给出的推荐做法是这样的: 保持函数的对外接口不变, 在处理特殊情形的分句中调用一个为这个特殊情况而写一个独立的函数. 这个独立函数, 放在所有的对外接口函数的后面. 然后重构这个独立函数, 并把重构提取的代码放在独立函数的后面. 这样, 从概念在代码中的布局上来看, 总是高层次的概念先于底层概念, 而相关的概念又都保持在相邻的区域内. 例如 Phoenix LiveView 中, 事件的处理的代码, 就可以这样来写: def handler_event ( &#39;button1_click&#39; , _value , stack ) , do : ... def handler_event ( &#39;update_file&#39; , value , stack ) , do : handle_update_file ( value , stack ) def handler_event ( &#39;enven_name&#39; , _value , stack ) , do : ... defp handle_update_file ( value , stack ) do [ v1 , v2 ] = extract ( value ) work_with_v1_and_v2 ... end defp extrac ( value ) do ... end Case 与 Cond 在刚开始学习的时候, 遇到需要使用 case 或 cond 的时候, 我往往犹豫应该使用那一个, 因为我觉得这两个都对应 C 语言的 swith 语句. 现在我认为, case 语句才对应 C 家族的 switch . cond 更加像 C 家族的 if-else-if 链. 例如, 下面的 Javascript 代码: function score_range ( leave ) { switch ( leave ) { case &quot;F&quot; : return [ 0 , 59 ] ; case &quot;E&quot; : return [ 60 , 65 ] ; case &quot;D&quot; : return [ 66 , 74 ] ; Case &quot;C&quot; : return [ 75 , 79 ] ; case &quot;B&quot; : return [ 80 , 85 ] ; case &quot;A&quot; : return [ 86 , 89 ] ; default : return [ 90 , 100 ] } } 对应的 Elixir 代码应该为: def score_range ( leave ) do case leave do &quot;F&quot; -&gt; [ 0 , 59 ] ; &quot;E&quot; -&gt; [ 60 , 65 ] ; &quot;D&quot; -&gt; [ 66 , 74 ] ; &quot;C&quot; -&gt; [ 75 , 79 ] ; &quot;B&quot; -&gt; [ 80 , 85 ] ; &quot;A&quot; -&gt; [ 86 , 89 ] ; #&quot;A+&quot; _v -&gt; [ 90 , 100 ] end end C 语言家族中的 switch 和 Elixir 中的 case 几乎是逐句对应的. 下面看看 if-else-if 链的代码: function leave ( score ) { if ( score &lt; 60 ) reurn &quot;F&quot; else if ( 60 &lt;= score &amp;&amp; score &lt;= 65 ) return &quot;E&quot; else if ( 66 &lt;= score &amp;&amp; score &lt;= 74 ) return &quot;D&quot; else if ( 75 &lt;= score &amp;&amp; score &lt; 80 ) return &quot;C&quot; else if ( 80 &lt;= score &amp;&amp; score &lt; 85 ) return &quot;B&quot; else if ( 86 &lt;= score &amp;&amp; score &lt; 90 ) return &quot;A&quot; else return &quot;A+&quot; } 对应的 Elixir 应该是: def leave ( score ) do cond do score &lt; 60 -&gt; &quot;F&quot; 60 &lt;= score and score &lt;= 65 -&gt; &quot;E&quot; 66 &lt;= score and score &lt;= 74 -&gt; &quot;D&quot; 75 &lt;= score and score &lt; 80 -&gt; &quot;C&quot; 80 &lt;= score and score &lt; 85 -&gt; &quot;B&quot; 86 &lt;= score and score &lt; 90 -&gt; &quot;A&quot; true -&gt; &quot;A+&quot; end end 在 Elixir 中, case 和 cond 的互换, 要比 C 家族的 switch 和 if-else-if 语句的互换方便和容易的多. 这也是在 Elixir 中写多分支语句的时候, 我犹豫的原因之一. 心理分析学派发现, 找到心理创伤的根源, 往往就可以缓解创伤的症状, 甚至治愈. 实际上一切困惑和神秘的都源于我们还没有很好的理解它们, 如果能够亲手, 以已经了解和掌握的知识和材料, 重新创建不熟悉或神秘的事物, 那么就可以扫清这个思维和心理障碍. 这是我的一点经验体会. 所以, 让我来重新发明轮子, 看看如何用自己熟悉和习惯的概念来实现令我困惑的 case 和 cond . 观察 case 语句的语法, 我发现, 可以把 case 语句看作是 Elixir 的立即调用表达式 (IIFE) 的语法糖: 首先把 case 语句的 do-block 块, 使用 fn ... end 包裹起来, 就是一个合法的一元匿名函数的定义, 然后立即使用 case 的第一个参数来调用这个新创建的匿名函数. 这样就完成了 case 语句的工作. defmodule Explore.Case do defmacro my_case ( v , do : block ) do iife ( block , v ) end defp iife ( body , v ) do { { :. , [ ] , #This is the `.` in `(fn...end).(v)` [ { :fn , [ ] , body } #This is: `(fn...end)` ] } , [ ] , [ v ] #This is `(v)` in `(fn...end).(v)`. } end end 上面的代码中, 第 9 行创建了一元匿名函数, 整个 iife 函数, 在完成匿名函数的创建后, 立即以 v 为参数调用了这个匿名函数. 测试一下我们. import Explore.Case fun = fn v -&gt; my_case v do &quot;A+&quot; -&gt; [ 90 , 100 ] &quot;A&quot; -&gt; [ 86 , 89 ] &quot;B&quot; -&gt; [ 80 , 85 ] &quot;C&quot; -&gt; [ 70 , 79 ] &quot;E&quot; -&gt; [ 60 , 79 ] &quot;F&quot; -&gt; [ 0 , 60 ] end end [ 90 , 100 ] = fun . ( &quot;A+&quot; ) [ 0 , 60 ] = fun . ( &quot;F&quot; ) fun . ( &quot;FFF&quot; ) # (FunctionClauseError) no function clause matches 像上面我们分析的那样, cond 的语句可以转化为 if-else-if 语句链. cond 的 do-end 块中, 应该是一个或多个 a -&gt; ... 分句. 所以, 我们首先检查我们的 my_cond 输入中是否不和这样的解构, 如果不是这样的解构, 那么就不是合法的 cond 语句, 这时给出错误提示就好了. 在上面的对 case 语句的模拟中, 为什么不做检查呢? 因为当传递给 my_case 的 do-end 块不是合法的 case 的 do-end 块时, fn 特殊表达会给出合适的错误提示. 但是, 这里, 我们要把 do-end 块自己完成转化, 所以必须提前检查是否语法正确. 要把多个的 left -&gt; right 语句, 转化: if left1 do right1 else if left2 do right2 else #... end end 我们从最内层开始构造, 当所有的 case 分支都失败后, 会抛出错误, 所以最后一个 if 的 else 分句应该抛出一个错误. 这由 make_last_else_part/0 函数完成. 然后我们需要把所有的 condtione -&gt; right 都转化成 if condtione do: right, else: ... . 这个工作由 make_if_else/2 完成. 我们从最后一个 condtione -&gt; right 开始转化, 它的结果作为上一个 condtione -&gt; right 的 else 部分. 所以在 my_cond 中我们首先对 condtione -&gt; right 列表做了反序排序. 然后使用 Enum.reduce/2 完成最后的构造. defmodule Explore.Cond do defmacro my_cond ( do : block ) do if Enum . all? ( block , &amp; check_syntax / 1 ) do block |&gt; Enum . map ( &amp; elem ( &amp;1 , 2 ) ) # get `[left,right] from `left -&gt; right`. |&gt; Enum . reverse ( ) #make if-else-if chain more easy |&gt; Enum . reduce ( make_last_else_part ( ) , &amp; make_if_else / 2 ) else { :cond , [ ] , [ [ do : block ] ] } end end defp check_syntax ( { :-&gt; , _ , v } ) when is_list ( v ) , do : true defp check_syntax ( _ ) , do : false defp make_if_else ( [ [ condtion ] , then ] , else_part ) do { :if , [ context : Elixir , import : Kernel ] , [ condtion , [ do : then , else : else_part ] ] } end defp make_last_else_part ( ) do { :raise , [ context : Elixir , import : Kernel ] , [ &quot;Can not find the true pattern&quot; ] } end end 测试一下: import Explore.Cond a = 7 my_cond do a &lt; 7 -&gt; &quot;less than 6&quot; a == 7 -&gt; &quot;eq 7&quot; a &gt; 7 -&gt; &quot;greate than 7&quot; end # eq 7","ref":"ch03-pattern_match.html#%E6%82%B2%E8%A7%82%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84","title":"第三章 模式匹配 - 悲观控制结构","type":"extras"},{"doc":"Elixir 的 with Erlang 中的 maybe 他们特殊的地方在于, 当模式匹配出错的时候, 这些结构中, 有对应的控制结构, 来处理最后匹配失败的数据. 关于 with 和 maybe 的更详细的讨论, 见本书的第5章 ≪ 定制新结构 ≫.","ref":"ch03-pattern_match.html#%E4%B9%90%E8%A7%82%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84","title":"第三章 模式匹配 - 乐观控制结构","type":"extras"},{"doc":"异常处理中的模式匹配的处理是特殊的. catch 处理的是函数调用参数列表; 即使如此, 对 :throw 类型的错误, 还有语法糖加持. 参数列表这种语法形式, 只有在函数定义和 catch 的时候才是合法的, 其他地方都是不合法的语句, 所以这种模式匹配是非常独特的. rescue 子句中, 模式匹配时只匹配异常名字. 而且对于运行时错误, 还可以使用 ErlangError 来统配的. 而如果要绑定错误对象就必须使用 guard 匹配; 当然了, 还是阉割过的 guard 匹配, 如果和 case 或函数定义是的 guard 子句比较的化. 像下面的代码展示的那样, 他们都不是常规的模式匹配. EralngError == ArithmeticError #false try do 1 / 0 rescue ErlangError -&gt; &quot;ErlangError can match ArithmeticError&quot; end #ErlangError can match ArithmeticError try do 1 / 0 rescue ArithmeticError -&gt; &quot;ArithmeticError&quot; end # ArithmeticError try do throw 1 catch v -&gt; v end # 1 try do throw 1 catch :thorw , v -&gt; v end # 1 更多的内容见后面的 错误处理章节 . &amp;#x21A9; 见 ≪Erlang 参考手册•maybe≫ 章节","ref":"ch03-pattern_match.html#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D","title":"第三章 模式匹配 - 异常处理中的模式匹配","type":"extras"},{"doc":"","ref":"ch04-parenthese.html","title":"第四章 括号","type":"extras"},{"doc":"在这一章我们讨论的是 语法上可以如何做 , 而 不是实际编码上应该怎么做 . 可以做是一个硬规则, 是面向编译器的; 应该怎么做是一个规范, 是面向程序员的. 所以很多地方, 在讨论完可以如何做后, 我又用黑体给出了社区推荐的做法, 也就是应该如何作. 本章讨论可以做的方法绝大部分, 不符合社区的推荐做法. 一边展示不推荐的做法, 一边规劝大家不要这样做, 这看起来似乎是在左右互博,自相矛盾. 所以这样做, 是为了搞清楚所以然 --- --- 社区给出这些规范的所以然, 也就是规范背后的原因. 当真正的理解了什么是可以做的, 以及什么必须做的时候, 才能理解规范所以如此的原因.","ref":"ch04-parenthese.html#%E6%9C%AC%E7%AB%A0%E7%9A%84%E7%9B%AE%E7%9A%84","title":"第四章 括号 - 本章的目的","type":"extras"},{"doc":"使用括号改变优先级, 这是最普通的括号的用法. 这和我们在数学课堂上使用括号的情形一样. 例如数学公式 $a\\times{}(b+c)$, 对应的程序表达式就是 a*(b+c) . 如果要消除括号, 那么需要调整代码, 并需要引入中间变量. 例如上面的等价的表达式, 可以写作 tem=b+c 和 a*tem 两个表达式. 但是这里有一个前提: 最初的表达式, 在一个块环境中. 因为多个表达式, 必须在块环境中.","ref":"ch04-parenthese.html#%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7%E6%94%B9%E5%8F%98%E4%BC%98%E5%85%88%E7%BA%A7","title":"第四章 括号 - 使用括号改变优先级","type":"extras"},{"doc":"使用 fn ... -&gt; end 定义匿名函数 当我们使用 fn ... -&gt; end 来定义匿名函数的时候, 括号是可选的. pi = fn -&gt; :math . pi ( ) end e = fn ( ) -&gt; :math . exp ( 1 ) end pi . ( ) |&gt; IO . inspect ( label : &quot;pi.()&quot; ) e . ( ) |&gt; IO . inspect ( label : &quot; e.()&quot; ) id = fn v -&gt; v end add_1 = fn ( v ) -&gt; v + 1 end id . ( 1 ) |&gt; IO . inspect ( label : &quot; id.(1)&quot; ) add_1 . ( 1 ) |&gt; IO . inspect ( label : &quot;add_1.(1)&quot; ) add = fn a , b -&gt; a + b end sub = fn ( a , b ) -&gt; a - b end add . ( 1 , 2 ) |&gt; IO . inspect ( label : &quot;add.(1,2)&quot; ) sub . ( 1 , 2 ) |&gt; IO . inspect ( label : &quot;sub.(1,2)&quot; ) 上面的代码中, 对于零元, 一元和二元匿名函数, 用带括号和不带括号两种样式分别做了定义. 可以看出, 在定义匿名函数的时候, 括号完全是可选的. 社区的推荐 : 使用 fn...-&gt;end 定义匿名函数的时候, 不用括号来包裹参数列表. 那么为什么 fn...-&gt;end 定义匿名函数的时候可以不用括号呢? 从形式来看, -&gt; 是参数列表结束而函数分句开始的标识. 所以不需要一个额外的括号来界定参数什么时候开始什么时候结束. 使用函数捕获操作符 &amp; 定义匿名函数 使用函数捕获操作符 &amp; 定义定义函数的时候, () 的作用只限于调整代码的优先级. 而 Elixir 中函数捕获操作符 &amp; 的优先级只高于 =&gt; , | , :: &lt;- 和 \\\\ 这几个操作符, 而这几个操作符, 又都是在特殊的环境下才有意义的, 所以几乎可以说, 函数捕获操作符 &amp; 是最低的优先级的操作符. 因此, 对定义匿名函数的表达式 &amp;(expression) 来说, 因为函数捕获操作符 &amp; 的优先级最低, 而且在 expression 中不允许嵌套函数捕获表达式, 因此 expression 中的其他的操作符, 优先级都比函数捕获操作符 &amp; 的高. 所以, 在表达式 &amp;(expression) 中有没有括号, 表达式的计算顺序都一样. 换句话说, 这里的括号就是多余的, 可以省略. 当需要把定义的函数赋值给一个变量的时候, 匹配操作符 = 的优先级高于函数捕获操作符 &amp; , 但是匹配操作符 = 是右结合的, 会优先完成左值的计算. 所以使用函数捕获操作符, 在匹配操作符 = 右侧定义匿名函数的时候, 像表达式 a=(&amp; expression) 这样, 其中的括号也可以省略. 下面的代码片段, 展示了这种这种情形. id2 = &amp; &amp;1 add_1 = &amp; &amp;1 + 1 sum = &amp; &amp;1 + &amp;2 sub = &amp; &amp;1 - &amp;2 id2 . ( 1 ) |&gt; IO . inspect ( label : &quot; id2.(1)&quot; ) add_1 . ( 1 ) |&gt; IO . inspect ( label : &quot;add_1.(1)&quot; ) sum . ( 1 , 2 ) |&gt; IO . inspect ( label : &quot;sum.(1,2)&quot; ) sub . ( 1 , 2 ) |&gt; IO . inspect ( label : &quot;sub.(1,2)&quot; ) 所以和 fn -&gt; end 语法定义匿名函数情形几乎一样, 使用函数捕获操作符 &amp; 定义匿名函数的也不需要小括号, 但是这里有一点点的不同. fn 和 end 是作为保留字存在的, 优先级高于其他的操作符. 匿名函数可以作为参数传递给其他高阶函数 当把匿名函数通过管道操作符 |&gt; , 传递给其他高阶函数的时候, 使用函数捕获操作符 &amp; 定义的匿名函数就必须使用括号, 因为管道操作符符 |&gt; 的优先级高于函数捕获操作符 &amp; . 例如: ( &amp; &amp;1 + &amp;2 + &amp;3 ) |&gt; apply ( [ 1 , 2 , 3 ] ) 因为管道操作符 |&gt; 优先级高于函数捕获操作符 &amp; , 所以要表达, 把匿名函数作为管道操作符 |&gt; 的左操作数, 这样的意图, 就必须为函数捕获操作符 &amp; 定义匿名函数的表达式加上括号. 现在我们分析一下, 表达式 &amp; &amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3]) 的语义. fun = &amp; &amp;1 + &amp;2 + &amp;3 |&gt; apply ( [ 1 , 2 , 3 ] ) true = is_function ( fun , 3 ) 所以, 这个表达式 &amp; &amp;1+&amp;2+&amp;3 |&gt; apply([1,2,3]) 计算后的结果为一个匿名的三元函数. 如果我们以参数 1,2,3 来调用这个匿名函数, 得到一个错误: ** (BadFunctionError) expected a function, got: 6. 为什么会这样呢? 函数捕获操作符 &amp; 操作优先级最低, 所以整个表达式等价于 &amp;(&amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])) . 加法运算符 + 优先级高于管道运算符 |&gt; , 所以 &amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3]) 等价于 (&amp;1 + &amp;2 + &amp;3) |&gt; apply([1,2,3]) . 因此整个表达式的意思就是: 这是一个三元匿名函数( &amp;1,&amp;2,&amp;3 ), 参数求和后 ( &amp;1+ &amp;2 + &amp;3 ), 把结果作为第一个参数传递给 apply/2 . 虽然我们获得了一个三元的匿名函数, 但是这个匿名函数无论我们输入的参数是什么, 都是要报错的. 三个参数按加法计算, 所以接受的只能是数值类型, 计算后的结果也只能是 数值 , 但是 apply/2 要求的第一个参数是一个 函数 , 所以无论我们以什么参数来调用这个匿名函数, 其结果都是抛出报错. 结论 : 在用函数捕获操作符 &amp; 定义匿名函数时, 不需要括号的参与, 但是要直接把函数捕获操作符 &amp; 定义的函数, 通过管道操作符 |&gt; 传递给其他函数的时候, 因为涉及优先级的问题, 所以必须使用括号, 把函数捕获操作符的优先级提高. 但是在使用函数捕获操作符 &amp; 的时候, 基于代码的可读性, 社区的推荐使用括号. 社区推荐做法 : 使用 &amp; 定义匿名函数的时候, 使用括号把 表达式括起来 , 即使很多时候语法上是不必要的. 也就是说, 按照社区的规范上面的代码中对匿名函数 id2 , add_2 等函数的定义, 应该写作: id2 = &amp; &amp;1 add_1 = &amp; ( &amp;1 + 1 ) sum = &amp; ( &amp;1 + &amp;2 ) sub = &amp; ( &amp;1 - &amp;2 )","ref":"ch04-parenthese.html#%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89","title":"第四章 括号 - 括号与匿名函数定义","type":"extras"},{"doc":"def/2 , defp/2 , defmacro/2 和 defmacrop/2 用来在模块中定义函数, 私有函数, 宏以及私有宏. 这里为了论述的方便, 用函数指代命名函数, 私有函数, 宏以及私有宏. 函数的调用格式 查看文档可以知道这些宏接受的第一个参数叫做 call , 而且我们知道这些宏都有一个同名的一元宏, 其功能就是定义函数或宏的签名, 所以 call 在其他语言中的对应物, 就是函数签名 (function signature) 或者函数头 (function head). 但是为什么不叫函数签名或函数头, 而叫 call 呢? 用一个动词命名参数名, 这多少还是有悖正常的思维. 其中又什么深意吗? 还真是的, 我在 Elixir 论坛中, 得到了答案: 这些宏接受的第一个参数, 必须是函数的调用的形式. 或者说, 代码 def fun(a,b) do...end , 是在编译时调用 def/2 , 这个函数接受两个参数, 第一个是 fun(a,b) 这个函数调用的返回值, 当然这个函数不存在. def 会解析出函数名, 参数列表, 并按照我们的调用的方式, 为我们创建这个函数. 现在让我们来看看函数调用. 函数调用有两种形式: fun_name arg1, arg2 fun_name(arg1, arg2) 所以 call 参数, 也就这些宏接受的第一个参数, 也必须符合这两种模式之一. 要特别注意第二种形式, 括号和函数名之间不能有空格的. 但是为什么要有两种形式呢? 大部分的编程语言, 实际上都只支持第 2 种形式. Elixir 所以支持第 1 种形式有两个原因: 零元函数调用, 省略括号, 看起来像常数的引用, 对于纯函数来说, 零元函数表现的也真的就像一个常数. 宏忽略小括号, 可以更像其他语言的关键字 Elixir 很多功能是宏提供的, 这就使得必须支持宏调用的时候可以省略括号, 否则就需要使用大量的嵌套的括号, 这会使得代码看起来非常的繁琐. 例如这样的代码: defmodule ( M , do : ( def ( fun_name ( a , c ) , do : ( a + c ) ) ) ) 看起来真正像 M 表达式 1 啊. 函数体 def*/2 这几个宏的, 第一个参数 call 我们已经学习了, 他们的第二个参数是 expression , 也就是表达式. 但是实际上必须是 do-block , 其他的表达式, 都是语法错误, 比如我们就不能这样写代码 def add(a,b), a+b . 也就说, 这几个 def*/2 宏接受的第二个参数必须是一个 [do: expression] . 但是需要注意的是, :do 的值只能是一个表达式, 当函数体有不只一个表达式的时候, 就需要用代码块, 或者说块表达式. 而 Elixir 中定义函数体的代码块的有以下两种方式: do...end 直接创建的是一个 do-block . 还可以使用 () 作为块的分界符, 换行或分号作为语句之间分隔符, 来创建块表达式. 也就是说, 还可以使用 [do: (...;...)] 来创建了一个 do-block . 函数定义 这几个 def*/2 宏, 2 个参数各有两种风格, 总共就有 4 种组合. 但是这四种组合中, 不带括号的函数调用 与 [do: (...)] 的组合 不完全支持 . 例如下面的代码: defmodule FunDefine do def add ( a , b ) do a + b end def sub ( a , b ) , do : a - b def div ( a , b ) do if is_integer ( a ) and is_integer ( b ) do Kernel . div ( a , b ) else a / b end end # def multiply a, b, do: a * b # def multiply a, b do: a * b # 注意这里没有逗号 ^, 可是依旧不能通过编译 end 我试图通过定义 add , sub , div 和 multiply 来演示函数定义的全部 4 种组合. 但是第 4 种样式报错, 为什么呢? def multiply a, b, do: a * b 不正确的原因在于, 词法分析器无法判断 函数参数列表 什么时候结束. 那么对于代码: def add a , b do a + b end 词法分析器是怎么就能知道参数列表什么时候结束呢? 这就是 do 的作用了. 否则, 如果编译器只是通过 :do 前面是不是有逗号, 来判断参数定义是否结束的话, 那么 def multiply a,b do: (a*b) 就应该通过编译的. 现在这样的代码不能通过编译, 说明在编译的词法分析阶段, 对 do 是做了特殊处理. 这是正是 do 作为保留字的原因, do 在这里并没有引入控制结构, 它充当了参数列表与函数体之间的分界符, 并创建了 do-block . 上面我们说, 第四种组合不被完全支持, 换句话说, 这种组合方式得到了部分支持的. 那么什么时候支持这种格式呢? 那就是定义无参数函数的时候. 例如下面的代码, 语法上是正确的: def e , do : :math . exp ( 1 ) 推荐规范 : 定义函数或宏的时候, 零元函数除外, 推荐带有括号的函数头格式.","ref":"ch04-parenthese.html#%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89","title":"第四章 括号 - 括号与命名函数定义","type":"extras"},{"doc":"命名的函数调用可以省略括号, 而匿名函数调用的时候必须使用括号. 函数调用的时候, 如果使用括号, 函数名和括号之间不能有空白 . 命名函数的省略括号调用 我认为允许命名函数和私有函数调用可以省略括号 2 , 这是 Elixir 语言的一个设计缺陷. 理由如下: 这样做使得命名函数, 不再是一等公民了, 一个函数式编程的语言, 命名函数不是一等公民, 总是些不协调的. 允许不带括号调用函数, 使得不能直接以函数名来引用函数, 而必须使用 &amp; 或者 Function.capture/3 . 允许函数调用省略括号带来的好处非常的小; 但因此导致必须使用函数捕获的相关语法, 才能引用函数. 这使得函数引用的语法非常不经济. 在我编码的时候, 首先思考的是哪个函数可以满足需求, 无论是要调用它, 还是要把它作为参数传递其他高阶函数. 所以首先确定是函数的名字, 然后才是思考是 调用 还是 引用 . 如果是要调用这个函数, 写括号也非常的流畅, 因为这时的思维的运行步骤与代码的书写步骤是一致的. 但是在需要引用这个函数的地方, 因为函数捕获操作符 &amp; 放在函数名的前面, 当意识到需要的是这个函数的引用的时候, 必须把光标重新移动到函数名的前面, 更糟心的是, 引用命名函数 (准确的说是捕获), 还需要指定函数的元数, 这意味着, 还需要再次把光标移动到函数名的后面. 也就是说, 对于代码, &amp;String.length/1 , 我往往是先写出中间的 String.length 部分, 然后向左移动光标, 到这个表达式的头部补上函数捕获操作符 &amp; , 再向右移动光标到表达式末尾, 指定函数的元数. 这种体验实在是太糟糕了. 很多时候, 看到代码中 &amp;String.length(&amp;1) 这样的表达式, 我忍不住就想把其修改为 &amp;String.length/1 . 也许 &amp;String.length/1 更正确和高效, 但是 &amp;String.length(&amp;1) 更加符合思维的顺序. 我的期望, 应该禁止命名函数的无括号调用语法, 而只允许宏调用可以省略括号. 这样函数名就是对函数的引用, 命名函数可以作为第一类公民了, 或者非常接近第一类公民了. 考虑到命名函数, 可能有多个同名而元数不同的函数, 引用命名函数的时候可以使用Eralng 函数导出一样的语法: String.length/1 . 函数类型是不能作为除法的运算数的, 所以这样就没必要使用函数捕获操作符了. 实际上 Erlang 中就是这样来区分函数的引用, 还是函数的调用的. 可是这是一个大工程, 必须在 Elixir 的源码级别改动, 且如此改动, 还会引发不兼容问题. 匿名函数调用必须用括号 调用匿名函数的时候, 必须使用括号. 例如这样的代码: fun = fn a , b -&gt; ( a * * 2 + b * * 2 ) * * 0.5 end ; fun . ( 3 , 5 ) 关于 Elixir 的匿名函数调用需要一个句号 . , Erlang 之父 Joe Armstrong 在 A Weak of Elixir 的文章中, 认为这是 Elixir 语义设计的不好的地方. 当然了, 也有不少人认为这不是问题. 我想从另一个角度来考虑这个问题. 一个函数, 尤其是支持函数编程语言中的函数, 总是需要从语法上来区分 调用 还是 引用 的. Elixir 的命名函数, 牺牲了对函数的引用的便捷, 换来调用命名函数时括号的可省略. 匿名函数的值, 本身就是存在一个变量中的, 所以引用非常的方便, 那么调用这个匿名函数的时候, 变量名后面的这个 . 实际上就是一种宣告: 这是对函数的调用, 而不是引用其值. 所以理论上, 对匿名函数的调用也没必要必须使用括号. 但是为什么 Elixir 中却要求必须使用括号呢? 这里我们先把问题搁下, 让我们先来总结一些括号在 Elixir 中的用法.","ref":"ch04-parenthese.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8","title":"第四章 括号 - 函数调用","type":"extras"},{"doc":"上面的几节中, 我们学习了括号在函数定义, 调用, 以及其他场景下的作用. 总结一下, 其实共有三个作用: 作为参数的列表的分界符 改变代码运行的优先级 创建块表达式 现在问一个问题: 以下的代码, 语法上正确吗? 如果正确的话, 返回值是什么呢? [] , {} , () 第一个问题的答案是: 这三个都是语法正确的. 前两个非常的常见, 它们是空的列表和空的元组. () 的返回的是 nil . 不知道这个答案有没有让你感到意外, 但是我第一次知道的时候, 感觉非常的意外. true = is_list [ ] true = is_tuple { } true = nil === ( ) 这个知识点, 实际上解释了函数调用的这个规则: 命名函数的调用, 如果要使用括号, 括号必须紧跟着函数名,其间 不能有任何空白字符 . 实际上函数定义的时候也是这样. 其他编程语言中, 基本上没有这样的语法规则, 大家所以这样做, 不过只是编码规范. 但是在 Elixir 中, 因为允许调用命名函数的时候, 可以不使用括号, 而一个空括号 () 的返回值又是 nil . 这样 fun_name () 的语义就变成了: 以空括号 () 表达式的结果 nil 为参数, 调用函数 fun_name . 所以 Elixir 中就多了这样一个关于函数调用时括号的语法. 这是一个语法, 而不是编码规范. 但是为什么 () 的返回值是 nil 呢? 这里 () 实际上是空的块表达式. 块表达式的值是块中的最后一个表达式的值, 而空块表达式 () 没有表达式, Elixir 所有代码都是表达式, 因此都需要有返回值. 对于空的块表达式, 最合理的返回值只能是用来表示空的 nil 了. 其他语言中, 括号的作用只有括号在 Elixir 中的前两个功能, 所以其他语言函数调用的时候, 语法上不用做这个要求. 现在重新来探索上面搁置的问题: 匿名函数的调用为什么必须使用括号呢? 思考代码: fun. (3, 4) 语法正确吗? 如果正确, 那么等价于 fun.(3,4) 还是 fun.(4) ? 如果 fun 是一个二元函数, 你会发现, fun. (3,4) 和 fun.(3,4) 是一样的. 也就是说, 匿名函数的调用, 虽然必须使用小括号把参数括起来, 但是小括号和 . 之间可以有空白 . 意外不? 实际上, 我们甚至可以把函数名和 . 之间也添加空白, 像这样: fun . (3, 4) . 我所以感到意外, 是因为自己先入为主的错误偏见: 命名函数调用时, 括号和函数名之间都不能有空白, 而 Elixir 的官方对匿名函数后面的 . 解释是: 本来这个点后面应该是函数名的, 但是因为这是一个无名的函数, 所以就只剩下括号了. 虽然没有说, 点和括号直接不可以有空格, 但是, 如果我们接受 Elixir 官方对 . 的解释, 自然的推断就是不能有空格. 但是从另外一个角度来看, 其实 . 两边可以有空白又是那么的自然, 完全不应该惊讶: . 是一个二元操作符. 所有的二元操作符, 比如 + , - 和操作数之间不都可以有空白的吗? 这种惊讶只是思维盲区带来的. 一旦我们认识到 . 是一个二元操作符, 就豁然开朗了. 但是如果我们意识到 . 是一个操作符, 那么为什么调用匿名函数的时候又必须使用括号呢? 毕竟 (2) 的返回值就是 2 吗? 在抽象语法上表示中, (2) 和 2 也没有任何的区别. 但是实际上是有区别的, (2) 所以等于 2 , 是 (2) 被作为块表达式, 计算后的结果等于 2. 但是如果当作参数表来处理, (2) 就不等于2. 我们不可以在不需要参数列表的时候, 提供参数列表的语法的. 例如单独的 (1,2) 就不是一个合法的表达式. 匿名函数调用, 所以必须使用括号, 是因为 . 操作符要求, 当其左操作数是函数的时候, 右操作数必须是参数列表.","ref":"ch04-parenthese.html#%E6%8B%AC%E5%8F%B7%E5%B0%8F%E7%BB%93","title":"第四章 括号 - 括号小结","type":"extras"},{"doc":"最后需要讨论一下块表达式和作用域的关系. 块表达式, 还是表达式, 它没有创建新的作用域. 但是 do ... end 的代码块, 因为是跟在作用域相关的语法结构后面, 所以, 其中的代码一般都是在新的作用域中的. 例如下面的代码: a = 0 ( b = 1 IO . inspect ( a , label : &quot;in block exprssion, a&quot; ) a = b + 1 ) IO . puts ( inspect ( a : a , b : b ) ) 在块作用表达式中, 当然可以访问外部的变量 a 就像第 4 行代码显示的那样. 而且, 还可以对外部作用域中定义的变量 a 赋新值. 而第 7 行表明, 不但变量 a 的值改变了, 而且块表达式中定义的变量 b , 在块外部也可见. 结论 : 块表达式并 不创建 新的作用域 . 不但块表达式不创建新的作用域, 使用括号表示的参数列表, 其作用域也属于外部. 例如下面的代码: b = :math . sin ( a = :math . pi ( ) / 2 ) { a , b } |&gt; IO . inspect ( ) # {1.5707963267948966, 1.0} 但是宏调用不一样. 宏是特殊的函数, 它接受 ast, 返回的也是 ast. 以宏的功能的不同, 可能会向运行时中注入宏参数一样的变量, 也可能不注入, 甚至还可能注入和宏参数完全无关的变量. ( c = 1 ) &amp;&amp; ( d = 2 ) false = :d in ( binding ( ) |&gt; Keyword . keys ( ) ) false = c in ( binding ( ) |&gt; Keyword . keys ( ) ) 上面的代码展示了, &amp;&amp; 宏, 并不把其接受的 ast 中的变量, 注入到运行时. &amp;#x21A9; Meta-expression, 这是 List 语言的设计者最初打算实现的, 给程序员使用的表达式格式, 但是最终 S 表达式流行起来, M 表达式从来没有实现. &amp;#x21A9; 这一小结节中, 函数就只是函数, 不再包括宏.","ref":"ch04-parenthese.html#%E5%9D%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F","title":"第四章 括号 - 块表达式不是作用域","type":"extras"},{"doc":"","ref":"ch05-new_constructor.html","title":"第五章 定制新结构","type":"extras"},{"doc":"Elixir 是一个特别灵活的语言, 这不但是说, Elixir 本身提供的语法结构非常灵活, 更加重要的是, 如果我们不满意 Elixir 提供的控制结构, 那么可以按照自己的意图, 来定义自己的控制结构.","ref":"ch05-new_constructor.html#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84","title":"第五章 定制新结构 - 定义自己的控制控制结构","type":"extras"},{"doc":"赋值与思维流 确切的说, = 叫做匹配操作符, 而不是赋值操作符. 但是变量可以匹配任意的值, 所以实际上, Elixir 中还是用 = 来做赋值的操作. 在其他编程语言中, 赋值是一个非常简单的操作, 因为赋值语句非常简短, 基本上一眼就能看清楚赋值的结果是什么. 其他语言中, 块语句不是表达式, 但是在 Elixir 中语句块也是表达式. 当赋值语句的右侧出现的是语句块的时候, 代码序列往往和思维序列不协调. 首先让我来描述一下, 我阅读这样代码时的思维过程. 因为是一个块语句, 也就是说 = 的右边需要多个步骤, 多个操作才能完成最后的结果. 阅读代码的时候, 思维自然要跟随代码, 以理解代码的意图. 当多个步骤执行完成后, 在我的思维中, 往往忘记了 = 的左边的表达式是什么了, 因为最后结果和变量之间的距离太远了, 这个距离既是物理上的, 也是心理上的. 而写一个块语句的时候, 在完成整个功能之前, 实际上我不知道最后的结果会是什么, 甚至不知道, 这个块语句就是函数最后的结果, 还是只是计算的中间过程. 所以基本上, 我也是先完成块语句然后再决定是否需要把结果赋值给一个变量的. 当我意识到需要把块语句的结果赋值给一个变量的时候, 这时候光标往往是停留在块语句的结尾处, 要完成赋值语法, 只好移动光标, 这让我有些烦恼. 我更希望写出的代码能和思维流一致, 这样写代码的时候流畅, 阅读的时候也更轻松. 设计赋值语句 Elixir 支持宏编程, 这就给我们提供了设计自己的赋值语句提供了可能. 但是 = 是一个特殊形式, 所以不能从新定义它, 而只能利用 = 提供的功能, 来重新设计新的语法糖. 首先让我来描述清楚, 我想要的语法是什么样的. if exprestion do :zero else :is_not_zero end |&gt; assign ( to : v ) 这样简单的, 可以使用 Elixir 提供的语法直接转化成为一行的代码: v = if exprestion, do: :zero, else: :is_not_zero . 这个时候使用 assign/2 是没有必要的. 但是当 if 语句不能转化成一行的代码时候, 或者当需要把 case 或 cond 结果赋值为一个变量的时候, 代码序列和思维流之间的阻抗就更加的明显了. 这个时候, 使用 assign/2 能让代码易写易读. 假设我们要控制一个机器人, 机器人使用一个 GenServer 表示, 它的状态是 %{x: x, y: y, diriction: direction} , 表示机器人所在的位置 x, y 和面对的方向 ( :E , 东方; :W , 西方; :N , 北方; :S , 南方). 当机器人接受到转弯的指令后, 就会按照指令转弯, 从而改变自己的状态. 那么处理右转的代码就是这样: def handler_cast ( { :turn , :right } , %{ direct : direct } = state ) do direct = case direct do :N -&gt; :E :E -&gt; :S :S -&gt; :W :W -&gt; :N end { :noreply , %{ state | direct : dircet } } end 那么在 assign/2 的帮助下, 可以把上面的代码重构为: def handler_cast ( { :turn , :right } , %{ direct : direct } = state ) do case direct do :N -&gt; :E :E -&gt; :S :S -&gt; :W :W -&gt; :N end |&gt; assign ( to : direct ) { :noreply , %{ state | direct : dircet } } end 这样的代码整洁了不少吧? 现在让我们来看看, 如何来实现 assgin/2 . 赋值实现 我们需要把 assgin/2 定义为一个宏, 这个宏的功能非常的简单, 只是 = 的语法糖嘛, 所以可以这样来实现. defmodule Corner.Assign do defp do_assign ( value , pattern ) do quote do unquote ( pattern ) = unquote ( value ) end end defmacro assign ( value , to : pattern ) , do : do_assign ( value , pattern ) #...other end 这个实现, 完成了我们期望的工作. 这里 assign/2 并不改变直接使用 = 的语义代码的语义. 调用 assign(value, to: pattern) , 当 pattern 和 value 不匹配的时候, 依旧会抛出匹配错误, 因为 assign(value, to: pattern) 本质上就是 pattern = value , 所以任何可以作为匹配操作符 = 左值的语法, 都可以作为 assign/2 的 :to 的值, 毕竟 assign/2 仅仅是语法糖. 这样的语法糖, 让代码更简洁, 美观, 如此而已. assgin/2 现在帮助我们减少了代码的序列和思维流之间的阻抗, 但是像上面对 hanlder_cast/2 的重构那样, 最后的返回语句不能使用管道操作符 |&gt; 连接起来, 这样的代码序列, 反映到思维流上, 就是思维流的打断. 如果 assign/2 能帮助我们把思维流也接续起来, 那么写 elixir 代码就更加愉悦了. 能让思维流保持连续的代码, 我认为是这样的: def handler_cast ( { :trun , :right } , %{ direct : direct } = state ) do case direct do :N -&gt; :E :E -&gt; :S :S -&gt; :W :W -&gt; :N end |&gt; assign ( to : direct , do : %{ state | direct : direct } ) end 再假设有现在我们有三个函数, 分别是 step1:: ()-&gt;any , step2:: (any) -&gt;{:ok,t}|{:error,any} 和 step3::(t)-&gt;any . step1 的结果作为 step2 的输入, step2 返回 {:ok,v} 时. v 作为 step3 输入. 那么无论是: {:ok, v} = step1() |&gt; step2() step3(v) 还是: step1 ( ) |&gt; step2 ( ) |&gt; assign ( to : { :ok , v } ) step3 ( v ) 阅读的时候, 思维流都是被打断的. 但如果 assign 允许我们写下面的代码, 就能让思维流保持连续. step1 ( ) |&gt; step2 ( ) |&gt; assign ( to : { :ok , v } , do : v ) |&gt; step3 ( ) 也就是说, 为 assign/2 在添加一个可省略的 :do 选项, 就能让思维流接续起来. 这个实现也非常的容易, 当我们完成 pattern = value 的赋值后, 再计算 do: expression 的值可以了. defmodule Corner.Assign do #assing(value, to: pattern) defp do_assign ( value , pattern , block ) do quote do unquote ( pattern ) = unquote ( value ) unquote ( block ) end end defmacro assign ( value , to : pattern , do : expression ) do do_assign ( value , pattern , expression ) end #... end 有了 assgin(value,to: pattern, do: block) 的帮助, 上面的多步骤组合的代码就可以这样来写. defmodule Demo do import Corner.Assgin , only : [ assign : 2 ] defp step1 ( ) , do : 1 defp step2 ( v ) , do : { :ok , v + 1 } defp step3 ( v ) , do : IO . inspect ( v , label : &quot;in step3 v&quot; ) def do_work ( ) do step1 ( ) |&gt; step2 ( ) |&gt; IO . inspect ( label : &quot;after setp2&quot; ) |&gt; assign ( to : { :ok , v } , do : v ) |&gt; IO . inspect ( label : &quot;after assign/2&quot; ) |&gt; step3 ( ) end end Demo . do_work ( ) #after setp2 : {:ok, 2} #after assign/2 : 2 #in step3 v: 2 在 assign/2 的帮助下, 我们写的 Elixir 代码, 几乎也可以做到 point-free 了. 如果赋值之后, 我们需要做非常多的计算, 那么使用 do: (...) 就不那么方便, 对这种情况, 可以非常简单的提供一个 assign(value, [to: pattern] ,do: block) 宏来解决. defmacro assign ( value , [ to : pattern ] , do : expression ) do quote generated : true do unquote ( pattern ) = unquote ( value ) unquote ( expression ) end end 在导入我们的宏之后, 就可以如此来使用赋值语句了: import Corner.Assign function ( ) |&gt; assing ( to : { :ok , v } ) do do_lot_of_work_with ( v ) end 可以看出, 在管道操作符右侧, 使用 do-end 块会使得代码编码的不那么整齐. 所以最终的库中, 我没有提供 assign/3 这个宏. 正常的情况下, 使用 :do 选项中应该只有一个表达式. 如果发现 :do 选项中, 需要两个或更多的表达式才能完成最终的工作, 那么第一种选择是把 :do 选项中的语句提取为一个新的函数. 第二种选择是在 :do 使用变量,绑定中间结果. 然后在后续的代码中, 使用变量绑定的值, 完成剩余的工作. step0 ( ) |&gt; step1 ( ) |&gt; assgin ( to : { :ok , v } , do : v ) |&gt; extract_function_from_do ( ) |&gt; step2 ( ) |&gt; ... 或者 step0 ( ) |&gt; assign ( to : { :ok , v } , do : tem = do_sample_with ( v ) ) the_code_use_tems |&gt; step2 ( ) |&gt; ... import 语句非常的方便, 但是问题在于, 如果是全部导入的话, 从文本上, 我们不知道到底导入什么内容. 所以 Elixir 官方的文档中告诉我们, 应该优先使用 require 其实才是 import 最后是使用 use . assgin 宏不是操作符, 从功能上来说, 完全可以不使用 import 语句. 使用 require 语句之后, 我们就可以带着模块名来使用, assgin/2 宏了. 例如 1 |&gt; Corner.Assgin.assgin(to: v, v + 1) . 语法上, 这样显的非常的啰嗦. 可以定义宏 to/2 来消除这种啰嗦. defmacro to ( value , pattern ) , do : do_assign ( value , pattern ) defmacro to ( value , p , do : block ) , do : do_assign ( value , p , block ) 这样, 使用 require Corner.Assgin, as: Assign 后, 使用 to/2 可以使得代码变得整洁. require Corner.Assign , as : Assign some_code ( ) |&gt; Assgin . to ( { :ok , v } , do : v + 1 ) #...","ref":"ch05-new_constructor.html#%E8%B5%8B%E5%80%BC","title":"第五章 定制新结构 - 赋值","type":"extras"},{"doc":"如果要选 最不喜欢的语言结构 , Elixir 的 with 是我的答案. 我所以不喜欢这个语句结构, 首先是像 with 语句中的 &lt;- 暗示的那样, 其中的代码序列和逻辑思维流之间存在阻抗. 其次, with 结构的代码布局非常的不美观. 例如代码: with # with 头部开始 { :ok , a } &lt;- fun1 ( ) , # 产生子代码 #... # 更多产生子代码 { :ok , b } &lt;- fun2 ( a ) # with 头部结束 do # with 体开始 action_with_a_and_b # with 体结束 else # 尾部开始 patter1 -&gt; hanlder_error1 patter2 -&gt; hanlder_error2 # 尾部结束 end 这个 with 结构, 像代码中注释的那样, 可以分成 3 部分, 分别是 头 , 体 和 尾 . 通常情况下, with 代码就像上面的片段展示的这样, with 头往往有多个语句, 而 with 体却只有一行或很少的几行代码. 像这样的头部或者参数部分, 多于体或者正文的语法结构, 除了 with 语句外, 我没有见过别的语法有这样的布局. 这样的布局, 给我的感觉是头重脚轻, 极度不协调. 看到这样的代码, 不由自主地, 我的脑海中总是浮现出有染色体缺陷的畸形儿的形象. 所以我非常的不喜欢这个语法结构. 如果不使用 with 语句, 等价的代码应该如何写呢? 我认为可以写成这样: try do { :ok , a } = fun1 ( ) { :ok , b } = fun2 ( a ) action_with_a_and_b rescue % MatchError { term : term } -&gt; case term do pattern1 -&gt; handler_error1 pattern2 -&gt; handler_error2 end end 对于没有 else 部分的 with 语句, 就更加简单: try do { :ok , a } = fun1 ( ) { :ok , b } = fun2 ( a ) action_with_a_and_b rescue % MatchError { term : term } -&gt; term end 而如果语句已经在一个块结构中了, 代码还可以进一步的精简: def fun do { :ok , a } = fun1 ( ) { :ok , b } = fun2 ( a ) atction_with_a_and_b rescue % MatchError { term : term } -&gt; term end 所以我认为本质上, with 语句只是帮助我们写了 try 块. 我认为理想的 with 语句应该只要 体 和 尾 两部分就够了. 特殊表达与保留字 在前面的章节中, 已经多次出现 特殊表单 (Special Forms)这个短语了, 但是特殊表单到底意味着什么呢? 我最初的理解, 特殊表单就像是别的语言中的关键字或者保留字. 这些符号和词汇, 不但有语言规定的意义而且不能用作变量名和函数名, 现在不少的语言, 对保留字的限制有所放宽, 比如 Javascript 中, 保留字虽然还不允许作为变量存在, 但是已经可以作为对象的方法或者字段名了. 在 Elixir 中, 有些特殊表单是没法用 Elixir 的语法来实现的. 比如 with 这个特殊表单, 它的特殊就在于其参数个数是不定的, 而 Elixir 中, 无论是函数还是宏的定义, 都不允许不定参数, 所以使用 Elixir 自身的语法是没法定义 with 这样的参数个数不定的宏. 但是 with 可以作为变量吗? 可以作为我们的函数名吗? 让我们来探索一下. with = 2 IO . inspect ( with == 2 , label : &quot;with can used as variable&quot; ) with { :ok , a } &lt;- { :ok , 1 } , { :ok , b } &lt;- { :ok , a + 2 } do a + b end |&gt; then ( &amp; ( &amp;1 == 4 ) ) |&gt; IO . inspect ( label : &quot;with can still work&quot; ) defmodule A do def with ( a , b ) , do : a + b end A . with ( 1 , 2 ) |&gt; then ( &amp; ( &amp;1 == 1 + 2 ) ) |&gt; IO . inspect ( label : &quot;with can use as function name&quot; ) 特殊表居然可以用作变量和函数名. 而且即使用作变量, 也不影响它作为特殊表单的功能. 但是保留字不一样, Elixir 中也有保留字, 虽然非常非常的少. 只有: true , false , nil , when , and , or , not , in , fn , do , end , throw , catch , rescue , after 和 else , 共 16 个. 但是 with 不是, 只要不是保留字, 就可以作为变量, 以及函数名, 甚至模块名. 从上面的代码的输出中, 我们可以看出, 实际上 Elixir 对 with 几乎没有做限制. 我不满意 with 结构, 现在知道, 我们可以使用 with 来定义宏. 但是这不是一个好决定. 首先, 使用 with 作为宏的名字, 使得定义的宏不能直接导入到客户端的上下文中, 而只能用 require 加载宏, 然后带着模块名来使用我们定义的宏, 像上面的代码第 15 行展示的那样, 使用模块前缀来调用模块中的, 以 with 命名的宏. 因为特殊表单 (这里是 with ) 不允许被覆盖, 我们不能通过 import Kernel.SpecialForms, expect: [with: 1] 来排除它. defmodule CanNotExceptSpecailForm do import Kernel.SpecialForms , except : [ with : 1 ] # ... other code not use Kernel.with end 所以, 只要向环境导入特殊表单同名且参数个数一样的函数或宏, 比如 A.with/1 , 就会引发了编译器的报错. 最后, 即使不是特殊表达, 而是一般的宏, 如果我们自定义的和 Kernel 模块中的不兼容的话, 还是不建议使用同名覆盖的策略. 让我们看以下, 假如我们要覆盖 if/2 这个宏会发生什么吧. defmodule IF do import Kernel , except : [ if : 2 ] defmacro __using__ ( _opt ) do quote do import Kernel , except : [ if : 2 ] import IF end end defmacro if ( a , b ) do a &amp;&amp; b end end defmodule ExceptIfButStillUseIt do use IF a = 1 if ( a , IO . puts ( &quot;hello&quot; ) ) # ... other code use the IF.if Kernel . if ( a , do : IO . puts ( a ) ) end 这里的问题主要是两点: 对于不熟悉我们的模块的人来说, 看到第 19 行的 if 语句会让非常的困惑. 在已经导入我们的宏的上下文中, 如 19 行那样, 必须使用 Kernel.if 的时候, 就只能带着 Kernel 模块前缀了. 核心模块中提供的宏, 特殊表单和保留字, 编译器对它们的限制, 可以总结为下表. | 标识符类型 | 举例 | 用作普通标志? | 可以被覆盖? | |--------|----|----|---| | 一般标识符 | if | 可以 | 是的 | | 特殊表达 | with , case cond | 可以 | 不可以 | | 保留字 | fn , do 等 | 不可以 | 不可以 | 回到 with 的话题上, 现在知道, 我们定义的新宏, 不应该命名为 with , 那么应该叫什么呢? Erlang 的新版本 OTP 25 中引入了新的特性 maybe 1 . 它实际上和 with 解决一样的问题. 因此, 为了向 Erlang 靠拢, 我们以 maybe 来命名我们定义的宏. maybe 的用法 首先, 让我们确定如何使用 maybe . 对于使用 with 的代码: with # with 头部开始 { :ok , a } &lt;- fun1 ( ) , { :ok , b } &lt;- fun2 ( a ) # with 头部结束 do # with 体开始 action_with_a_and_b #with 体结束 else #尾部开始 patter1 -&gt; hanlder_error1 patter2 -&gt; hanlder_error2 # 尾部结束 end 和 with # with 头部开始 { :ok , a } &lt;- fun1 ( ) , { :ok , b } &lt;- fun2 ( a ) # with 头部结束 do # with 体开始 action_with_a_and_b #with 体结束 end 使用 maybe 应该重构为: maybe do #maybe body begin { :ok , a } = fun1 ( ) { :ok , b } = fun2 ( a ) action_with_a_and_b #maybe body end else #maybe tail start patter1 -&gt; hanlder_error1 patter2 -&gt; hanlder_error2 #maybe tail end end 和 maybe do { :ok , a } = fun1 ( ) { :ok , b } = fun2 ( a ) action_with_a_and_b end 需要注意的是: 我们的 maybe 中使用的是 = 而不再是 &lt;- , 而且和 Erlang 中的 maybe 也不一样, 我们不用引入新操作符(Erlang 的 maybe 结构中, 引入了新的操作符 ?= ). 新的 maybe 结构中, 在 action_with_a_and_b 对应的代码中, 如果发生匹配错误, 会直接返回匹配操作符的右值或跳转到 else 段落; 在 with 代码中, action_with_a_and_b 对应的代码发生匹配错误, 会抛出异常的. 这是一点不同. maybe 的定义 现在让我们定义 maybe 宏. 我们的 maybe 接受一个参数, [do: body, else: tail] , maybe 宏把代码转化成为对应的 try 语句块. defmodule Corner.Maybe do defmacro maybe ( do : body ) do quote do try do unquote ( body ) catch :error , { :badmatch , v } -&gt; v end end end defmacro maybe ( do : body , else : tail ) do quote do try do unquote ( body ) catch :error , { :badmatch , v } -&gt; case v do unquote ( tail ) end end end end end 要使用 maybe 只要导入我们的宏就可以了.","ref":"ch05-new_constructor.html#with","title":"第五章 定制新结构 - with","type":"extras"},{"doc":"匿名函数, 因为没有名字, 所以不能直接的在其内部调用自己. 计算机科学中, 这个问题, 可以通过不动点组合子来完成 2 . 但是老实说, 对于 Y 组合子, 如果不查看文档的话, 我不能写出正确的表达. 对我来说, Y 组合子太绕了. 不使用 Y 组合子, 当然也可以完成匿名函数的递归: tem_fun = fn ( fun , n , acc ) -&gt; if n == 0 do acc else fun . ( fun , n - 1 , acc + n ) end end fun = fn ( n , acc ) -&gt; tem_fun . ( tem_fun , n , acc ) end 这样的代码框架几乎是固定的, 所以可以定义一个宏 fn! 来为自动生产这样的框架. 例如, 我想这样来写代码: fn! fun do ( n , acc ) -&gt; if n == 0 do acc else fun . ( n - 1 , acc + n ) end end fn! 和 fn 很像, 通用用来定义匿名函数, 但是在 fn! 的上下文中, 可以用函数名来完成递归调用. 从这一点上来说, fn! 可以看作是 fn 的加强版. fn! 的定义 现在让我们仔细分析 fn! 到底应该帮助我们做些什么. 首先, 我们分析 fn! 的输入. 第一个参数是表示递归匿名函数名字的变量. 第二个参数是一个 do-block , 其中的内容应该一个或多个 args -&gt; bodys 表达式. 我们需要把 do-block 中的内容转化为一个真正的递归调用函数, 而所作的就是为每个分句都添加一个表示递归函数自身的参数. 当分句中没有对 name 函数的调用时, 新添加的第一个参数, 没有用处, 所以应该添加 _ 前缀, 以避免恼人的编译警告. 虽然这个新添加的变量, 只要不予 args 中的变量重复, 叫什么都无所谓, 但是为了逻辑的清晰, 我们还是用 name 来命名这个表示递归函数自己的参数. 在这个整整的递归调用函数内容, 如果有对 name 函数的调用, 例如 name.(a,b) 这样的表达式, 需要转化为 name.(name, a,b) . 这是我们的 fn! 宏的最困难的工作, 这个工作由 make_fn/2 完成. 而 make_fn/2 要做的就是处理没有命名函数的的分句. 处理所有分句后, 把这些分句组合成为一个匿名函数. 所以 make_fn/2 的代码也非常简单. defmodule Corner.Fn do # 其他代码 defp make_fn ( name , body ) do new_body = Enum . map ( body , &amp; clause_handler ( name , &amp;1 ) ) { :fn , [ ] , new_body } end # 其他代码 end clause_handler/2 函数完成对每个分句的处理. 它做的工作也非常简单, 检查整个函数分句的函数体的语法树, 并修正其中的递归调用的部分. 如果分句的函数体中有修正, 那么修正后的抽象语法树, 也修正前的不一样, 这样, 我们就能知道, 为这个分句新添加的表示递归函数自己的参数, 用不用添加 _ 前缀. 向参数列表中添加新参数的工作由 make_args/2 完成. 这个工作相对来说比较简单, 只是向列表头部添加一个元素而已. 唯一需要注意地方就是, 需要考虑参数中的哨兵语句. 当新的参数和新的函数体都完成后, 最后只需要把它们重新组合为匿名函数, 就完成了对可递归调用匿名函数的定义. defp clause_handler ( name_ast = { atom , _ , _ } , { :-&gt; , meta , [ args | body ] } ) do new_body = Macro . postwalk ( body , &amp; correct_recursive_call ( atom , &amp;1 ) ) new_args = if new_body != body do make_args ( args , name_ast ) else name_ast = &quot;_ \#{ atom } &quot; |&gt; String . to_atom ( ) make_args ( args , { name_ast , [ ] , nil } ) end { :-&gt; , meta , [ new_args | new_body ] } end defp make_args ( [ { :when , meta , args } ] , fun ) do [ { :when , meta , [ fun | args ] } ] end defp make_args ( args , fun ) do [ fun | args ] end 对递归调用的修正工作由函数 correct_recursive_call/2 完成. 假设我们的匿名的递归函数叫做 fun , 那么 correct_recursive_call/2 做的工作就是, 找到 fun.(a,b) 对应的抽象语法树, 修改为 fun.(fun,a,b) 对应的抽象语法树. 而其他的语法树, 保持原样. # call is ast of `atom.(...args)`. # The return is ast of `atom.(atom,...args)`. defp correct_recursive_call ( atom , call = { { :. , _ , [ { atom , _ , _ } = fun ] } , _ , args } ) do call |&gt; Tuple . delete_at ( 2 ) |&gt; Tuple . append ( [ fun | args ] ) end defp correct_recursive_call ( _ , ast ) , do : ast 最后, fn! 函数完成的的工作就非常简单了. 首先检查递归匿名函数的所有的分句, 都有相同个数的参数. 然后创建与递归匿名函数参数个数相同的匿名函数, 在其内部代理已经定义好的可递归的匿名函数. 这里有一点点风险, 最后定义的代理匿名函数的变量是自动生成的. 作为中间变量存储可递归匿名函数的变量, 必须和它们不一样. 为了保证这一点, 我们当然可以自己定义参数生产函数. 这里并没有这样做, 而是使用了一点小技巧, 可以确保用来保存可递归匿名函数的变量绝对不会和 Macro.generate_arguments/2 产生的参数重复. Macro.generate_arguments/2 产生的参数, 都是小写字母开头的, 所以只要定义的变量, 以大写字母开头就可以了. 在常规的 Elixir 中, 是不能定义大写字母开头的变量的, 但是在宏定义中, 可以这样做. defmacro fn! ( name , do : block ) do case syntax_check ( block ) do { :ok , arity } -&gt; var = { :TEM_fun , [ ] , nil } tem_fun = make_fn ( name , block ) params = Macro . generate_arguments ( arity , nil ) quote do unquote ( name ) = fn unquote_splicing ( params ) -&gt; unquote ( var ) = unquote ( tem_fun ) unquote ( var ) . ( unquote ( var ) , unquote_splicing ( params ) ) end end :error -&gt; raise SyntaxError , &quot;the clauses must have the same arity.&quot; end end 对递归函数子句参数个数做检查的工作有 syntax_chexk/1 完成. 它的工作非常的简单, 如果只有一个子句, 那么无论这个子句有多少参数, 都是合法的. 返回 {:ok,arity} 就可以了, 子句多于一个, 那么后续子句的参数个数, 必须和第一个子句的参数个数一样. 这是非常典型对列表的递归检查. defp syntax_check ( [ { :-&gt; , _ , [ args | _ ] } | others ] ) do args = Ast . get_args ( args ) check_args_length ( others , length ( args ) ) end defp check_args_length ( [ ] , len ) do { :ok , len } end defp check_args_length ( [ { :-&gt; , _ , [ args | _ ] } | others ] , len ) do args = Ast . get_args ( args ) if len == length ( args ) do check_args_length ( others , len ) else :error end end 最后, 让我们来检验一下我们劳动成果. import Corner.Fn fn! sum_from_one_to do 0 -&gt; 0 n -&gt; n + sum_from_one_to . ( n - 1 ) end sum . ( 100 ) # 5050 看起来, 我们成功了. &amp;#x21A9; 详细内容见, https://www.erlang.org/doc/reference_manual/expressions.html#maybe &amp;#x21A9; 见 Wikipedia ≪不动点组合子≫ 词条.","ref":"ch05-new_constructor.html#%E5%8F%AF%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0","title":"第五章 定制新结构 - 可递归的匿名函数","type":"extras"},{"doc":"OTP 平台的卖点之一是对并发的友好支持. 所以 Elixir 对异步的支持是天然的. OTP 平台的并发模型就是很好的异步的例子. 其实在 Javascript 这样的单进程的语言中, 异步代码的执行背后同样是多线程/进程来完成的. Javascript 中异步编程, 虽然引入了多线程/进程, 但是并不破坏 Javascript 的单进程编程模式. Javascript 语言的成功, 我认为和单进程编程模式是非常有关系的. 这个模式极大的减轻了程序员的心智负担. 把 Javascript 中的异步编程的概念, 移植到 Elixir 中, 使得进程之间的交互变得透明, 在使用 Elixir 的时候, 也可以把注意力集中到业务逻辑, 而不是异步交互的细节, 这样不但可以提供生产效率, 也能增强代码的可维护和可理解性.","ref":"ch06-async_programe.html","title":"第六章 异步编程","type":"extras"},{"doc":"Elixir 对异步编程的支持由 Task 模块提供. 但是我很少使用它, Task 不是一个代数结构类型 (Algebraic Structure Type) 1 , 因此无法完成链式操作. Javascipt 中的 Promise 不一样, 它是一个代数结构类型, 可以完成链式操作. 使用 Promise, Javascript 社区成功的解决了回调地狱问题. 因此我希望首先能把这个类型引入到 Elixir 语言中. 我们将要定义的 Promise 模块, 对外提供的接口有 8 个函数, 其中 6 个来源于 Javascript 的 Promise API. 但是这里没有定义 catch 函数. catch 在 Elixir 中是保留字, 不允许用作函数名, 因此这里用 on_error 来代替. 最后的 2 个函数: of/1 和 map(promise,fun/1) 是函子的通用函数. Promise 构造函数 Promise.new((resolve,reject)-&gt;any) Promise 特化的构造函数 Promise.resolve(v) 把 v 转化为已完成的 Promise 结构. Promise 特化的构造函数 Promise.reject(v) 把 v 转化为已拒绝的 Promise 结构. Promise 的转化换函数 Promise.then(promise,fun, error_hanlder\\\\nil) Promise 错误处理函数 Promise.on_error(promise,fun) Promise 解构函数 await(promise) 返回 Promise 中包含的类型 函子构造函数 Promise.of({:resolved|:rejected,v}) 把任意类型的值 v 转化为一个 Promise 结构. 函子通用转化换函数 Promise.map(promise,fun) 我们首先来看看 Promise 的 API. Promise 对象有 5 个状态: 待执行( :pending ), 已完成( :resolved ), 已拒绝( :rejected ) 和出错 ( :error ). 这一点和 Javascript 的 API 不一样. 所以要把 :rejected 拆分成两个状态, 是为了处理错误的方便. Javascript 的异步函数中, 是使用 try...catch 来处理错误的. 在 Elixir 社区, 很少使用 try...catch , 更常规的做法是用标签来标记返回结果. 所以, 这里我们细分了拒绝的状态. 在这里的分类中, :rejected 通过 Promise.rejecte/1 , Promise.of(v, :rejected) 或者动态创建 Promise 时调用 rejecter/1 创建的 Promise . 而错误指的是客户端代码运行过程中抛出错误. 当需要提取 Promise 的值的时候, 调用 Promise.await 函数. Promise.await/1 会等待 Promise 对象从待执行变为已执行的状态. Promise.await/1 返回 {tag, result} . tag 的可能值为 :resolved , :rejected , :error , :stop . 我们的 Promise 是用 GenServer 实现的, :stop 表示 Promise 服务已经终止. 动态构造函数 new(fun) Promsie.new/1 接受一个二元函数 fun , 返回一个待执行状态的 Promise 结构. fun 函数规范为: (resolver,rejecter -&gt; any) . 其中 resolver , rejecter 都是一元函数, 其调用后, 会改变 Promise 的状态. fun 的返回值会被丢弃, 但是如果 fun 抛出了异常, 那么 Promise 的状态将转化为 拒绝状态 . 在 fun 中, 如果调用 resolver/1 或 rejecter/1 , 之前, 没有出错, 那么 Promise 状态将转化为: 完成 或 拒绝 . resolver/1 或 rejecter/1 应该是 fun 执行的最后一个语句, 当其中一个执行后, fun 的后续代码都不会再被执行. Promise.new/1 调用 GenServer.start/2 启动 Promise 服务进程. GenServer.start/2 会使用他的第二个参数来调用回调函数 init/1 . defmodule Corner.Promise do use GenServer @receive_time 60 * 1000 def new ( fun , receive_time \\\\ @receive_time ) when is_function ( fun , 2 ) do { :ok , pid } = GenServer . start ( __MODULE__ , [ fun , self ( ) , receive_time ] ) % __MODULE__ { pid : pid } end def init ( [ fun , pid , receive_time ] ) do state = %{ receive_time : receive_time , sender_ref : make_ref ( ) , state : :pending , sender : pid , timer_ref : nil , result : nil } { :ok , state , { :continue , fun } } end #... end 在初始化函数 init/1 中, 我们只初始化了状态, 但是还没有完成对函数 fun 的执行. 所以, 这里, 我们返回的时一个三元的元组. GenSerrver 接收到 init/1 返回的三元元组后, 会理解执行 handle_continue 回调. def handle_continue ( fun , %{ state : :pending } = state ) do %{ sender_ref : sender_ref } = state run_and_handle_error ( fn _ -&gt; fun . ( &amp; resolver ( sender_ref , &amp;1 ) , &amp; rejecter ( sender_ref , &amp;1 ) ) throw ( { sender_ref , :stop } ) end , state ) end run_and_handle_error/2 执行函数, 捕获错误, 并改变服务进程的状态, 此外, 这个函数还对潜在的内厝泄露问题做了防护. 当客户端疏忽, 创建一个 Promise 后从来左右在通过 await/1 取回结果, Promise 对应的服务进程就会永远运行在系统中. 为了避免这种情况, 当 Promise 处于完成状态之后, 一定时间内, 客户端不发送继续处理的请求, 也不取回结果, 系统将会自动终结, 以完成垃圾回收的工作. 这里默认的时间 由 @receive_time 提供, 当前为 1 分钟. 可以为 Promise.new/2 提供第二个参数来调整这个值. 当接受到 :run 消息后, 取消接受记时. 执行函数 fun . 执行结束后, 重新开始计时. defp run_and_handle_error ( fun , %{ state : tag , result : result } = state ) do if state . timer_ref , do : :timer . cancel ( state . timer_ref ) try do if tag == :error , do : fun . ( { tag , result } ) , else : fun . ( result ) catch kind , error -&gt; catch_error ( kind , error , __STACKTRACE__ , state ) else v -&gt; message = { :timeout , state . sender_ref } timer_ref = Process . send_after ( self ( ) , message , state . receive_time ) %{ state | timer_ref : timer_ref , state : :resolved , result : v } |&gt; noreply ( ) end end catch_error/4 用来处理所有的异常情况. defp catch_error ( :throw , { ref , :stop } , _ , %{ sender_ref : ref } = state ) do send ( state . sender , { :result , { :stop , :done } } ) Process . exit ( self ( ) , :kill ) end defp catch_error ( :throw , { ref , tag , result } , _ , %{ sender_ref : ref } = state ) do message = { :timeout , ref } timer_ref = Process . send_after ( self ( ) , message , state . receive_time ) %{ state | timer_ref : timer_ref , state : tag , result : result } |&gt; noreply ( ) end defp catch_error ( tab , error , stacktrace , %{ sender_ref : ref } = state ) when tab in [ :error , :throw ] do message = { :timeout , ref } timer_ref = Process . send_after ( self ( ) , message , state . receive_time ) result = { error , stacktrace } %{ state | timer_ref : timer_ref , state : :error , result : result } |&gt; noreply ( ) end 前两个分句捕获的是 Promise 服务进程内部抛出的消息. 第三个分句捕获客户端提供的函数 fun 运行过程中产生的错误. 如果 fun 函数中既没有调用 resolver/1 也没有调用 rejecter/1 , 而且没有产生错误, 那么 Promise 服务进程就是抛出 {ref, :stop} , 这样第一个分句就会执行. 结果就是像客户端发送 {:result, {:stop, :done}} 信息后, 立刻终止运行了. 而当 fun 函数中有调用 reserver/1 或 rejecter/1 的时候, 第二个分句会执行. 重新开始了客户端接受计时, 并更新了 Promise 服务器进程的其他状态信息. 数据构造函数 Promise.of(v,tag\\\\:resolved) , Promise.resolve(v) 和 Promise.reject(v) 是三个数据构造函数. 用来把 v 置于 Promise 结构内. Promise.resolve(v) 是 Promise.of(v) 的代理; Promise.rejcet(v) 与 Promise.of(v, :rejected) 效果一样. 这些构造函数和 new/1 的最大差别在于, 这些函数构造的 Promise 服务绝对不会出现死锁, 使用 Promise.new(fun) 构造 Promise 服务的时候, 如果在 fun 既没有调用 resolver/1 , 也没有 rejectoer/1 , 且没有引发异常的化, Promise 进程就会死锁. def of ( v , tag \\\\ :resolved ) do new ( fn resolver , rejecter -&gt; if tag == :resolved do resolver . ( v ) else rejecter . ( v ) end end ) end def resolve ( v ) do of ( v ) end def reject ( v ) do of ( v , :rejected ) end 数据转化函数 map/1 , then/1-2 和 on_error/1 是三个函数转化函数. 其中 then/1-2 和 on_error/1 与 Javascript 的 Promise API 向对应的. 2 . then/1 只处理 :resolved 状态的 Promise, then/2 接受两个转化函数, 第一个处理 :resolved 状态的, 第二个处理 :rejected, :error 状态的. on_error/1 只处理 :rejected 和 :promise 状态的的 Promise. map 是为了配合 Elixir 的函数子句而提供的 API. 也就是说, 无论 Promise 的状态是什么, 都统一有一个函数来处理. 对于 :resolved 和 :rejected 状态的 Promise , map 的处理函数 fun , 接受到的数据就是 Promise 中的数据. 当 Promise 的状态是 :error 的时候, map 的处理函数接受到的是 {:error, {v,[stack]}} . map/1 , then/1-2 和 on_error/1 做的工作是类似的, 分成三个函数, 只是为了客户端调用的方便. 它们只是向 Promise 服务进程发送异步的 {:run,fun1,fun2} 消息. 在本章的开头, 我抱怨 Task 模块不是一个代数结构, 并许诺为 Elixir 种引入 Promise . Promise 是代数结构. 代数结构的关键就是, 数据转化后已经形成对应的结构. 对 Promise 来说, 就是要求所有的转化函数, 必须也返回 Promise 结构. 如此, 才能完成链式调用. 这就是什么, 在 async_send_run/3 的最后返回 Promise 结构的原因. def then ( promise , fun1 , fun2 \\\\ nil ) def then ( % __MODULE__ { } = this , fun1 , fun2 ) when is_function ( fun1 , 1 ) and ( fun2 == nil or is_function ( fun2 , 1 ) ) do async_send_run ( this , fun1 , fun2 ) end def map ( % __MODULE__ { } = this , fun ) when is_function ( fun , 1 ) do async_send_run ( this , fun , fun ) end def on_error ( % __MODULE__ { } = this , fun ) when is_function ( fun , 1 ) do async_send_run ( this , nil , fun ) end defp async_send_run ( % __MODULE__ { pid : pid } = m , fun1 , fun2 ) do if is_pid ( pid ) and Process . alive? ( pid ) do GenServer . cast ( pid , { :run , fun1 , fun2 } ) m else %{ m | state : :stop } end end 异步消息 {:run, fun1,fun2} 的处理函数如下: def handle_cast ( { :run , fun , _ } , %{ state : :resolved } = state ) when is_function ( fun , 1 ) do run_and_handle_error ( fun , state ) end # reject happend but no error_hanlder def handle_cast ( { :run , _fun , nil } , %{ state : tag } = state ) # _fun is not nil when tag != :resolved do noreply ( state ) end # resolved happend but just error_hanler def handle_cast ( { :run , nil , _fun } , %{ state : :resolved } = state ) do noreply ( state ) end def handle_cast ( { :run , _fun , fun } , %{ state : tag } = state ) when tag != :resolved do run_and_handle_error ( fun , state ) end 第一个分句是 :resolved 状态时, fun 转化数据的情形. 第二个分句是 :rejected 状态, 但是并没有提供错误处理函数的情形. 第三个分句是 :res;pved 状态, 但是没有提供数据转化函数的情形. 第四个分句是错误状态的, 使用 fun 处理错误处理状态的情形. await Promise.await/1 函数用来提取 Promise 中记录的值. 本质来说, await/1 是客户端向 Promise 服务进程发送同步请求: {:await, pid} . 但是当 Promise 服务进程已经死掉了, 那么这个函数会返回会返回 {:stop, :done} . def await ( %{ } = this ) do if Process . alive? ( this . pid ) do send ( this . pid , { :await , self ( ) } ) receive do { :result , message } -&gt; message after :infinity -&gt; { :stop , :bad } end else { :stop , :done } end end 最后的提示 最后要注意的是, 这里全部都是函数, 没有宏, 所以 不要使用 import 语句 , 如果使用 import 导入全部函数, 那么会引发 Promise.then/1 与 Kernel.then/2 的命名冲突.","ref":"ch06-async_programe.html#%E6%89%BF%E8%AF%BA-promise","title":"第六章 异步编程 - 承诺(Promise)","type":"extras"},{"doc":"Generater 是 ES6 中引入的新的语法, 让我们可以通过 function* 来创建产生子. 有了这个语法, 在 Javascript 中, 我们就可以产生无限数量的序列了. Elixir 标准库中, 提供了 Stream 模块. 任意的在枚举过程中, 一个接一个产生的可枚举数据类型, 都可以叫做 Stream 3 . 虽说 Stream 模块提供 组合 和 创建 Stream 的函数. 但是从函数的数量上来说, 这个库中提供的, 创建 Stream 的函数只有 3 个, 堪堪占据全部函数的十分之一左右. 对于无限序列, Stream 模块提供的 API 非常方便. 比如让我们产生一个斐波那契数列的 Stream : Stream . unfold ( { 1 , 1 } , fn { a , b } -&gt; { a , { b , a + b } } end ) |&gt; Stream . take ( 10 ) |&gt; Enum . to_list ( ) 但是, 当要求产生特定的序列时, 就开始变得怪异了. 比如, 产生斐波那契数列中, 和小于 10000 的序列. Stream . unfold ( { 1 , 1 , 0 } , fn { a , b , sum } -&gt; if sum &lt; 1000 , do : { a , { a + b , b , sum + a } } , else : nil end ) |&gt; Enum . to_list ( ) 这样的 API, 虽然能完成工作, 但是代码的可读性非常差, 阅读这样的代码, 往往一头雾水. 这是因为控制流由 Stream.unfold/2 控制的. Stream.unfold(acc,fun) 通过判断 fun 返回结果, 来决定为流中产生什么元素或者是否结束序列. 具体的说, 当 fun 返回的是 nil 的时候, 序列结束. 当 fun 返回一个二元元组的时候, 元组的第一个元素作为序列的元素, 第二个元素作为继续调用 fun 的参数. 这就是为什么, Stream.unfold/2 第二个参数的类型为 (acc() -&gt; {element(), acc()} | nil) 的原因. 如果要完成更加复杂的工作, 例如写一个从文件中读取内容的 Stream , 那么就必须使用 Stream.resource/3 . 和 Stream.unfold/2 类似, Stream.resource/3 根据回调函数的返回结果来决定如何产生流的元素和什么时候结束流. 但是 Stream.resource(start_fun,next_fun,end_fun) 因为要调用 end_fun 完成最后的资源清理工作, 所以不能仅要求 next_fun 返回 nil 来表示流结束. next_fun 的类型规范是: (acc() -&gt; {[element()], acc()} | {:halt, acc()}) . 当返回的结果为 {:halt,acc()} 的时候, Stream.resource 调用 end_fun(acc) , 并结束流序列. 但为什么表示需要参数元素的时候, 不能直接返回 {elememt(), acc()} 而必须把要产生的序列放在列表中呢? 这是因为如果返回 {element(),acc()} 那么, Stream.unfold/2 就无法产生一个包含 :halt 的 Stream 序列了. Stream 让我想起了 Javascript 的产生子. 如果 Elixir 提供了产生子, 那么产生子函数结合上面定义的 Promise 就可以写出更加容易读的 Stream.","ref":"ch06-async_programe.html#%E6%B5%81-stream","title":"第六章 异步编程 - 流(Stream)","type":"extras"},{"doc":"定义产生子的宏, 就叫做 defgen 吧. 我们使用 Javascript 产生子函数类似的语法. 在 defgen 上下文中, 可以使用 yield . 表达式 yield a 会等待 迭代子的 next/2 的执行. 待 next/2 执行后, next/2 会得到返回值 {:ok, a} ; 而在产生子内部, yield a 的返回值是 next/2 的第二个参数. 产生子函数中最后一个 yield 语句执行完成后, 再调用 next/2 会返回 :done . 在 Javascript 中, 产生子函数返回的迭代器(记为 g ), 第一次调用 g.next(v) 时, 传给 next 方法的值 v 被丢弃了. 我一直认为这时一个实现的 bug. 现在有机会来自己实现产生子, 我希望, 第一次调用 next(g,v) 传入的值 v 不会被丢弃. 在第一次调用 next/2 的时候, 就可以为 next/2 的第二参数提供任意的值. 那么该如何来实现呢? Elixir 现有的语法中, 如何组合出这样的功能呢? 首先 receive 会暂停一个进程的执行, 直到收到需要的数据, 才接着执行. 所以, 产生子函数, 应该运行在另外的一个进程中, 当 defgen 返回的匿名函数被调用的时候, 产生子函数开始执行, 直到遇到第一个 yield 语句, 停止执行. 等待 next/2 函数发送信号. 当产生子进程, 收到 next/2 的发送的信号后, 表达式 yield a 完成如下工作: 参数 a 发送给 next 把 next 发送过来的数据作为 yeild a 的返回值传递后其他语句 继续执行其他语句, 直到遇到新的 yeild 语句 sequenceDiagram participant 主进程 participant 产生子进程 主进程-&gt;&gt; 产生子进程: 启动产生子进程 g = generater.(...) 产生子进程--&gt;&gt;产生子进程: 运行, 遇到 yield 后,&lt;br&gt;等待主进程发送信号 主进程-&gt;&gt; 产生子进程: v --- next(g,v) 产生子进程-&gt;&gt;主进程: {:ok,b} --- yield b 主进程--&gt;&gt; 产生子进程: ... 产生子进程--&gt;&gt;主进程: ... 主进程 --&gt;&gt; 主进程: 子进程还活着吗? 主进程 -&gt;&gt; 主进程: 没有 defgen name do...end 产生一个匿名函数, 这个匿名函数绑定给了变量 name . 调用匿名函数 name 会启动产生子进程, 并返回一个透明结构. 这个透明结构, 对应于 Javascript 的产生子迭代器, 但是, 在我们这里, 用它来作为客户端与产生子进程通信的信道. 如果我们愿意, 还可以为这个信道/迭代器实现枚举协议, 这样就可以使用 Enum 模块和 for 来处理产生的序列了. defgen fun(a,b) do...end 和 第 5章 ≪定制新结构≫ 的递归匿名函数小节中, 定义的 fn!/2 宏有大量的功能是相同的: 它们都定义匿名函数, 在宏的上下文中, 都可以完成对定义的匿名函数的递归调用. 还帮助我们把这个匿名函数绑定给了变量. 这些共同的功能, 都是如何构造递归调用的匿名函数的, 所以, 可以把通用的代码, 提出到 Ast 辅助模块中. 其中功能完全一样的是对子句参数个数的检查. 我们把这个函数命名为 clauses_arity_check(ast) . 然后就是构建递归匿名函数的工作, 这两个匿名函数几乎是一样的, 所不同的是向递归匿名函数中添加的参数个数不一样, 稍微把定义 fn! 宏时用到的 make_fn/3 做一点修改, 就变成了 make_recursive_fn/4 . def make_recursive_fn ( name , body , correct_args_fun ) do new_body = Enum . map ( body , &amp; clause_handler ( correct_args_fun , name , &amp;1 ) ) { :fn , [ ] , new_body } end defp clause_handler ( correct_args_fun , name_ast = { atom , _ , _ } , { :-&gt; , meta , [ args | body ] } ) do new_body = Macro . postwalk ( body , &amp; correct_recursive_call ( atom , &amp;1 ) ) new_args = if new_body != body do correct_args_fun . ( args , name_ast ) else name_atom = &quot;_ \#{ atom } &quot; |&gt; String . to_atom ( ) correct_args_fun . ( args , { name_atom , [ ] , nil } ) end { :-&gt; , meta , [ new_args | new_body ] } end # ast of `atom.(...args)` -&gt; ast of `atom.(atom, ...args)`. defp correct_recursive_call ( atom , { { :. , m1 , [ { atom , _ , _ } = fun ] } , m2 , args } ) do { { :. , m1 , [ fun ] } , m2 , [ fun | args ] } end defp correct_recursive_call ( _ , ast ) , do : ast 这里, 我们添加的新参数 correct_args_fun . fn!/2 的相关代码, 只要用 Ast 模块中的代码替换原来的相关代码, 就可以完成更新. 在 Ast 模块的帮助下, 我们就可以专心写与 defgen 相关的核心功能了. defmodule Corner.Generater do defstruct ref : nil , pid : nil , async : false alias Corner.Ast defmacro defgen ( name , async \\\\ false , do : block ) do case Ast . clauses_arity_check ( block ) do { :ok , arity } -&gt; tem_fun = { :TEM_fun , [ ] , nil } tem_fun_ast = Ast . make_recursive_fn ( name , block , &amp; make_args / 2 ) params = Macro . generate_arguments ( arity , nil ) quote do unquote ( name ) = fn unquote_splicing ( params ) -&gt; unquote ( tem_fun ) = unquote ( tem_fun_ast ) async = unquote ( async ) ref = make_ref ( ) me = self ( ) fun = fn -&gt; try do unquote ( tem_fun ) . ( unquote ( tem_fun ) , me , ref , unquote_splicing ( params ) ) rescue error -&gt; send ( me , { ref , { :error , error , __STACKTRACE__ } } ) end end pid = spawn ( fun ) struct ( unquote ( __MODULE__ ) , pid : pid , ref : ref , async : unquote ( async ) ) end end |&gt; Macro . postwalk ( &amp; yield_to_send ( async , &amp;1 ) ) # |&gt; tap(&amp;(Macro.to_string(&amp;1) |&gt; IO.puts())) :error -&gt; { := , [ name , { :fn , [ ] , block } ] } end end # other ... end defgen 的定义和 fn! 的定义非常的像, 差别只有两处, 第一处是为递归匿名函数修改参数的函数 make_args/2 定义不同. 产生子函数, 需要两个额外的参数表示产生子进程的 pid 和用来做通信参考的 ref . 这个改动也是非常的简单, 只需要把这两个参数加载函数名之后就可以了. @pid { :pid , [ ] , nil } @ref { :ref , [ ] , nil } defp make_args ( [ { :when , meta , args } ] , fun ) do [ { :when , meta , [ fun , @pid , @ref | args ] } ] end defp make_args ( args , fun ) do [ fun , @pid , @ref | args ] end 第二个改动是 defgen 定义最后的对产生的抽象语法树的遍历. 在本节的开始, 讲到在 defgen 上下文中, 是可以使用关键字 yield 的. 最后的对抽线语法树的遍历, 就是处理关键字 yield . 简单来说, c = yield expression 要被转化为: c = receive do v -&gt; send ( pid , { ref , [ expresssion ] } ) end 对于的代码如下: @doc &quot;&quot;&quot; Transform `c = yield a` &quot;&quot;&quot; &amp;&amp; false defp yield_to_send ( async , { := , m1 , [ left , { :yield , _ , _ } = yield_exp ] } ) do receive_and_send = yield_to_send ( async , yield_exp ) { := , m1 , [ left , receive_and_send ] } end @doc &quot;&quot;&quot; Transform `yield a` to ` receive do v -&gt; send(pid,{ref,[a]}) v end ` &quot;&quot;&quot; &amp;&amp; false defp yield_to_send ( async , { :yield , _meta , exp } ) do pid = @pid ref = @ref return_value = if async do quote do [ Promise . resolve ( unquote ( exp ) ) ] end else quote do unquote ( exp ) end end quote do receive do v -&gt; send ( unquote ( pid ) , { unquote ( ref ) , unquote ( return_value ) } ) v end end end defp yield_to_send ( _ , a ) , do : a 为了更好的理解 defgen 到底如何工作, 打开 defgen 定义中注释掉的调试语句, 看看, defgen 到底是把代码转化成了什么样子: import Corner.Generater defgen my_generater do a , b when a &gt; b -&gt; c = yield ( a ) d = yield ( c + b ) yield ( d ) a , b -&gt; yield ( a ) yield ( b ) end 转后后的代码为: my_generater = fn arg1 , arg2 -&gt; TEM_fun = fn _my_generater , pid , ref , a , b when a &gt; b -&gt; c = receive do v -&gt; send ( pid , { ref , [ a ] } ) v end d = receive do v -&gt; send ( pid , { ref , [ c + b ] } ) v end receive do v -&gt; send ( pid , { ref , [ d ] } ) v end _my_generater , pid , ref , a , b -&gt; receive do v -&gt; send ( pid , { ref , [ a ] } ) v end receive do v -&gt; send ( pid , { ref , [ b ] } ) v end end me = self ( ) ref = make_ref ( ) fun = fn -&gt; try do TEM_fun . ( TEM_fun , me , ref , arg1 , arg2 ) rescue error -&gt; send ( me , { ref , { :error , error , __STACKTRACE__ } } ) end end pid = spawn ( fun ) struct ( Corner.Generater , pid : pid , ref : ref , async : false ) end 代码张开后, 一切非常清楚, 新产生的匿名函数, 调用后会启动一个新进程, 并返回一个产生子结构 Corner.Generater , 它对应于 Javascript 产生子函数返回的迭代子. 所以剩下的代码, 就是为为 Cornder.Generater 定义 next/2 方法了. def next ( % __MODULE__ { } = m , v \\\\ nil ) do if running? ( m ) do %{ pid : pid , ref : ref } = m send ( pid , v ) receive do { ^ ref , [ v ] } -&gt; { :ok , v } { ^ ref , v } -&gt; v end else :done end end running?/1 是一个简单的方法, 用来判定产生子的工作进程是否还或者. 此外, 我们还定义了一个 running?/1 的否定式 done?/1 : def running? ( % __MODULE__ { pid : pid } ) do pid &amp;&amp; Process . alive? ( pid ) end def done? ( % __MODULE__ { } = m ) , do : ! running? ( m ) 如何使用定义好的产生子函数呢? g = my_generater . ( 3 , 2 ) { :ok , 3 } = g |&gt; next ( 1 ) # c is 1 { :ok , 3 } = g |&gt; next ( 4 ) # d is 4 { :ok , 4 } = g |&gt; next ( :any ) true = g |&gt; done? ( ) defgen 对标的 Javascript 产生子函数返回的也是迭代子, 可以使用 for-of 语法完成迭代操作. Elixir 中, 只要实现可枚举协议 (Enumerable), 就可以使用 for 特殊表单了. 那么为产生子结构提供枚举实现吧. Enumerable 定义了 4 个回调函数, 其中最核心的是 reduce(t,acc,fun) . defimpl Enumerable , for : Corner.Generater do alias Corner.Promise alias Corner.Generater , as : G require Corner.Assign , as : Assign def reduce ( % G { } , { :halt , acc } , _fun ) do { :halted , acc } end def reduce ( % G { } = g , { :suspend , acc } , _fun ) do { :suspended , acc , fn _acc -&gt; Process . exit ( g . pid , :kill ) end } end def reduce ( % G { } = g , { :cont , acc } , fun ) do if G . done? ( g ) do { :done , acc } else get_next ( g , acc , fun ) end end #.... end 当 reduce/3 的第一个分句被调用的时候, 表示迭代正常完成了, 所以把最后的结果 acc 返回就好了. 第二个分句被调用, 说明客户端已经得到了结果, 不需要后续的数据了, 因为产生子背后是运行的进程, 当用户不在需要产生子后, 背后的进程就应该终止, 第二个分句返回的元组的第三个元素是一个匿名函数, 它就是完成最后资源清理工作的. 第三个分句是正常的递归过程, 当产生子已经完成了, 返回结果就好了; 如果还没有完成, 那么调用 get_next/3 继续迭代. defp get_next ( % G { } = g , acc , fun ) do case G . next ( g ) do { :ok , v } -&gt; if g . async or is_struct ( v , Promise ) do { _tag , v } = Promise . await ( v ) if is_struct ( v , Promise ) , do : Promise . await ( v ) , else : v else v end |&gt; Assign . to ( new_v ) reduce ( g , fun . ( new_v , acc ) , fun ) #Loop { :error , error , stack } -&gt; { :done , { :error , error : error , stack : stack } } :done -&gt; { :done , acc } end end get_next/3 实际上不过对 Generater.next/1 返回结果分情况处理而已. 如果迭代得结果是一个 Promise 结构, 那么首先从 Promise 中提取结果, 如果不是 Promise 那么直接继续下一轮得迭代. 迭代的工作最后转化为对第 11 行对 reduce/3 的递归调用. Enumerable 除了 reduce/3 外还有 count/1 , member?/2 和 slince/1 . 对产生子来说, 无法不遍历产生子就获得答案; 而遍历生产子, 遍历完成后, 产生子进程就结束了. 无法通过这些函数返回的信息, 进一步来处理产生子的内容了. 所以, 这些函数只是简单的返回 {:error, __MODULE__} . @_ { :_ , [ if_undefined : :apply ] , Elixir } for { fun , args } &lt;- [ count : [ @_ ] , slice : [ @_ ] , member? : [ @_ , @_ ] ] do def unquote ( fun ) ( unquote_splicing ( args ) ) do { :error , __MODULE__ } end end 因为实现了 Enumerable 协议, 所以, 可以是使用 Enum 模块和 for 特殊表单来处理我们的产生子. defgen gen2 do ( ) -&gt; yield ( 1 ) yield ( 2 ) yield ( 3 ) end g = gen2 . ( ) [ 1 , 2 , 3 ] = for v &lt;- g do v end true = done? ( g )","ref":"ch06-async_programe.html#%E4%BA%A7%E7%94%9F%E5%AD%90-generater","title":"第六章 异步编程 - 产生子(Generater)","type":"extras"},{"doc":"Javascript 中还有异步函数的概念. 为了和 Javascript 的异步编程 API 保持一致, 定义异步函数的宏, 命名为 async . 在前面, 我们已经定义 Corner.Promise 模块. async 要做的最主要的工作就是修改抽象语法树, 把抽象语法树的返回值, 封装成 Corner.Promise 结构. async 在其上下文中, 还为 Corner.Promise 命名了别名, 并导入了 Corner.Promise.await/1-2 . 这样, 在其内部就可以方便的处理 Promise 结构了. 当前为函数, 私有函数, 匿名函数以及上一节的产生子提供了异步支持. 首先, 让我们看看函数和私有函数如果完成异步定义的. def/2 和 defp/2 的返回结果 转化为 Promise 结构就好了. return_promsie/1 函数就是完成这工作的. async 中的其他代码, 不过调用 def/2 或 defp/2 宏来创建函数或私有函数而已. defmodule Corner.Async do defmacro async ( { atom , _meta , args } , do : body ) when atom in [ :def , :defp ] do new_body = return_promise ( body ) case atom do :def -&gt; quote do def ( unquote_splicing ( args ) , do : unquote ( new_body ) ) end :defp -&gt; quote do defp ( unquote_splicing ( args ) , do : unquote ( new_body ) ) end end end #... end 那么改如何把一个函数体的返回值转化为 Promise 呢? 或者是, 怎么才能在抽象语法树中识别出返回值呢? 其他函数中, 比如 C 语言家族中, 都是用 return expression 来表示函数的返回值, 因此可以从抽象语法树中识别出来, 但是 Elixir 中不是这样的, 在抽象语法树中, 是无法识别出返回值的. 不过在 Elixir 中, 可以使用 try 特殊表单来获得一个代码块的返回值. return_promise/1 就是这样做的. defp return_promise ( ast ) do quote do alias Corner.Promise import Corner.Promise , only : [ await : 2 , await : 1 ] try do unquote ( ast ) rescue err -&gt; Promise . reject ( { err , __STACKTRACE__ } ) else v -&gt; if is_struct ( v , Promise ) do v else Promise . reject ( v ) end end end end 现在让我们看看如何为匿名函数提供异步支持. defmacro async ( { :fn , meta , ast } ) do new_ast = arrow_return_promise ( ast ) { :fn , meta , new_ast } end defp arrow_return_promise ( abs ) do walker = fn { :-&gt; , meta , [ args , body ] } -&gt; new_body = return_promise ( body ) { :-&gt; , meta , [ args , new_body ] } ast -&gt; ast end Macro . postwalk ( abs , walker ) end 匿名函数使用 fn 特殊表达来定义, 它和 def/2 不一样, 需要自己提取分句的每个分句的函数体. 在 arrow_return_promise 中定义的匿名函数 walker 就是完成这个工作的. 最后是对 defgen 宏的支持. defmacro async ( { :defgen , _ , [ fun_name ] } , do : block ) do new_block = arrow_return_promise ( block ) quote do import Corner.Generater alias Corner.Promise import Corner.Promise , only : [ await : 1 ] defgen ( unquote ( fun_name ) , true , do : unquote ( new_block ) ) end end defgen 的异步支持, 非常像 fn 的异步支持. 但是因为 defgen 是我们自己定义的宏, 所以, 我们需要首先向用户的环境中导入 Corner.Generater.defgen/2-3 和 Corner.Promise.await/1 . 我们还为 Corner.Promise 引入了别名, 这样, 在 defgen 的上下文中, 我就可以使用较为紧凑的 Promise 来写代码了. 最后, 检验时刻到, 我们可以像下面的代码那样来使用 async 来写代码了: import Corner.Async async defgen ( fun ) do a , b -&gt; yield ( Promise . resolve ( 3 ) ) yield ( a ) yield ( b ) end is_function ( fun , 2 ) #true for v &lt;- fun . ( 2 , 1 ) do v end #[3,2,1] &amp;#x21A9; 代数结构类型是一个相对抽象的概念. 要理解这个概念, 首先必须理解代数结构这个数学概念. 按照我的理解, 代数结构是说, 当操作符 $f$ 作用到数据集 $S$ 上后, 得到的结果还在 $S$ 中, 这样如果把数据集合 $S$ 看作一个空间, 输出和输出在这个空间中就形成了一定的结构. 代数结构最重要的概念是闭合性, 运算的闭合性, 使得编程可以使用链式操作. 操作符在数据集上具有闭合性, 数学上讲, 操作符在数据集上形成了闭包. 编程中也有闭包的概念, 这两个概念使用的是同一个英文单词, 但是意义不一样. 举个例子, $+$ 与整数集合 $N$, 整数加上整数得到的结果还是整数, 操作的输入和输出具有封闭性. 而 $\\div$ 与整数集合 $N$ 不具有封闭性, 因为整数除以整数不能保证得到的还是整数. 甚至 $\\div$ 与实数集合 $R$ 也不能构成闭包, 因为 0 是不能作为被除数的. 具有运算封闭性, 在数学上就构成了类群. &amp;#x21A9; 见 MDN Promise 参考页面 &amp;#x21A9; 见 Stream 模块文档","ref":"ch06-async_programe.html#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0-async","title":"第六章 异步编程 - 异步函数(async)","type":"extras"},{"doc":"","ref":"ch07-pipe.html","title":"第七章 管道操作符","type":"extras"},{"doc":"在函数式编程的社区中, 函数组合非常的重要. 组合函数是一个高阶函数, 它接受多个函数, 返回一个新的函数, 例如 fun=compose(f,g,k) , 那么 fun(x,y,z) 就等价于 f(g(k(x,y,z))) . 为了与思维的习惯一致, 人们还定义了反序的组合函数, 叫做 pipe 函数. 在 Elixir 中没有内置的 compose 或 pipe 函数, 但是内置了管道操作符 |&gt; . 我一度认为管道操作符 |&gt; 就是 Elixir 的 pipe 函数. 但是这是一个幻觉. 管道操作符 |&gt; 更像 shell 的管道而不是函数式编程中的 pipe 函数. 至少 Elixir 编译器不会为我们做函数组合的优化. 函数式编程中, 很多语言, 会对函子的 map 操作做优化. 比如: [1,2,3].map(f).map(f2) 编译器会优化为 [1,2,3].map(compse(f,f2)) , 以提高程序的执行效率. 在 Elixir 中, 相应的代码是这样的: [1,2,3] |&gt; Enum.map(f)|&gt; Enum.map(f2) . 这样的代码, 如果有优化的, 最后应该等价于 [1,2,3]|&gt; Enum.map(&amp;f2.(f.(&amp;1))) . 但是实际的情况并不是这样的. 例如下面的代码: fun1 = fn v -&gt; v |&gt; IO . inspect ( label : &quot;+1&quot; ) |&gt; then ( &amp; ( &amp;1 + 1 ) ) end fun2 = fn v -&gt; v |&gt; IO . inspect ( label : &quot;-1&quot; ) |&gt; then ( &amp; ( &amp;1 - 1 ) ) end range = 1 .. 5 range |&gt; Enum . map ( fun1 ) |&gt; Enum . map ( fun2 ) |&gt; IO . inspect ( label : &quot;result of map chain&quot; ) 控制台的输出为: + 1 : 1 + 1 : 2 + 1 : 3 + 1 : 4 + 1 : 5 - 1 : 2 - 1 : 3 - 1 : 4 - 1 : 5 - 1 : 6 result of map chain : [ 1 , 2 , 3 , 4 , 5 ] 从控制台的输出中, 可以观察到, 所有的 +1 输出结束后, 才开始 -1 的输出. 管道操作符 |&gt; 连接起来的多个 Enum.map 并没有被合并为一个. 只有对 fun1 的迭代全部完成后, 对 fun2 调用才开始执行. 但如果把 fun2 和 fun1 组合成一个新的函数, 像下面的代码这样: range |&gt; Enum . map ( &amp; fun2 . ( fun1 . ( &amp;1 ) ) ) |&gt; IO . inspect ( label : &quot;result of compose&quot; ) 那么控制台的输出应该是 +1 -1 交替出现. 因此可见, Elixir 内置的管道操作符 |&gt; 不是函数式编程的 pipe 函数. 可是手动的组合函数总是比较的麻烦, 写一个函数来帮助我们完成函数的组合也不是难事, 但是 Elixir 社区中, 因为命名函数不是一等公民, 所以函数组合的语法并不常用. 大家最习惯的其实还是使用管道操作符 |&gt; , 所以如果管道操作符 |&gt; 能对 Enum.map 做优化, 那么应该能提升代码的运行效率. 非常幸运, 管道操作符 |&gt; 在 Elixir 中并不是特殊表单, 因此可以定义自己的管道操作符 |&gt; . Elixir 源码中定义的管道操作符 |&gt; 可以作为我们工作的起点. 我们可以在 kernel.ex 中发现其定义: defmacro left |&gt; right do [ { h , _ } | t ] = Macro . unpipe ( { :|&gt; , [ ] , [ left , right ] } ) fun = fn { x , pos } , acc -&gt; Macro . pipe ( acc , x , pos ) end :lists . foldl ( fun , h , t ) end 不用特别的熟悉 Elixir 的宏, 只需要理解最后的 :lists.foldl/3 , 我们就能大概理解管道操作符 |&gt; 的原理了, 其实与在 Javascript 中定义 pipe 函数的算法一样. 上面的代码中, t 就是管道操作符 |&gt; 的所有的右操作数 (函数) 组成的列表, 也就是所有待组合的 函数调用 的列表. 我们自己定义的管道操作符 |&gt; 所作的优化, 本质就是对函数调用列表 t 合并同类项. 具体来说就是, 识别连续相邻的 Enum.map(f1) , Enum.map(f2) ..., Enum.map(fn) , 并把他们合并成为一个 Enum.map(composed_fun) . 首先我们定义一个 Optimizer 行为, 这个这个行为只有一个函数, 就是优化函数: optimize(t,list) . 所以如此, 是因为, 虽然现在我们只是完成 Enum.map/2 相关的实现, 但是对于管道操作符 |&gt; 的右操作数, 如果将来发现, 除 Enum.map/2 组成的链条外, 还有其他的情形可以优化, 那么我们只需要对新情形实现 Optimizer 行为就好了. 定义 Optimizer 行为, 让我们的代码更容易组织.","ref":"ch07-pipe.html#%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8D%E6%98%AF%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0","title":"第七章 管道操作符 - 管道操作符不是组合函数","type":"extras"},{"doc":"defmodule Optimizer do @callback optimize ( t :: any , ast_list :: List . t ( ) ) :: List . t ( ) defmacro __using__ ( _opts ) do quote do import Kernel , except : [ |&gt; : 2 ] import Optimizer.Pipe , only : [ |&gt; : 2 ] end end end 第 2 行我们定义了优化器的接口. 而 __using__/1 的定义可以看作是优化器对外提供的 API. 优化器的使用者, 只需要 use Optimizer 就可以了使用优化器了, 不用关心优化器内部的实现.","ref":"ch07-pipe.html#%E4%BC%98%E5%8C%96%E5%99%A8%E5%8D%8F%E8%AE%AE","title":"第七章 管道操作符 - 优化器协议","type":"extras"},{"doc":"现在让我们来定义针对 Enum.map/2 的优化. 我把有关优化的代码都放在 optimizer 目录下, 为 Enum.map/2 做优化的模块, 命名为 Optimizer.EnumMap . 像我们上面分析的那样, Optimizer.EnumMap 要做的事情, 就是把由管道操作符 |&gt; , 链接起来的连续的多个 Enum.map(fun) 表达式合并为一个 Enum.map(funs) . 这里由 reduce_map/1 函数完成具体的工作. reduce_map 函数分两步完成工作: 对所有函数调用表达式进行分组, 连续的 Enum.map(fun) 表达式分为一组, 其他的表达式, 单独为一组. 由 group_function_calls/1 完成. 把分组后的 Enum.map(fun) 表达式抽象语法树, 合并为一个 Enum.map(composed_fun) . 由 tranceform_group/1 . defmodule Corner.Optimizer.EnumMap do alias Corner.Optimizer @behaviour Optimizer @impl Optimizer def optimize ( __MODULE__ , list ) do reduce_map ( list ) end defp reduce_map ( ast_list ) do ast_list |&gt; group_function_calls ( ) |&gt; Enum . map ( &amp; tranceform_group / 1 ) end #... end group_function_calls 就是对函数调用表达式的抽象语法树列表做迭代. 对于函数调用 fun_call , 如果它是 Enum.map(fun) 的抽象语法树, 那么它应该就是被分组的内容, 首先把它使用列表包裹, 以表示这是一个分组, 然后把列表添加到汇聚结果 acc 的头部. 如果它不是 Enum.map(fun) , 那么直接加入到 acc 头部就好了. 当汇聚结果 acc 其中由内容了, 待检查的 fun 符合要求, 而且汇聚结果的最后一个元素是一个列表话, 那么我们需要继续向列表中添加新的元素. 如果汇聚结果的最后一个元素不是一个列表. 那么需要向汇聚结果中添加新的分组列表. 当 fun 不是 Enum.map(fun) 的时候, 只要把 fun 添加到汇聚结果中, 就可以了. 这样操作后, 函数调用的顺序全部颠倒了, 所以使用 Enum.reverse/1 对函数调用列表完成重排. defp group_function_calls ( fun_call_list ) do for fun_call &lt;- fun_call_list , reduce : [ ] do [ ] = acc -&gt; if is_map_call ( fun_call ) do [ [ fun_call ] | acc ] else [ fun_call | acc ] end [ ele | rest ] = acc -&gt; fun_is_map? = is_map_call ( fun_call ) cond do fun_is_map? and is_list ( ele ) -&gt; [ [ fun_call | ele ] | rest ] fun_is_map? -&gt; [ [ fun_call ] | acc ] true -&gt; [ fun_call | acc ] end end |&gt; Enum . reverse ( ) end is_map_call/1 用来检查抽象语法树是否对应表达式 Enum.map(fun) . defp is_map_call ( { { { :. , _ , [ { :__aliases__ , _ , [ :Enum ] } , :map ] } , _ , _ } , 0 } ) , do : true defp is_map_call ( _ ) , do : false tranceform_group/1 把分组的 Enum.map(fun) 合并为一个 Enum.map(composed_fun) . 这也是分三步完成, 第一步提取 Enum.map(fun) 表达式中的 fun . 这由 get_fun/1 函数完成. 第二个步组合提取函数. 最后一步把组合函数 composed_fun 转为为 Enum.map(composed_fun) . 其他非 Enum.map(fun) 的函数调用, 不做处理直接返回. defp tranceform_group ( map_calls ) when is_list ( map_calls ) do composed_fun = map_calls |&gt; Enum . map ( &amp; get_fun / 1 ) |&gt; compose ( ) { { { :. , [ ] , [ { :__aliases__ , [ ] , [ :Enum ] } , :map ] } , [ ] , [ composed_fun ] } , 0 } end defp tranceform_group ( other_ast ) , do : other_ast get_fun/1 函数非常简单, 我们只是通过模式匹配来提取我们需要的就可以了. defp get_fun ( { { { :. , _ , [ { :__aliases__ , [ ] , [ :Enum ] } , :map ] } , _ , [ fun ] } , 0 } ) do fun end 最后是组合函数. compose/1-2 . defp compose ( list , acc \\\\ nil ) defp compose ( [ fun | funs ] , nil ) do acc = quote do unquote ( fun ) . ( ) end compose ( funs , acc ) end defp compose ( [ fun | funs ] , acc ) do acc = quote do unquote ( fun ) . ( ) |&gt; unquote ( acc ) end compose ( funs , acc ) end defp compose ( [ ] , acc ) do quote do fn v -&gt; v |&gt; unquote ( acc ) end end end 分组后函数的列表的顺序与它们在管道操作符中出现的顺序已经完成了反转. 对与列表 [fun_n, ... fun_2, fun_1] . 这里每一个函数都是一元函数. 最终要转化为 fn v -&gt; v |&gt; fun_1.() |&gt; fun_2.() |&gt; ... |&gt; fun_n.() end . 第一个分句完成, 最后 fun_n.() , 第二个分句完成 fun_1.() |&gt; fun_2.() ..|&gt; fun_n.() . 而最后一个数据完成 fn -&gt; v |&gt; ... end 的操作. 前面说过, 要自定义管道操作符 |&gt; , 现在是兑现的时候了.","ref":"ch07-pipe.html#%E5%AF%B9-enum-map-%E4%BC%98%E5%8C%96","title":"第七章 管道操作符 - 对 Enum.map 优化","type":"extras"},{"doc":"defmodule Corner.Optimizer.Pipe do import Kernel , except : [ |&gt; : 2 ] alias Corner.Optimizer . { EnumMap } @optimizer [ EnumMap ] defmacro left |&gt; right do [ { h , _ } | t ] = Macro . unpipe ( { :|&gt; , [ ] , [ left , right ] } ) fun = fn { x , pos } , acc -&gt; Macro . pipe ( acc , x , pos ) end t = Enum . reduce ( @optimizer , t , &amp; apply ( &amp;1 , :optimize , [ &amp;1 , &amp;2 ] ) ) :lists . foldl ( fun , h , t ) end end 当定义了更多的优化器的时候, 只需要修改上面代码的第 3, 4 两行代码, 就可以了. 上面的代码, 大部分都是照搬 Elixir 的 Kernel 模块中管道操作符 |&gt; 的定义, 只是增加了第 12 行的内容, 而它做的工作, 依次的调用我们定义的优化器. 现在来看看, 代码是不能按照我们的预期工作: use Corner.Optimizer add_one = fn v -&gt; IO . puts ( &quot;+1&quot; ) v + 1 end sub_one = fn v -&gt; IO . puts ( &quot;-1&quot; ) v - 1 end 1 .. 5 |&gt; Enum . map ( add_one ) |&gt; Enum . map ( sub_one ) |&gt; IO . inspect ( label : &quot;after optimizer&quot; ) 控制台中输出为: + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 after optimizer : [ 1 , 2 , 3 , 4 , 5 ]","ref":"ch07-pipe.html#%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C%E7%AC%A6","title":"第七章 管道操作符 - 管道操作符","type":"extras"},{"doc":"看起来, 功能测试通过了, 但是我们毕竟是做优化的, 我们的代码真的能提升代码的执行效率吗? 这还需要实际测试的. defmodule OptimizeBenchmarkTest do use ExUnit.Case , async : true @range 1 .. 1000 def fun1 ( up \\\\ 10 ) do for _ &lt;- 1 .. up do @range |&gt; Enum . map ( &amp; ( &amp;1 + 1 ) ) |&gt; Enum . map ( &amp; ( &amp;1 - 1 ) ) end end def fun2 ( up \\\\ 10 ) do use Corner.Optimizer for _ &lt;- 1 .. up do @range |&gt; Enum . map ( &amp; ( &amp;1 + 1 ) ) |&gt; Enum . map ( &amp; ( &amp;1 - 1 ) ) end end test &quot;Optimizer of |&gt; for Enum.map&quot; do arg = [ 10000 ] task1 = Task . async ( fn -&gt; :timer . tc ( &amp; fun1 / 1 , arg ) end ) task2 = Task . async ( fn -&gt; :timer . tc ( &amp; fun2 / 1 , arg ) end ) [ { t , v } , { t1 , v1 } ] = Task . await_many ( [ task1 , task2 ] , 60_000 ) IO . puts ( &quot;speed up \#{ ( t - t1 ) / t1 * 100 } %.&quot; ) assert v == v1 end end 最初, 我是使用 LiveBoook 来探索 Elixir 的. 在 LiveBook 中, 运行这个测试的后, 其中有一次, 代码的输出是这样的: speed up -1.5641347109939043%. 这就尴尬了😒. 优化后的代码不是提速了, 反而变慢了 1.5 个百分点. 可是为什么会这样啊? 这是因为 LiveBook 代码 Cell 本质上是解释执行的, 就像不能以代码在 IEx 中的运行时间来衡量代码的效率一样, 我们也不能用 LiveBook 的 Cell 中代码的执行时间来衡量代码的效率. 这个优化的实现, 其实并不是那么的复杂, 为什么 Elixir 编译器不这样做呢? 这里有两个原因. 第一原因, 就是 Elixir 标准库中有 Stream 模块, 文档中, 明确提到 Stream.map 会组合函数的. 也就是说, Elixir 是以 Stream.map 来完成函数组合的工作的. 对于上面的组合代码, 使用 Stream 替换了 Enum , 就获得了相同的结果. 1 .. 5 |&gt; Stream . map ( add_one ) |&gt; Stream . map ( sub_one ) |&gt; Enum . to_list ( ) |&gt; IO . inspect ( label : &quot;result of map chain&quot; ) 所以, 当我看到测试在 LiveBook 效率没有提升, 甚至还下降的时候, 我一度怀疑, 自己是不是解决了一个错误的问题? 答案是: 不是的. 这个工作依旧是有意义的. 就像上面展示的那样, 理论上绝对不有应该效率下降的优化后的代码, 测试的时候, 有时居然会下降 1.5%. 那么 Stream 版本呢? 会比我们的的代码效率更高吗? 总是优与多个 Enum.map 串联吗? defmodule BenchmarkStreamTest do use ExUnit.Case , async : true @range 1 .. 1000 def fun1 ( up \\\\ 10 ) do for _ &lt;- 1 .. up do @range |&gt; Enum . map ( &amp; ( &amp;1 + 1 ) ) |&gt; Enum . map ( &amp; ( &amp;1 - 1 ) ) end end def fun2 ( up \\\\ 10 ) do for _ &lt;- 1 .. up do @range |&gt; Stream . map ( &amp; ( &amp;1 + 1 ) ) |&gt; Stream . map ( &amp; ( &amp;1 - 1 ) ) |&gt; Enum . to_list ( ) end end test &quot;Enum.map vs Stream.map&quot; do arg = [ 10000 ] task1 = Task . async ( fn -&gt; :timer . tc ( &amp; fun1 / 1 , arg ) end ) task2 = Task . async ( fn -&gt; :timer . tc ( &amp; fun2 / 1 , arg ) end ) [ { t , v } , { t1 , v1 } ] = Task . await_many ( [ task1 , task2 ] , 60_000 ) IO . puts ( &quot;speed up \#{ ( t - t1 ) / t * 100 } %.&quot; ) assert v == v1 end end 这次在 LiveBook 中运行的结果更加糟糕, 和 Enum.map 相比, Stream.map 版本的代码效率下降了 100% 还多. 1%~2% 的效率差异我们还能解释为代码执行过程中偶然因素带来的, 但 Stream.map 和 Enum.map 的巨大差异绝对不能归结为偶然. Stream.map 虽然完成了的函数的组合, 但是却并没有提升效率. Elixir 的 Enum.map 不组合函数的第二个原因是, Elixir 不是一个纯的函数编程语言. 传递给 Enum.map 的函数不保证没有副作用的. 而理论上来说, 只有当传递给 Enum.map 的函数是纯函数的时候, 才可以组合函数. 但是要在编译时判断一个函数中是否有副作用, 这基本上做不到, 所以 Elixir 标准库中的管道操作符 |&gt; 并不对 Enum.map 做函数的组合. 我们的优化器, 忽略了函数中的副作用而强行对函数做了组合. 把优化器做测试的代码, 保存到文件中, 使用 mix test 命令来重新测试, 这次发现, 使用优化器的代码, 效率有了 30%~40% 的效率提升. 手动组合功能一样的函数, 其效率和使用这里定义的优化器的一样. 在不增加工作量的情况下, 效率提升 30%~40%, 从这个角度来看, 这个工作还是算有意义吧?","ref":"ch07-pipe.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95","title":"第七章 管道操作符 - 基准测试","type":"extras"},{"doc":"","ref":"ch08-error_handle.html","title":"第八章 错误处理","type":"extras"},{"doc":"Erlang 中把错误分成 4 类. 编译时错误, 也就是语法错误 逻辑错误, 漏洞或者更常见的是说法 bug. 运行时错误, 运行时产生的错误 产生的错误, 也就是写代码中故意产生的错误. 前两种错误, 发生在语言之外的, 在代码层面没法对其做处理. 后两种错误又叫做异常. 代码层面能处理的其实都是异常. 异常以引发异常的机制和函数不同, 又可以分成三类: 错误( :error ), 运行时的错误, 例如 1 + :a 或者有 :erlang.error() 引发的. 退出( :exit ), 由 :erlang.exit/1-2-3 引发, 用来使进程退出执行. 抛出( :throw ), 由 :erlang.throw 引发. Erlang 中用 catch 关键字来处理这些错误. 而 Elixir 中, 除了 catch 外, 还从 Ruby 中引入了新的 rescue 保留字. 那么自然的就有一个问题, catch 和 rescue 如何分工呢? 按照 Elixir 文档 的说法, rescue 用来处理异常, 而 catch 可以用来捕获 throw 值和 exit 信号. (The rescue clause is used to handle exceptions while the catch clause can be used to catch thrown values and exits.) 但是什么是异常呢? Elixir文档中并没有明确的给出定义, 但是 Erlang 文档 中有清晰的解释. 如果 Elixir 中的异常和 Erlang 中的是一个概念话, 那么我对 rescue 和 catch 的分工的理解, 就成了: rescue 能处理所有三种类型的异常, 而 catch 只能 处理 throw 和 exit 引发的异常. 但是 这样的理解是错误的 . 例如下面的代码, rescue 在这里并没有把我们从 throw 引发的错误中拯救出来. try do throw ( 1 ) rescue v -&gt; IO . inspect ( v ) end 使用 Erlang 对异常的分类, rescue 实际上只能处理错误 error 类型错误. Elixir 文档中也的确有提到 rescue 对 Erlang 的错误的处理, 所有的 Erlang 错误都被转化为 ErlangError . 这可以看作是一种暗示: Elixir 中异常对应于 Erlang 的 :error 类型的错误. 理解了这一点, 对于 catch 的分工描述才能有正确的理解. 在 Erlang 中, 本来就是用 try...catch 来处理所有错误的; Elixir 中依旧可以使用 catch 来处理全部的三种类型的错误, 也就是说, 在 Elixir 中 catch 并没有退化. 而 Elixir 中增加的保留字 resuce , 只是针对 :error 类型的处理而提供的更优雅便捷的语法. 结论 : 我起初的理解刚好搞反了, catch 是全能的错误处理者, 而 rescue 才是挑剔者 .","ref":"ch08-error_handle.html#%E9%94%99%E8%AF%AF%E5%88%86%E7%B1%BB","title":"第八章 错误处理 - 错误分类","type":"extras"},{"doc":"上一节我们讨论了, Elixir 中的 rescue 的使用场景, 现在我们来讨论如何使用它. 比如让我们使用 try...rescue 来来模拟 Erlang 的 maybe 特性. defmodule Corner.Maybe do defmacro maybe ( do : block ) do quote do try do unquote ( block ) rescue e in [ MatchError ] -&gt; e . term # %MatchError{term: term} -&gt; term e -&gt; reraise e , __STACKTRACE__ end end end end 不难推测, 还可以在第 7 行的列表中加入更多的错误类型. 如果不管异常的名字叫什么都要处理的话, 就可以向第 9 行那样处理. 但是像第 7 行中对错误的处理, 处理的结果, 只是从错误结构中提取相应的异常消息, 那么我忍不住, 就想使用注释掉的第 8 行那样的代码. 但是第 8 行的代码是语法错误的. rescue 子句中, -&gt; 左侧的模式匹配, 只基于异常的名字来处理 1 . 这样的处理有些奇怪啊! 如果允许第 8 行那样写代码, 代码不是显的更整洁吗? 为什么 Elixir 对 rescue 的匹配匹配语法要限制只能匹配错误名字呢? 现在还没有答案, 但是不要这一个问题阻拦了我们探索的脚步. 也许后面的探索中, 答案自然就会浮出水面呢!","ref":"ch08-error_handle.html#%E6%80%8E%E4%B9%88%E6%8B%AF%E6%95%91","title":"第八章 错误处理 - 怎么拯救","type":"extras"},{"doc":"通过上面对 rescue 和 catch 的分工的讨论, 我们知道 catch 是三项全能. 现在让我们来看看 catch 的表现. 抛接游戏 Elixir 中 throw 可以抛出任意的数据类型 (就像 C++ 中那样), 而 catch 可以原封不动的接住所有被抛出的东西. Elixir 中没有 return 语句, 使用 throw catch 可以模拟它. 例如类似于下面的 Javascript 代码: function fun ( a ) { if ( a &gt; 3 ) return &quot;a &gt; 3&quot; if ( a &lt; 0 ) return &quot;a &gt; 0&quot; if ( a == 2 ) return a return a + 1 } 对应的 Elixir 代码可以这样来写: def fun ( a ) do if a &gt; 3 , do : throw &quot;a &gt; 3&quot; if a &lt; 0 , do : throw &quot;a &lt; 0&quot; if a == 2 , do : throw a catch v -&gt; v else _ -&gt; a + 1 end 信号捕获 在 Erlang 中, catch 实际上更加类似于 Linux 进程间通信机制中的信号陷阱. 也就是说, catch 捕获的实际上是信号, Elixir 信号比 Linux 的信号通信高级的地方在于: Linux 的信号种类是固定的; 而 Elixir 中 exit 可以发送的信号, 是由标签表示的 类型 与 附加消息 共同组成的. 其中标签个数可以认为是固定的, 但是附加信息的数量是无限的. catch 子句中完整的匹配语法是这样的: catch kind , message when guard -&gt; ... 也就是说, catch 子句中 -&gt; 左侧, 应该是一个二元的参数列表形式. when 子句是可以省略的, 就像其他环境中的 when 那样. 而 catch v -&gt; ... 是 catch :throw, v -&gt; ... 的语法糖, 或者按照 Erlang 文档的说法, catch 的默认类型是 :throw . 我们用代码来检验以下我们的理解是否正确: 1 = try do throw ( 1 ) catch :throw , v -&gt; v end 2.0 = try do throw ( 2.0 ) catch v -&gt; v end 对 throw 产生的错误来说, catch v -&gt;.. 和 catch :throw, v -&gt; ... 一样. 这证实了 catch v -&gt; ... 只是 catch :throw, v -&gt; ... 的语法糖的结论. 2 = try do exit ( 2 ) catch :exit , v -&gt; v end 对 exit 引发的错误, 可以使用 catch :exit, v -&gt; 捕获. 3 = try do :erlang . error ( 3 ) catch :error , v -&gt; v end :reason = try do :erlang . error ( :reason , [ 2 ] ) catch :error , reason -&gt; reason end 对Erlang 的 :erlang.error/1-2-3 产生的错误, catch 总是能捕获其原因(代码中的变量 reason ), 其值就是 :erlang.error 的第一个参数. :badarith = try do 1 / 0 catch :error , v -&gt; v end { :badmatch , :error } = try do :ok = :error catch # not work # :error, %MatchError{}=v -&gt; v # now `reason` is not a Error, but a tuple :error , reason -&gt; reason end 使用 catch :error, reason -&gt; ... 来捕获运行时错误, reason 绑定错误发生的原因. 不同的错误, 产生的原因数据类型不统一. 比如算术计算引发的错误, 是用一个原子 :badarith 表示. 而匹配错误, 返回的是一个二元元组, 元组的第一个元素是原子 :badmatch , 第二个元素则是匹配操作符 = 的右操作数. :reason = try do exit ( :reason ) catch :exit , v -&gt; v end { :kill , 1 } = try do exit ( { :kill , 1 } ) catch :exit , v -&gt; v end 对于 exit 产生的错误, 无论传递给 exit/1 的是什么, catch :exit, v -&gt; 语句中 v 都能绑定它的值. % MatchError { } = try do raise MatchError catch :error , % MatchError { } = v -&gt; v end % MatchError { } = try do raise MatchError , term : { :ok , 1 } rescue v in MatchError -&gt; v end catch 和 rescue 都可以用来处理 raise 引发的错误. catch 的语法可以更方便的使用匹配语法, rescue 只能匹配模块名. 但是, 注意对比运行时产生的匹配错误与使用 raise 产生的匹配错误之间的微妙区别. 运行时产生的匹配错误, 使用 catch :error, v -&gt; ... 语句时, v 绑定的是一个二元元组. 而 rasie 产生的错误, 表达式 catch :error, v -&gt;... 中 v 绑定的是 %MatchError{} 异常结构.","ref":"ch08-error_handle.html#%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7","title":"第八章 错误处理 - 如何捕获","type":"extras"},{"doc":"在探索 catch 对异常的捕获是, 我们发现 catch 对运行时错误和 raise 产生的错误有区分, 这使得 catch 对错误来源敏感, 这就导致了由不同的机制 ( error 或 raise ) 产生的相同异常 ( MatchError ), 必须使用不一致的语法来处理. Elixir 中用 rescue 来统一处理异常, 而不再区分它们的来源. 可是 rescue 子句中的匹配的语法, 只支持对异常名匹配. 这样在需要提取异常消息的时候, 代码就不够简洁了. 好在变量可以匹配任意给定的值, 这个匹配规则没有打破. 所以 rescue v -&gt; 可以用来匹配任意的 :error 类型的异常. rescue v -&gt; 表达式中, 当变量 v 绑定异常结构后, 在 -&gt; 的右侧, 就可以使用结构的匹配语法来对异常做匹配了. 也就是说, 对于异常, 我们可以使用下面的代码来完成匹配: try do do_block_code rescue v -&gt; case v do % ErrorName { field : field_v } -&gt; field_v ... end ... end 我们可以定义自己的语法糖, 让 rescue 子句中, 可以使用更强大的模式匹配语法. try 是 Elixir 特殊表单, 社区对其语法有一致的预期, 为了不迷惑, 不熟悉我们的库的程序员, 我们不使用 try 来作为我们的宏的名字. 这个将要定义的宏是要增强 rescue 的匹配功能, 这里我们使用和 fn! 一样的命名惯例, 把我们的宏命名为 try! . defmodule Corner.Try do defmacro try! ( asts ) do Macro . postwalk ( asts , &amp; walker / 1 ) |&gt; make_try ( ) |&gt; tap ( &amp; ( Macro . to_string ( &amp;1 ) |&gt; IO . puts ( ) ) ) end #... end 我们只是修改 rescue 分句, 所以, 遍历抽象语法树, 找到 resuce 分句相关的部分, 修改抽象语法树, 这就是 try!/1 最重要的工作. 这个工作有 walker/1 函数完成. walker 函数使用模式匹配, 识别出 rescue 分句, 然后调整抽象语法树对应的部分, 使得原来的 rescue % Error_1 { } -&gt; ... % Error_2 { } -&gt; ... ... % Error_n { } -&gt; ... 转化为: rescue v -&gt; case v do % Error_1 { } -&gt; ... % Error_2 { } -&gt; ... ... % Error_n { } -&gt; ... end 对应的代码, 非常简单: defp walker ( { :rescue , rescue_block } ) do { :rescue , [ { :-&gt; , [ ] , [ [ { :v , [ ] , nil } ] , { :case , [ ] , [ { :v , [ ] , nil } , [ do : rescue_block ] ] } ] } ] } end defp walker ( ast ) , do : ast 最后, try! 还是需要使用特殊表达 try 来完成工作, 所以最后我们用 make_try/1 来完成对 try 特殊表单的调用表达式. defp make_try ( block ) do { :try , [ ] , [ block ] } end 最后使用我们新定义的 super_try 来重构我们的 maybe 宏. defmodule Corner.Maybe do defmacro maybe ( do : block ) do quote do import Corner.Super , only : [ try! : 1 ] try! do unquote ( block ) rescue % MatchError { term : term } -&gt; term end end end defmacro maybe ( do : block , else : else_part ) do quote do import Corner.Super , only : [ try! : 1 ] try! do unquote ( block ) rescue % MatchError { term : term } -&gt; term else unquote ( else_part ) end end end end 测试一下: defmodule Corner.MaybeTest do use ExUnit.Case import Corner.Maybe test &quot;maybe&quot; do result_maybe = maybe do { :ok , a } = { :ok , 2 } { :ok , b } = { :error , a + 1 } b + 1 end assert result_maybe == { :error , 3 } end end","ref":"ch08-error_handle.html#%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%8B%AF%E6%95%91","title":"第八章 错误处理 - 更优雅的拯救","type":"extras"},{"doc":"最后, 讨论一下 try 结构中子句的顺序. 在 Elixir 文档中, 最完整的错误处理块为 try ... rescue ... catch ... else ... after . 我们看到的绝大部分例子, 都是省略部分子句的情况, 但是这些子句的相对顺序还是保持的, 那么能不能改变这些子句的相对顺序呢? 比如, 把 rescue 放在 catch 后. try do raise :error catch v -&gt; v |&gt; IO . inspect ( label : &quot;catch v&quot; ) rescue v -&gt; v |&gt; IO . inspect ( label : &quot;rescue&quot; ) else v -&gt; v |&gt; IO . inspect ( label : &quot;else&quot; ) after IO . puts ( &quot;after&quot; ) end 上面的代码, 编译器给出的警告, 警告的内容是 catch 应该放在 resuce 的后面, 不过代码依旧可以运行. 那么为什么应该那样呢? 前面的讨论, 我们知道 catch 是全能捕手, 上面的代码中, 用到的是它捕获 throw value 的语法, 所以 rescue 有机会捕获 raise 产生的错误. 但是如果使用的最通用 catch 的语法呢? 例如下面的代码: catch :error , v -&gt; ... rescue rescue_code 在上面的代码中, rescue 子句就是死代码, 永远不用有机会执行. 编译器给出警告的原因. 那么除了 rescue 和 catch 的相对位置外, 其他的子句呢? 能改变顺序码? 比如, 把 after 子句放在 resuce 前面, 可以吗? try do 1 / 0 after IO . puts ( &quot;after&quot; ) rescue v -&gt; v |&gt; IO . inspect ( label : &quot;rescue&quot; ) :rescue catch v -&gt; v |&gt; IO . inspect ( label : &quot;catch&quot; ) :catch else v -&gt; v |&gt; IO . inspect ( label : &quot;else&quot; ) end 上面的代码片段, 不但能顺利通过编译, 而且警告都没有. 也就是说, 这是完全合法的代码. after 在代码中出现的顺序, 不影响其功能. 进一步的, 不难推测, else 也可以放在 resuce 子句前. try do 2 rescue v -&gt; IO . inspect ( v , label : &quot;resuce v&quot; ) else v -&gt; v |&gt; IO . inspect ( label : &quot;else&quot; ) catch :error , v -&gt; IO . inspect ( v , label : &quot;catch :error ,v&quot; ) end 上面的代码, 也一切正常. 总结一下: 在 try 子句中: 如果 rescue 和 catch 都存在的话, rescue 应该放在 catch 子句的前面, 而其他的子句的顺序并没有特别的要求. 最后提醒读者, 我们这里是对语法规则的探索, 才故意打乱其顺序的, 绝对不是鼓励大家在实际的编码中也这样做.","ref":"ch08-error_handle.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AD%90%E5%8F%A5%E7%9A%84%E9%A1%BA%E5%BA%8F","title":"第八章 错误处理 - 错误处理子句的顺序","type":"extras"},{"doc":"在 Elixir 的官方文档中, 我们看到可以省略 try 关键字, 而直接处理错误的例子. 例如在命名函数中: def fun ( ) do ... catch :error , v -&gt; v after ... end 那么什么时候, 可以省略 try 呢? 是不是所有后面需要 do-block 的语法结构中, 都可以使用省略 try 而直接使用错误处理子句呢? 不是的. 例如, 我们就不可以给 if 语句加一个 catch 子句. 就像下面的代码这样. if 3 &lt; 4 do 1 -&gt; 1 / 0 catch :error , _ -&gt; &quot;1/0&quot; else &quot;how it can be 3 not less than 4&quot; end 我们看到命名函数中, 可以直接使用错误处理的子句, 那么是不是在匿名函数中也可以直接使用呢? 答案也是否定的, 而且 Elixir ≪语法参考≫文档的 ≪保留字≫ 小节也给出了提示: do , end , catch , rescue , after , else 在 do-end 块中使用. fn 的语法是这样的: fn a -&gt; ... end 当这里的 ... 表示多于一个表达式的时候, 这里实际上是一个暗含的块, 但是并不是一个 do-block . 这一点我们可以通过 quote 语句, 在抽象语法树的层面上看清. quote do fn a -&gt; a + 1 a - 1 end def f ( a ) do a + 1 a - 1 end end fn 的块结构抽象语法树是: { :__block__ , [ ] , [ { :+ , [ context : Elixir , import : Kernel ] , [ { :a , [ ] , Elixir } , 1 ] } , { :- , [ context : Elixir , import : Kernel ] , [ { :a , [ ] , Elixir } , 1 ] } ] } 而函数 f(a) 定义的 do...end 块的抽象语法树是: [ do : { :__block__ , [ ] , [ { :+ , [ context : Elixir , import : Kernel ] , [ { :a , [ ] , Elixir } , 1 ] } , { :- , [ context : Elixir , import : Kernel ] , [ { :a , [ ] , Elixir } , 1 ] } ] } ] 知道了这些知识, 就不难理解为什么 fn 定义匿名函数的时候, try 不能省略了. 接着探索会发现, def/2 , defp/2 , defmacro/2 和 defmacrop 中可以省略 try . 其他情形下对 try 的省略, 都是对这个特定规则的过度推广. &amp;#x21A9; Elixir 文档中关于 rescue 匹配的文档, 翻译过来是: 除了以模式匹配外, rescue 围绕异常提供了一些方便, 允许我们根据异常的名字来展开救援. 原文见 Elixir 文档关于 rescue 子句的描述 .","ref":"ch08-error_handle.html#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB-try","title":"第八章 错误处理 - 什么时候必须 try","type":"extras"},{"doc":"","ref":"ch09-module.html","title":"第九章 模块","type":"extras"},{"doc":"在 Elixir 中, 说到模块的时候, 可以指以下三个相关的概念: defmodule/2 这个宏 Module 这个 Elixir 模块 源码编译后的 .beam 文件 这三个概念当然是相互联系的, 但是又是三个不同的实体. .beam 是最后 Erlang 运行环境用来加载的单位, 当我们要讨论虚拟机如何使用模块的时候, 我们指的往往是这个意义上的模块. Module 是 Elixir 标准库中提供的一个模块, 它提供了一系列函数, 可以用来帮助我们更好的定义自己的模块. defmodule/2 是一个宏, 用来定义模块. 可以认为对 defmodule/2 宏的调用, 就是要求 Elixir 编译器把传递给这个宏的参数, 转化为 Erlang 的字节码. 这里我使用 defmodule/2 上下文 或 函数定义时 , 表示表达式 defmodule Name, do: ... 中 ... 代表的代码的情形. 而 模块中/内 , 表示对 .beam 文件结构或其加载后, 在内存中分布方式的讨论.","ref":"ch09-module.html#%E6%A8%A1%E5%9D%97%E6%A6%82%E5%BF%B5","title":"第九章 模块 - 模块概念","type":"extras"},{"doc":"Erlang 中, 模块和 .beam 文件之间的关系是非常的明确的. 模块这个概念, 在源码层面对应的就是一个 Erlang 源文件(.erl), 而在字节码层面, 对应的就是一个 .beam 文件. Erlang 的一个源文件 (.erl) 编译后对应一个 .beam 文件. 所以模块的概念, 在 Erlang 中, 几乎可以和代码文件来对换. 而模块属性的作用在 Erlang 中也非常的清晰, 就是告诉编译器, 如何来填充 .beam 文件的相关段落 (chunk) 的. 在 Erlang 中, 大部分属性和 .beam 段落名之间是有直接对应关系的, 还有一部分属性有多个值, 比如 -callback , 这些值集合到一起, 放在一个段落中的. 用户自定义的属性, 与 -vsn 一起记录到 attributes 段落中. 其实不用关心属性是记录在字节码的什么段落中, 只要理解这些内容都是要反应到模块中的, 就能很好的理解 Erlang 中模块属性了. 例如下面的 Erlang 代码 - module ( hello ) . - export ( [ say_hi / 1 , say_bye / 1 ] ) . . . . 不难推测出, .beam 文件中, 记录模块名的位置上记录的内容一定就是 hello . 而记录模块导出函数的段落中, 一定有 say_hi say_bye 这样的内容. 上面的 Erlang 代码, 对应的 Elixir 代码应该是这样的: defmodule :hello do def say_hi ( a ) , do : ... def say_bye ( a ) , do : ... end Elixir 中, 源文件和字节码文件之间不再是一一对应关系, 而且模块属性的内容, 分散源码的所有地方, 而不是像 Erlang 那样集中到文件的头部. 所以从 Elixir 代码来理解模块属性, 就不那么直观了. 内建属性 Erlang 预定义的属性示例 意义 Elixir对应语法结构 -module(MODULE_NAME) 设置模块的名字 defmodule/2 -export(Functions) 模块中导出函数 def -import(Module,Functions) 导入其他模块中的函数 import Module, only: [Functions] -compile(Options) 模块中指定编译选项 @compile([options]) -vsn(Vsn) 模块版本 @vsn(&quot;VSN&quot;) -on_load(Function) 指定模块加载时调用的函数名 @on_load ... -nifs(Functions) 指定了模块中定义的哪些函数, 可能会被作为外部语言接口 (NIF) 使用 erlang:load_nif/2 加载 (?TODO?) -behaviour(Behaviour) 指定模块实现了行为(Behaviour). @behaviour @impl -callback Name(Argument) -&gt; Result. 1 定义 Behaveiour 的回调函数 @callback function_spec -record(Record, Fields). 定义记录 Record 模块中的 defrecord -include(&quot;SomeFile.hrl&quot;). 包含预处理 require -define(Macro, Replacement). 定义宏 defmacro , defmacrop -file(File,Line) 修改了预定义的宏 ?File 和 ?Line 的值. __ENV__.file , __ENV__.line , @file -type my_type() :: other_have_defined_type() 类型定义 @type my_type() :: other_have_define_type() -spec function(type()) -&gt; return_type() 为 function 指定规范 @spec spec function(type()) -&gt; return_type() 较旧的 Erlang 版本的不支持 -callback 模块属性, 而通过定义导出函数 behviour_info/1 来定义行为. 就像下面的代码这样. - export ( [ behaviour_info / 1 ] ) . . . . behaviour_info ( callback ) -&gt; [ { func1 , Arity1 } , . . . ] ; behaviour_info ( _ ) -&gt; undefined . Elixir 中与 Erlang 对应的内建模块属性, 除了 模块, 函数, 宏, 结构以及记录 的定义是使用特定的宏外, 其他的模块属性都使用 @ 的语法. 编程语言中, 以 @ 作为语法结构的, 除了 Elixir 的模块属性外, 还有别的几种用法, 而且这几种用法在 Elixir 中, 某种程度上, 也都可以由模块属性来提供. 也就是, 模块属性在 Elixir 中不再只是用来记录字节码的元数据了, 还承担了其他的语法功能, 这就更进一步的加大了, 我对 Elixir 模块和模块属性, 这两个概念的理解的困难.","ref":"ch09-module.html#%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7","title":"第九章 模块 - 模块属性","type":"extras"},{"doc":"Elixir 的模块属性, 我认为至少对应三种其他语言的功能: Java 的注解. Python 的修饰器 Ruby 的实例与类属性 Java 注解(Anotation) Java 中使用注解语法, 为代码添加元数据. Elixir 中, 以下的模块属性用来完成类似的工作. @deprecated , @moduledoc , @doc , @impl , @typedoc . 但是这里的语法稍微不同. 例如下面两个片段都是表明 parser 这个函数被废弃了: @Deprecated int parser(String str){ .... } 对应的 Eixir 中的代码是: @deprecated &quot;Use `String.parser/1` replace.&quot; def parser ( str ) do ... end 除了字母大小写的不同外, 需要注意的是, Elixir 的模块属性是必须有对应的属性值的; Java 的注解一般不需要参数, 因为注解的作用对象就是其后的代码或字段. Java 的注解只是表明了, 后面的 API 被遗弃了, 之于应该用那个新的 API 来代替, 只能靠文档来补充了. Elixir 中情况不一样, 编译时给出 API 过期的警告后, 立刻就能给出具体的建议. Java 中注解如果要完成相同的功能必须使用带有参数的注解才行. Python 修饰器 Python 中的修饰器语法, 是通过高阶函数提供的语法糖, 来简化函数或方法定义中的重复性的模板内容. 例如下面的代码: def trace(fun): def warper(arg): print(&quot;call %s(\\&quot;%s\\&quot;)&quot; %(fun.__name__, arg) ) ret = fun(arg) print(&quot;get: %s\\n&quot;%ret) return ret return warper @trace def hello(a): return &quot;Hello, %s&quot; %(a) @trace def hi(a): return &quot;Hi, %s&quot; %(a) hw = hello(&quot;world&quot;) hi_white = hi(&quot;Mr. White&quot;) print(hw) print(hi_white) 其输出为: call hello ( &quot;world&quot; ) get : Hello , world call hi ( &quot;Mr. White&quot; ) get : Hi , Mr . White Hello , world Hi , Mr . White Elixir 不支持修饰器. 但是修饰器, 本质上不过是高阶函数生产新函数, 来代理被修饰的函数. Elixir 强大的元编程能力, 再借助编译相关的模块属性钩子(Hook): @before_compile 和 @on_defination , 是可以实现类似 Python 的修饰器这样的功能. 实际上, 早就有人做到了这一点 2 . 首先安装我们需要的库: decorator LiveBook 中使用: Mix . install ( decorator : &quot;~&gt; 1.2&quot; ) 本地运行的话, 修改 mix.exs 文件. 在 deps 函数中, 添加 {:decorator, &quot;~&gt; 1.2&quot;} 就可以了. 然后运行 mix deps.get 就会下载对应的代码到本地. 现在让我们来在定义一个修饰器: defmodule PrintDecorator do use Decorator.Define , print : 0 def print ( body , context ) do args = context . args quote do name = Atom . to_string ( unquote ( context . name ) ) IO . puts ( &quot;Function called: &quot; &lt;&gt; name &lt;&gt; &quot;( \#{ unquote_splicing ( args ) } )&quot; ) unquote ( body ) |&gt; tap ( &amp; IO . puts ( &quot;get result: \#{ inspect &amp;1 } &quot; ) ) end end end 上面代码定义了修饰符函数 print . 当其他函数被 print 修饰后, 再调用被修饰后的函数, 函数的返回结果和修饰前没什么不一样, 但是在函数返回结果之前, 会首先打印出 &quot;Function called: &lt;fun_name&gt;&quot; 这样的文本, 在返回之前, 而函数返回结果之前会先答应到控制台: &quot;get result: xxxx&quot;. 现在让我们看看如何使用修饰符函数 print 来修饰其他的函数. defmodule DecoratorUseModule do use PrintDecorator @decorate print ( ) def square ( a ) do a * a end end alias DecoratorUseModule , as : DUM 4 = DUM . square ( 2 ) 执行上面的代码, 控制台中输出为: Function called : square ( 2 ) get result : 4 Ruby 实例属性 Elixir 的模块属性, 还和 Ruby 中的定义实例属性的语法类似. Ruby 中, 用 @age 这样的语法来定义实例的属性的. Elixir 大量的语法形式是借鉴自 Ruby 的, 所以一度我也为这两个概念的联系和区别而困惑. 我认为 Elixir 的这个语法设计是故意的. 和 Erlang 中自定义属性不一样, Elixir 中的自定义模块属性, 除了可以作为模块的元数据来使用外, 还有更加实用的功能. 在编译时, 可以作为在元编程的临时结果的存储所; 作为模块内的常量. 例如, 在上面我们用的 decorator 库中, 当编译回调钩子执行 on_defination/6 后, 在被修饰的函数所在的模块被添加了 :decorated 属性 3 . 在模块被编译之前, before_compile/2 宏被调用, 在这个宏执行的过程, 读取模块的属性 :decorated 的值后, 就把这个属性从模块中删除了 4 . 所以要这样做, 是因为 :decorated 记录的内容需要被进一步的处理, 而不应作为模块的元信息记录到字节码中. 最后的一个问题就是, 为什么不可以使用模块作用域的变量来做中转呢? 这是因为 Elixir 作为一个函数式编程语言, 变量的值是不变的. 这样作用域嵌套形成的闭包, 因为变量值的不可变, 使得内部作用域和外部作用域不会相互影响. 对内部的作用域来说, 它访问的自由变量的值永远都是同一个值, 内部作用域不用担心, 因自由变量值的改变, 而破坏了内部作用域的逻辑前提. 对外部作用域来说, 内部作用域, 虽然可以定义同名变量来覆盖外部的变量, 但是在内部作用域中, 无论如何对变量重新绑定值, 都是对内部作用域的同名的新变量的操作, 而绝对不会改变外部作用域中变量的值. 所以外部作用域的代码, 也不用担心代码在运行期间, 内部作用域的代码破坏自己的数据. 函数式编程带来的好处, 不用我在此鼓吹. 但是如此一来, 遇到不同的作用域中的代码需要共享数据的时候, 就比较麻烦了. 模块的属性, 在编译时, 是整个模块中可读可写的, 所以刚好可以用来保存编译钩子 (Hook) 执行中产生的副作用. Elixir 的模块属性和 Ruby 的实例属性, 除了语法上的相似外, 其相联系之处还在于它们都是属性, 都是可以用来表示相应的概念的状态; 而区别在于, 它们表征的概念实体的生命周期不一样. Elixir 的模块属性, 活跃于编译时, 如果没有特殊设置的话, 编译结束后, 其生命也就结束了. 通过特殊的设置, 可以把属性值作为模块的元数据保存到字节码中, 那么这些数据, 将伴随着模块的存在而存在的. 但是在模块运行的期间, 这些模块的元数据是恒常不变的. 无变化, 也就无所谓生死了. 因此, 我认为, Elixir 的模块属性, 如果说有生命周期的话, 它的生命周期是模块编译期间. 而 Ruby 的实例属性, 存活于运行时, 贯穿于实例的生命周期内. Ruby 中用类属性来表示整个类都共享的数据, 其使用的语法为 @@classAttr . Ruby 可以用类属性来完成的数据复用. Elixir 模块内是不支持常量定义的, 模块属性可以用来充当模块内的常量, 以完成数据复用. 假如我们要定义一个数学相关的模块, 其中涉及到角度于弧度的转化, 那么我们可以这样来写: defmodule Angle do @pi 3.14 def convert ( { :degrate , v } ) do @pi / 180 * v end def convert ( { :radian , v } ) do 180 / @pi * v end end 上面的代码中, 多个地方用到了常量 $\\pi$, 如果不提供数据复用的方法, $\\pi$ 常量的字面量将散落于系统的各个角落. 当提高计算的精度提高, 需要使用更精确的 $\\pi$ 值时, 修改散落再各处的字面量, 那将会是一个通过且易错过程. 像上面的代码中那样, 用模块属性做编译时常量, 更新 $\\pi$ 常量的值, 我们只需要修改第 2 行代码就可以了. 此外, 模块属性的值, 不但可以为字面量, 还可以是其他的函数的返回值. 但是, 模块最后记录的属性值, 必须是可以用字面量定义的类型. 像 PID , Reference , 匿名函数等, 必须通过函数或宏调用才能产生的数据类型, 是不可以记录于模块属性中的. 合理的使用模块常量, 可以提高代码的执行效率. 假设我们的代码中, 多个地方需要使用斐波那契数列的第 1000 项. 那么每次调用都会重新计算这个值, 会拖累程序的效率. 但是, 当我们使用模块属性来保存, 那么只需要在编译的时候, 计算一次斐波那契数第 1000 项的值. defmodule Fib do def fib ( n ) do do_fib ( n , [ 1 , 1 ] ) |&gt; IO . inspect ( label : &quot;fin( \#{ n } )&quot; ) end defp do_fib ( 0 , [ a , _ ] ) , do : a defp do_fib ( n , [ a , b ] ) do do_fib ( n - 1 , [ b , a + b ] ) end end defmodule UR do def fun1 ( ) do fib1000 = Fib . fib ( 1000 ) fib1000 - 1 end def fun2 ( ) do fib1000 = Fib . fib ( 1000 ) fib1000 + 1 end end defmodule UC do @fib1000 Fib . fib ( 1000 ) def fun1 ( ) do fib1000 = @fib1000 fib1000 - 1 end def fun2 ( ) do fib1000 = @fib1000 fib1000 + 1 end end # 每次调用控制台都会输出 `fin(1000):....` UR . fun1 ( ) |&gt; IO . inspect ( label : &quot;UR.fun1()&quot; ) UR . fun2 ( ) |&gt; IO . inspect ( label : &quot;UR.fun2()&quot; ) # 编译时输出一次 `fin(1000): ...`, 运行时不在输出 UC . fun1 ( ) |&gt; IO . inspect ( label : &quot;UC.fun1()&quot; ) UC . fun2 ( ) |&gt; IO . inspect ( label : &quot;UC.fun2()&quot; )","ref":"ch09-module.html#elixir-%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7%E6%89%BF%E6%8B%85%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8A%9F%E8%83%BD","title":"第九章 模块 - Elixir 中模块属性承担的语法功能","type":"extras"},{"doc":"模块属性在编程中, 最常用的语法功能, 就是上面小节中介绍: 1) 用来保存临时的状态信息, 2) 作为运行时常量. 但是, 持久化到字节码中的模块属性值, 不只是可以用来做模块的元数据, 也可以有其他用途 5 , 所以有必要学习如何把模块属性持久化到字节码中. Module 模块中为我们提供了相应的 API: Module.register_attribute(module, attribute, options) . 当我们不使用这个函数, 而直接在 defmodule/2 上下文中, 使用 @attr 来定义模块属性的时候, 默认的 options 是 [accumulate: flase, persist: false] . 也就是说, @attr 的值默认是单值, 且不持续化的. 如果我们想要持续化, 那么必须在使用 @attr 之前, 先调用 Module.register_attribute/3 . 还是让我们用代码来探索吧: defmodule Corner.ModuleAttr do @x 1 @x 2 IO . inspect ( @x , label : &quot;@x&quot; ) Module . register_attribute ( __MODULE__ , :y , persist : true ) @y 1 @y 2 IO . inspect ( @y , label : &quot;@y&quot; ) Module . register_attribute ( __MODULE__ , :z , accumulate : true ) @z 1 @z 2 IO . inspect ( @z , label : &quot;@z&quot; ) Module . register_attribute ( __MODULE__ , :i , accumulate : true , persist : true ) @i [ 1 , 2 ] IO . inspect ( @i , label : &quot;@i&quot; ) @i 2 IO . inspect ( @i , label : &quot;@i&quot; ) end Corner.ModuleAttr . __info__ ( :attributes ) |&gt; IO . inspect ( label : &quot;attrs&quot; ) persist: true 可以把属性持久化到模块属性中; accumulate: true 使得属性的值可以累积. 上面的代码在控制台中的输出为: @x : 2 @y : 2 @z : [ 2 , 1 ] @i : [ [ 1 , 2 ] ] @i : [ 2 , [ 1 , 2 ] ] attrs : [ vsn : [ 178793915849767856111007519148929511895 ] , y : [ 2 ] , i : [ 1 , 2 ] , i : [ 2 ] ] 当属性值累计时, 在编译过程中, 属性值记录于一个列表中, 每次对属性赋值, 都是向列表头部添加新值. 但是持久化的时候, 像上面的输出中, 最后一行显示的那样: 所有需要持久化的属性值都被记录为列表, 每次赋值都当作列表中的一项, 被单独记录, 而不是根据相同属性名合并后记录. 最后, __info__/1 是 Module 模块中定义的回调函数. Elixir 定义的所有模块, 都实现了 Module 行为.","ref":"ch09-module.html#%E6%8C%81%E4%B9%85%E5%8C%96%E5%B1%9E%E6%80%A7%E5%80%BC","title":"第九章 模块 - 持久化属性值","type":"extras"},{"doc":"以前的章节中, 我们知道 defmodule/2 上下文中, 除了 def* 系列宏之外, 还可以使用其他语法结构. 现在我们来讨论, 只能在 defmoulde/2 相关的上下分中才能使用的语法结构. 函数必须定义在模块中, 这是来自 Erlang 的规定; 所以 def 和 defp 只能在模块中使用, 非常容易理解. 但是为什么结构, 记录, 异常这些定义也必须在模块中呢? defstruct , defexpect 以及 defrecord 这些宏到底做了什么呢? 在 defstruct 文档中 6 , 讲到 defstruct 还在模块中定义了 __struct__/0 函数. 正是因为 defstruct 被调用的时候, 会向被调用者的上下文中注入函数, 所以 defstruct 被调用的上下文就只能被限制为在模块内了. 和 defstruct 类似, 但是在 Elixir 中很少使用还有宏 defrecord . 这个宏做的工作与 defstruct 非常类似, 只是他们选用的表示数据的容器类型不同. defstruct 选 map 作为组合数据的基础; 而 defrecord 以元组为基础. 这是他们之间的不同. 其相同点在于: 这两个宏被调用的时候, 都要向调用它的上下文中注入函数. 所以 defrecord 也必然的就被限制在了模块中了. defexpect 所以被限制在模块内, 原因更容易理解. 因为它是基于 defstruct 工作的, 或者说, 它是特化的 defstruct ; defstruct 都被限制在模块内, defexpect 都被限制也就顺利成章了.","ref":"ch09-module.html#defmodule-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9","title":"第九章 模块 - defmodule 上下文中的内容","type":"extras"},{"doc":"上一节, 我们讨论了为什么有些宏, 被限制只能在模块中使用. 在上面的讨论中, 有意无意地, 已经认定了: Elixir 中, 只有 defmodule/2 这个宏可以被编译器编译为字节码文件. 但是这种认识是错误的. defprotocol 和 defimple 宏的调用结果, 也一样是产生 .beam 文件的. Elixir 在这里的处理和 Java 中的处理非常的类似. 我们可以用下表来做个比较. 对应项 Java Elixir 字节码后缀 .class .beam 最常用的编译单元 类定义 模块定义 嵌套处理 类定义可以嵌套, 字节码平铺 模块可以嵌套, 字节码平铺 API 接口(Interface) 协议(Protocol) API 的实现 匿名类 协议实现 API 复用代码的机制 抽象类 行为 在 Java 语言中, 类和接口的定义都会被编译为 .class 文件. 在 Elixir 中模块定义和协议定义也都要产生对应的字节码文件. 在上表中, 我把 Elixir 中的行为和 Java 中的抽象类做对比, 因为它们都是为了在定义 API 的时候最大化的复用代码, 这是从语言外部对比来看. 如果从 Elixir 语言内部来看, 协议实际上是以行为 (Behaviour) 为基础, 抽象出的模块动态调度的通用方法. 有关协议与行为的更多讨论, 见后面的 ≪协议与行为≫ 章节.","ref":"ch09-module.html#%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%A1%8C%E4%B8%BA","title":"第九章 模块 - 协议和行为","type":"extras"},{"doc":"这一小节, 我们探索如何在运行时获取一个模块的信息. 前面的小结中, 我们说到, Elixir 中定义的模块, 都实现了 Module 行为. 也就是说都有 __info__/1 函数. Erlang 的编译器自动的为每个模块插入了两个导出函数 module_info/0-1 . 每个 Elixir 代码, 最后也是要编译为 Erlang 字节码的, 所以每个 Elixir 模块, 哪怕时空模块, 至少都有这三个导出函数的. 这三个函数是模块内省的基础. module_info/0 module_info/0 给出的模块信息包括: 模块名字 :module 所有的导出 :exports 持久化的属性 :attributes 模块编译时的信息 :compile 模块的数字签名 :md5 其他两个函数, 接受的参数都是原子, 其中大部分和 module_info/0 返回 Keyword 的 key 相同. module_info/1 module_info/1 支持的的输入参数除了 module_info/0 的五个原子外, 还包含: :functions , :nifs 和 :native 7 . __info__/1 __info__ 支持以 6 原子为输入. module_info/0 的 5 个原子中, __info__ , 不支持以 :exports 为参数; 增加了 :functions 和 :macros . 差异 这里 __info__/1 和 __module__/1 都支持 :functions , 但其含义不同. __info__(:functions) 返回的是 Elixir 模块的定义的公开函数的子集 , 模块中以 _ 为前缀的函数在不显示. module_info(:functions) 返回的是模块内所有的函数 , 包括没有被导出的私有函数. 模块探索 知道了这些信息, 就不难写一个模块来帮助我们完成模块内省的工作了. defmodule Module.Explorer do def funs ( m ) do m . module_info ( :functions ) |&gt; Enum . reject ( &amp; macro? / 1 ) end def pub_funs ( m ) do m . module_info ( :exports ) |&gt; Enum . reject ( &amp; macro? / 1 ) end def priv_funs ( m ) do funs ( m ) -- pub_funs ( m ) end defp macro? ( { atom , _ } ) do &quot; \#{ atom } &quot; =~ ~r/MACRO-/ end def macros ( m ) do m . module_info ( :functions ) |&gt; Enum . filter ( &amp; macro? / 1 ) |&gt; Enum . map ( &amp; fun_2_macro / 1 ) end def pub_macros ( m ) do m . __info__ ( :macros ) rescue _ -&gt; [ ] end def priv_macros ( m ) do macros ( m ) -- pub_macros ( m ) end defp fun_2_macro ( { atom , arity } ) do &quot;MACRO-&quot; &lt;&gt; name = &quot; \#{ atom } &quot; { String . to_atom ( name ) , arity - 1 } end for name &lt;- [ :md5 , :compile , :attributes , :module ] do def unquote ( name ) ( m ) do m . module_info ( unquote ( name ) ) end end end","ref":"ch09-module.html#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9C%81","title":"第九章 模块 - 模块内省","type":"extras"},{"doc":"为实现代码复用, Elixir 提供了几个特殊表单: import , require 和 use . 从代码的清晰的角度来说, 应该首先使用 require , 其次 import 最后 use . 我们依次来看它们的用法. require require 的语法为: require &lt; ModuleName &gt; [ , as : &lt; AliasName &gt; ] 上面的代码, 不 Elixir 代码, 而是说明语法的 BNF 范式, 方括号中的内容是可省略的部分. 从语法的形式上来说, require 和 alias 非常的相似. alias 也有可选的 :as 选项. 但是, require 和 alias 对 :as 选线的默认处理并不一致. 对 X.Y 的模块, require X.Y 语句后, 并不能使用 Y.fun(...) , 来调用 X.Y 模块中定义的函数 fun . 而必须使用 require X.Y, as: Y 才可以. 我们可以定义一个新的宏来改变 require 对 :as 选项的默认处理, 使得它可以像 aliase 对 :as 选项的默认处理那样工作. 按照前面的命名规则, 这个宏命名为 require! . defmodule Corner.Require do defmacro require! ( module ) do quote do require unquote ( module ) alias unquote ( module ) end end defmacro require! ( module , as : as ) do quote do require unquote ( module ) , as : unquote ( as ) end end end 如果模块中没有宏定义, 那么 require 唯一作用就是确保要求的模块在系统中是可用的. 如果系统中不存在要求的模块, 那么编译时, 编译器会提前报错, 而不用等到调用函数或宏的时候, 才报错. require NoExist.Module 上面的代码, 会给类似于下面的编译错误: ** (CompileError) ch09.module.livemd#cell:1: module NoExist.Module is not loaded and could not be found 如果要求的模块中存在宏, 要想调用模块内定义的宏, 就必须使用 require 语句. 总结 : require 语句的作用就是确保要求的模块存在, 且使得模块中定义的宏在当前上下文中可见. import import 语句不但可以用来导入模块中的宏, 而且还可以在当前上下文中使用是本地函数调用的语法来调用导入的函数或宏. import 有三个用法: 导入模块中所有的公开的宏和函数, 但是以下划线为前缀的除外: import ModuleName 导入模块中指定的宏或函数: import ModuleName, only: [fun_or_macro_name: arity] . 排除指定的函数外, 导入其他所有函数或宏: import ModuleName, except: [fun_or_macro_name: arity] . 不推荐使用第 1 中格式, 因为这样的代码, 在代码中体现不出到底导入了什么函数. 当一个模块从多个其他模块中导入函数后, 如果都是用的是第 1 种方法, 当前文件中调用的外部函数来自那个模块, 就难以确定了. 所以应该优先使用第 2 中格式. 第 3 中格式一般在覆盖核心模块提供的函数或宏的时候使用. use use 需要被使用地模块中的 __using__ 宏函数配合才能完成功能. 原则上 __using__ 宏可能在上下中注入任意的内容, 所以不到万不得已不推荐使用 use 语句. 如果我们要自定义 Kernel 模块中提供的操作符; 在重定义的模块中, 需要使用 import Kernel, except: [fun_or_macro_name: arity] . 在使用重定义操作符的模块中, 为了避免和核心模块中的操作符冲突, 必须也排除它们. 用代码来说大概是这样的: defmodule OverWriteAdd do import Kernel , execpt : [ + : 1 ] def + ( number ) when is_numebr ( n ) , do : abs ( n ) end # in OverWriteAdd user module import Kernel , except : [ + : 1 ] import OverWriteAdd , only : [ + : 1 ] + 2 #... 在每次使用 OverWriteAdd 的时候, 都需要写 Kernel, except: ... , 语法上有些啰嗦, 为了减少冗余, 可以在 OverWriteAdd 模块中添加宏 __using__ . defmacro __using__ ( _opt ) do quote do import Kernel , except : [ + : 1 ] import OverWriteAdd , only : [ + : 1 ] end end 然后客户端使用一行代码: use OverWriteAdd 就可以了, 而不用写两行代码了. 缺失的部分 在 Javascript 中, import 语句, 除了按照定义模块中定义的函数名导入函数, 还可以为导入的函数重命名. 在 Elxiir 中, 缺少这样的语法. Kernel.defdelegate/2 宏, 完成的功能和这里的描述的功能非常类似, 但是做的多了一点点, defdelegate/2 不但可以为函数改名字, 而且还导出了这个函数. defdelegate/2 做的多了一点点. 因为这里的需求只是希望在模块内以自己提供名字, 来调用导入的函数, 而不是把这个函数作作为模块导出函数的一部分. 也就是说, 需要提供一个对导入函数在模块内, 重命名的机制. 我们可以定义 rename 宏来实现. rename 有两种格式: 指定函数的参数个数: rename ModuleName.fun_name/arity, to: new_fun_name . 不指定函数的参数个数: rename ModuleName.fun_name, to: new_fun_name . 使用第二中格式时, 如果模块中有多个同名的函数, 那么这几个函数都会导入的当前的上下文中. 实际上, rename 是在当前的上下文中定义私有函数. 所以 rename 必须在模块的上下文中才可以使用. rename 宏通过 do_rename 函数来完成工作. defmodule Corner.Rename do defmacro rename ( fun , to : new_name ) do do_rename ( fun , new_name ) end #... end do_rename 函数对 rename 的两种用法, 使用两个分句, 分别处理. 我们先来看指定参数格式的处理: defp do_rename ( { :/ , _ , [ m_f , arity ] } , { new_name , _ , _ } ) do { { :. , _ , [ module , fun ] } , _ , _ } = m_f ast = make_private ( module , fun , arity , new_name ) quote do ( unquote_splicing ( ast ) ) end end 这个函数做的工作非常的简单, 从参数中提取模块, 函数, 参数格式, 以及要重定义的函数名, 然后使用 make_private/4 来定义匿名函数就好了. make_private/4 返回的抽象语法树, 保存与一个列表中, 所以最后, 使用 unquote_splice/1 去掉外层的列表, 而只保留定义使用函数的抽象语法树. defp make_private ( module , fun , arity , new_name ) do args = Macro . generate_arguments ( arity , nil ) { _ , _ , asts } = quote do @compile online : true defp unquote ( new_name ) ( unquote_splicing ( args ) ) do unquote ( module ) . unquote ( fun ) ( unquote_splicing ( args ) ) end end asts end make_private 也足够直白, 只是以 new_name 来代理对被重命名的函数调用而已. quote/1 中有多个表达式时, quote/1 返回一个块表达式. make_private 返回的是多个语句的抽象语法树, 而不是块表达式的抽象语法树. rename 不带参数个数的用法有 do_rename 的第二个分句处理: 因为参数中不提供参数个数, 所以 do_rename 首先需要从模块中提取对应函数的参数个数. 然后依次定义私有函数就好了. defp do_rename ( { { :. , _ , m_f } , _ , _ } , { new_name , _ , _ } ) do [ module , fun_name ] = m_f aritys = get_aritys ( module , fun_name ) ast = for arity &lt;- aritys do make_private ( module , fun_name , arity , new_name ) end |&gt; List . flatten ( ) quote do ( unquote_splicing ( ast ) ) end end 需要注意的是, 上面代码中的 module , fun_name 都是抽象语法树, 所以不能直接通过 module.module_info(:exports) 来获取模块导出函数的信息. get_aritys/2 函数用来获取 module 中名为 fun 的所有函数的参数个数. defp get_aritys ( module , fun ) do { aritys , _ } = quote do unquote ( module ) . module_info ( :exports ) |&gt; Enum . filter ( fn { key , _v } -&gt; key == unquote ( fun ) end ) |&gt; Enum . map ( fn { _key , value } -&gt; value end ) end |&gt; Code . eval_quoted ( ) aritys end 在编译时, 实际上还时需要执行 module.module_info(:exports) 调用, 所以 module 代表的模块, 在调用 rename 之前必须已经定义完成. defp get_aritys ( module , fun ) do { aritys , _ } = quote do unquote ( module ) . module_info ( :exports ) |&gt; Enum . filter ( fn { key , _v } -&gt; key == unquote ( fun ) end ) |&gt; Enum . map ( fn { _key , value } -&gt; value end ) end |&gt; Code . eval_quoted ( ) aritys end 然后, 就可以这样来使用 rename : defmodule RenameTest do import Corner.Rename rename ( String . length ( ) , to : str_len ) def test ( ) do a = &quot;hello&quot; String . length ( a ) == str_len ( a ) end end RenameTest . test ( ) #true &amp;#x21A9; Elixir 被废弃的 Behaviour 模块就是为了帮助我们定义自己的 behaviour_info 函数. 现在因为 Erlang 支持 -callback 模块属性, 所以 Elixir 也废弃了 Behaviour 模块, 而启用了新的 @callback 内置模块属性. &amp;#x21A9; https://github.com/arjan/decorator &amp;#x21A9; 见源码 第 20 行 &amp;#x21A9; 见源码 第37, 38行 &amp;#x21A9; 持久化属性值在编程中的使用, 见后面的 冷知识章节 . &amp;#x21A9; 见 Kernel 模块文档 destruct/1 相关内容 &amp;#x21A9; 见 Erlang 参考文档, 模块章节 .","ref":"ch09-module.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E5%85%A5","title":"第九章 模块 - 函数的导入","type":"extras"},{"doc":"","ref":"ch10-protocol_and_behaviour.html","title":"第十章 协议与行为","type":"extras"},{"doc":"就像 case 和 cond 一度让我感觉选择困难一样, 面对协议和行为, 我往往也难以做出抉择. 但是这种困难和语言无关, 因为它不是语义方面的的问题, 而是系统设计知识不足带来的. 可以这样理解, 协议就是 OOP 编程中的接口 (Java) 或者纯抽象类(C++); 而行为就是一般的抽象类. 至少协议和行为解决的问题与 OOP 中接口与抽象类解决的问题是一样的. 接口和协议可以看作一个系统的 API 接口, 使用者只需要关心系统提供了那些功能, 而不用关心这些功能是如何实现的. 抽象类或行为可以看作是可供 DIY 的产品. 基础的功能, 行为( Behavior ) 已经为我们定义好了, 系统各个部分交互的规则也已经完成了, 但是具体的业务需求部分, 需要用户自己 DIY. 如果代码最主要的目的, 是简化系统的调用, 那么应该使用协议及其实现. 如果代码提供的服务, 需要支持定制化的开发, 那么就应该使用协议.","ref":"ch10-protocol_and_behaviour.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9","title":"第十章 协议与行为 - 如何选择","type":"extras"},{"doc":"首先在底层, 协议和协议的实现到底是什么? Erlang 中根本没有协议这样的语法概念. Elixir 运行在 Erlang 的虚拟机中, 所以 Elixir 是用了 Erlang 中的概念为我们抽象出了协议这一新概念. 和协议关系最密切的概念就是行为, 就像上一节描述的那样, 这两个概念密切到我不知道如何选择. 现在又知道, 协议是高级的概念, 那么可以肯定, 协议的概念一定构建在行为的基础上. 行为是模块的属性, 是模块发出的声明: 实现了某个模块中所有的 @callback 属性. 而一个理想的协议模块, 除了实现的动态调度的相关函数外, 没有其他函数. 那么协议这个概念本质上, 就是 Elixir 帮助我们更简单的完成对行为的动态调度.","ref":"ch10-protocol_and_behaviour.html#%E5%8D%8F%E8%AE%AE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88","title":"第十章 协议与行为 - 协议到底是什么","type":"extras"},{"doc":"在前面的模块的章节中, 我们已经知道了 defprotocol 和 defimpl 宏的调用, 和 defmodule/2 的调用一样, 在编译后会产生编译模块, 反映到文件系统中就是 .beam 文件. 我们还知道, defmodule/2 是支持嵌套定义的, 那么这就意味着, defprotocol 和 defimpl 除了定义在顶层的作用域外, 还可以嵌套在 defmodule/2 的上下文中. 现在让我们定义一个 Corner.Addable 协议. defmodule Corner do defprotocol Addable do def add ( a , b ) end defimpl Addable , for : [ Integer , Float ] do def add ( a , b ) , do : a + b end end 首先, 用 elixirc 来编译这段代码, 得到 4 个 .beam 文件, 分别是: Elixir.Corner.beam , Elixir.Coner.Addable.beam , Elixir.Coner.Addable.Integer 和 Elixir.Corner.Addable.Float . 也就是说, 如果在模块内使用 defprotocol , 那么它的变化类似于 defmodule/2 , 最后产生的模块名会添加外部模块前缀. 而协议的实现代码, 实际上是定义在 Protocol.Type 这样的模块中的, 而不再添加外部模块的前缀. 例如下面的代码第 5 ~ 10 行, 我们在 TimeSpan 模块的定义的上下文中, 为 TimeSpan 类型实现 Coner.Addable 协议. 这新的实现, 是位于模块 &lt;s&gt;Corner.TimeSpan.&lt;/s&gt;Corner.Addable.Corner.TimeSpan 中, 这里没有添加外部模块的前缀 Corner.TimeSpan . 也就是说, defimpl Protocol, for: Type 无论在哪里, 都一样展开为 Protocol.Type , 而不会因为嵌套在其他模块结构中, 而添加新的前缀. defmodule Corner.TimeSpan do defstruct hour : 0 , min : 0 , second : 0 alias Corner . { Addable , TimeSpan } defimpl Addable , for : __MODULE__ do def add ( a , b ) do %{ hour : h1 , min : m1 , second : s1 } = a %{ hour : h2 , min : m2 , second : s2 } = b # %__MODULE__{hour: h1 + h2, min: m1 + m2, second: s1 + s2} % TimeSpan { hour : h1 + h2 , min : m1 + m2 , second : s1 + s2 } end IO . inspect ( __MODULE__ , label : &quot;__MODULE__&quot; ) end end 在这种模块嵌套的代码中, 要特别留意上下文. 请注意上面的代码片段中的 __MODULE__ , 在不同的上下文中, 其展开结果是不一样的. 第 5 行的 __MODULE__ 展开为 Corner.TimeSpan 在意料之中. 但是第 12 行的 __MODULE__ 展开是什么呢? 或者说, 第 8 行的最终的语义和第 9 行一样吗? 通过控制台的输出, 我们知道是第 13 行的 __MODULE__ 展开为 Corner.Addable.Corner.TimeSpan . 因此不难推测, 注释掉的第 9 行, 其语义与第 10 行的是不同的. 虽然上面的讨论已经知道 defimpl 是要定义一个新的模块, 但是我第一次编码的时候, 还是犯了第 9 行这样的错. 因为 defprotocol 和 defimpl 实际上是要创建模块, 除了 defprotocol 对核心模块的少数几个宏做了限制外 1 , 大部分的功能并没有限制, 所以就像我们可以在 defmodule/2 的上下文中执行 def* 以外的其他表达式那样, 在 defprotocol 和 defimpl 上下文中也可以这样做. 现在我们知道了, defimpl 可以嵌套到 defmodule/2 中, 那么 defimpl 内部可以嵌套 defimpl 调用吗? 或者再推广一下: defimpl 都可以在什么样的上下文中调用呢? 以前的章节中, 我们见到的 defimpl 调用的上下文有: 顶层作用域 defmodule/2 作用域 剩下的作用还有如下几个: defprotoc defimpl def , defp , defmacro defmacop 首先, 不可以直接在 defprotoc 的上下文中, 使用 defimpl 为正在定义的协议提供实现. defprotocol Addable2 do def add ( a , b ) defimpl Addable2 , for : Integer do def add ( a , b ) do a + b end end end 编译这段代码, 得到了编译错误. 错误是 defimpl 引发的, 错误的原因是不能加载模块 Addable2 . 这说明, 调用 defimpl 的时候, 会加载 :for 选项指定的模块. 现在还没有完成 Addable2 模块的定义, 所以加载这个模块自然是失败的. 但是我们可以在协议定义的上下文中, 为其他协议提供实现吗? 答案是可以的. defprotocol Corner.Addable2 do # def add1(a) defimpl Corner.Addable , for : String do Kernel . def ( add ( a , b ) , do : a &lt;&gt; b ) end Kernel . def say_hello ( ) do IO . puts ( &quot;Hello&quot; ) end end Corner.Addable2 . say_hello ( ) 但是要注意第 4 行, 这里使用 Kernel.def 远程方法调用的语法来调用 def/2 , 因为在 defprotocol 上下文中, 特意排除了核心模块 def/2 的导入. 在实验上面的代码片段前, 我以为 defprotocol 上下文中, 必须有 def/1 语句, 但是现在明白, 不是的. 起初还以为, defprotocl 上下文中, 不可以定义自己的函数, 现在发现, 可以使用远程方法调用的语法, 用 Kernel.def/2 来定义自己的函数; 就像上面的代码第 7~9 行中那样. 最后强调一下: 虽然可以像上面的代码片段那样, 用 defprotocol 来定义模块, 但是绝对不推荐这样做. 结论 : 在 defprotcoc 定义的上下文中, 不能为正在定义的协议的提供实现. 或者说, 宏调用 defimpl Protocol,... , 中的 Protocol 对应的模块必须是闭合的. 那么 defimpl 可以嵌套自己吗? defimpl Corner.Addable , for : Tuple do def add ( a , b ) do Tuple . append ( a , b ) end defimpl Corner.Addable , for : BitString do def add ( a , b ) do a &lt;&gt; b end end end defimpl 中可以嵌入 defimpl ; defimpl 在 defimpl 调用的上下文中, 与在顶层的作用域上下文中, 没有区别 . 这还真的出乎我的意料. 但是这样做, 除了让代码变得丑陋外, 一点其他用处也没有. def 和 defp 是用来在模块中定义函数的. 函数不可以嵌套定义, 所以我预计, 在 def 上下文中, 是不可以调用 defimpl 的. 但是还是让我们实验一下吧. defmodule EmbedImplToFun do def fun ( ) do defimpl Addable , for : Tuple do def add ( a , b ) do Tuple . concat ( a , b ) end end end end 又超出了预期了, 居然可以! 那么可以预期, 在 def 中也是可以调用 defmodule/2 . Elixir 中不允许命名函数嵌套, 但是知道了上面的知识, 我们就可以让函数返回模块, 然后在模块中定义命名函数, 以这种迂回的方式来实现函数的嵌套. 详细讨论见 冷知识章节 .","ref":"ch10-protocol_and_behaviour.html#%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%A8%A1%E5%9D%97","title":"第十章 协议与行为 - 协议与模块","type":"extras"},{"doc":"让我们再回到对协议的讨论上来. 协议看起来足够的简单. 似乎 defprotocol 只是作了限制的 defmodule/2 : 其上下文中, 只能使用 def/1 宏. 但是实际上不是这么简单的. 首先协议对其中的定义函数是有限制的: 协议中的函数, 不可以为零元函数. 所以在 defprotocol 上下文中使用的 def/1 是重新定义的, 而不是导入的 Kernel.def/1 . 当我们在协议中定义零元函数的时候, 会引发编译错误. defprotocol ZeroArityFun do def sayHi ( ) end 上面我们展示了, defprotocol 对 def/1 的限制; 接下来, 我们会看到协议对函数也有辅助: 协议会对其中定义的函数的第一个参数做类型检查. defprotocol Corner.Protocol do def sub_one ( a ) def add_one ( a ) end alias Corner.Protocol defimpl Protocol , for : Integer do def sub_one ( a ) do IO . puts ( &quot;sub_one(i)&quot; ) a - 1 end def add_one ( a ) do a + 1 end end defimpl Protocol , for : Float do def sub_one ( a ) do IO . puts ( &quot;sub_one(f)&quot; ) a - 1 end def add_one ( a ) , do : a + 1 end defimpl Protocol , for : BitString do def sub_one ( &lt;&lt; _ :: utf8 , rest :: binary &gt;&gt; ) do rest end def add_one ( a ) , do : a &lt;&gt; &quot;one&quot; end Protocol . sub_one ( 1 ) Protocol . sub_one ( 1.0 ) Protocol . sub_one ( &quot;Hello&quot; ) Protocol . add_one ( 1 ) |&gt; IO . inspect ( label : &quot;add_one(1)&quot; ) Protocol . add_one ( 1.0 ) |&gt; IO . inspect ( label : &quot;add_one(1.0)&quot; ) Protocol . add_one ( &quot;One + &quot; ) |&gt; IO . inspect ( label : &quot;add_one( \\&quot; One + \\&quot; )&quot; ) 实际上, 协议对函数的辅助, 只是实现对模块的动态调度的自然结果; 而对函数的限制, 则是实现动态调度的必然要求. 协议实际帮助我们消弭模块名, 来实现函数的动态调度. 但是 Elixir 动态调度只能通过模式匹配来完成. 函数调用的匹配包括一下内容的匹配: 模块名 函数名 参数模式, guard 子句 协议要动态调度, 就是要消除模块之间的差异的, 所以在这里, 模块不能作为动态调度的依据了. 协议的实现中, 函数名都是一样的, 所以它自然也不能用作动态调度的依据. 零元函数, 因为没有参数, 所以最后可以用来区分不同函数的因子, 也不再有用. 这就是协议上下文中要求 def/1 定义的函数, 必须至少含有一个参数的原因. 上面我们看到了, 协议的确做到了对协议实现模块的动态调度. 但是它是如何做到的呢?","ref":"ch10-protocol_and_behaviour.html#%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%87%BD%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6%E4%B8%8E%E8%BE%85%E5%8A%A9","title":"第十章 协议与行为 - 协议对函数的限制与辅助","type":"extras"},{"doc":"Elixir 协议模块文档的 反射章节 , 告诉我们: 每个协议模块, 都会包含了以下三个用来完成, 协议及其实现模块的反射操作的函数: __protocol__/1 返回这个协议模块的相关的元信息. impl_for/1 返回给定数据的处理模块, 或者返回 nil . impl_for!/1 和上面的函数类似, 但是如果没有找到对应的实现的话, 会引发异常. 所以通过 impl_for 或 impl_for! 可以完成对实现模块的动态调用. 比如我们上面定义的 Corner.Addable 协议, defprotocol 对应的模块中, add/2 函数就可以非常简单的这样来实现 2 : defmodule Corner.Addable do #... def add ( a , b ) do m = impl_for! ( a ) m . add ( a , b ) end end 但是 impl_for 和 impl_for! 又是如何完成它们的工作的呢? 前面我们已经知道, 协议的实现模块的模块名都是以协议模块的模块名为前缀的. 要完成 impl_for 和 impl_for! 可以分成两步走: 在运行时获取所有的模块, 并依据模块名筛选出以协议名为前缀的模块. 但是这样找出的模块不能保证就一定是协议的实现. 探测这些找到的模块的元信息, 来确认模块是否的确是协议的实现. 那么第一个关键就是如何在运行时获取系统中的模块呢? Erlang 的标准库的 :code 模块提供了这样两个函数: all_available/0 all_loaded/0 顾名思义, 这两个函数: 第一个用来获取所有的可以加载到系统中的模块; 第二个用来获取所有加载到系统中的模块. 知道了这些知识, 第一步就不难完成了. 接下来我们探索一下, defprotocl 和 defimpl 如何配合, 以便可以通过模块的元信息来确认某个模块是协议的实现的. 协议的实现模块, 有一个 :__protocol__ 属性, 其值为: [protocol: Protocol, for: Type] . 我们可以通过 ProtoclImpl.__info__(:attributes) 或 Module.module_info(:attributes) 来获模块的所有的属性. 这两个函数返回的都是关键字列表, 因此我们可以通过 Access 行为来获取 :__protocol__ 对应的值. 下面的代码, 获取了 Corner.Addable.Integer 模块的 :__protocol__ 属性的值: Corner.Addable.Integer . module_info ( :attributes ) [ :__protocol__ ] 所以第二步也就非常清楚了. 根据数据, 判断对应的模块. 我想相应的代码, 大概是这样的: def data_to_module ( d ) do cond do is_tuple ( d ) -&gt; Tuple is_atom ( d ) -&gt; Atom is_list ( d ) -&gt; List is_bitstring ( d ) -&gt; BitString is_integer ( d ) -&gt; Integer is_float ( d ) -&gt; Float is_function ( d ) -&gt; Function is_pid ( d ) -&gt; PID is_map ( d ) -&gt; Map is_port ( d ) -&gt; Port is_reference ( d ) -&gt; Reference is_struct ( d ) -&gt; :struct _ -&gt; Any end end 根据协议实现的 :__protoco__ 属性值, 来找到合适的处理模块, 代码大概是这样: def filter ( [ protocol : pro , for : mod ] , d ) do t = data_to_module ( d ) if t == :struct and % mod { } = d do true else mod == t end end 那么 imp_for 和 impl_for! 大概就是这样的: def impl_for ( d ) do :code . all_loaded ( ) |&gt; Enum . map ( &amp; elem ( &amp;1 , 0 ) ) |&gt; Enum . filer ( &amp; by_module_name_prfix ( &amp;1 , __MODULE__ ) ) |&gt; Enum . find ( nil , &amp; filter ( &amp;1 . module_info ( :attributes ) [ :__impl__ ] , d ) ) end def impl_for! ( d ) do t = impl_for ( d ) if t , do : t , else : raise Protocol.UndefinedError , d end","ref":"ch10-protocol_and_behaviour.html#%E5%8D%8F%E8%AE%AE%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6","title":"第十章 协议与行为 - 协议动态调度","type":"extras"},{"doc":"在我自己构思以上的实现后, 我发现, 我能看懂 Elixir 的 impl_for 的实现了. 其源码在于 protocol.ex 的第 817 ~ 877行 . 如果把其中的宏展开的话, 代码是这样的: defmacrop any_impl_for ( ) do if @fallback_to_any do quote do : unquote ( __MODULE__ . Any ) . __impl__ ( :target ) else nil end end @spec impl_for ( term ) :: atom | nil def impl_for ( data ) # What is this _v_ ? def impl_for ( % struct { } ) do struct_impl_for ( struct ) end def impl_for ( data ) when is_integer ( data ) do # Note this one.....................v target = Module . concat ( __MODULE__ , Integer ) try do target . __impl__ ( :target ) rescue UndefinedFunctionError -&gt; any_impl_for end end def impl_for ( data ) when is_float ( data ) do # Note this one.....................v target = Module . concat ( __MODULE__ , Float ) try do target . __impl__ ( :target ) rescue UndefinedFunctionError -&gt; any_impl_for end end ... def impl_for ( _ ) do any_impl_for end defp struct_impl_for ( struct ) do target = Module . concat ( __MODULE__ , struct ) try do target . __impl__ ( :target ) rescue UndefinedFunctionError -&gt; any_impl_for end end 这样的实现, 确实高明. 宏的代码共 60 行; 每个基础类型, 展开后 8 行代码, 全部基础类型的 impl_for 子句就有: $8\\times 11 = 88$ 行. 我这里的代码所以短, 是因为我只对 Integer 和 Float 做了展开, 其他 9 个基本类型的账号, 都用 ... 代替的缘故. 通过查看 Elixir 的源码, 还可以知道, 每个协议的实现模块中都有一个 __impl__(:target) 函数. 这是 defimpl 与 defprotocol 打的配合, 为的是消除命名冲突. Elixir 的实现, 时间复杂度为 O(0), 而我的实现, 实际复杂多为 O(1). 😳 在上面的代码片段的第 11 行, 有一个不常见的语法. 对一个结构对象 struct_obj 来说, %s{} = struct_obj , 那么变量 s 中绑定的内容就是 struct_obj 结构所在模块的名字. defmodule Corner.Point do defstruct x : 0 , y : 0 end alias Corner.Point , as : P obj = % P { } % module { } = obj module == Corner.Point # true &amp;#x21A9; 见 Elixir 协议模块源码的 第 690~703 行. &amp;#x21A9; 这是我的猜测, 所以 defpotocol 真正产生的代码和这里的代码肯定不一样.","ref":"ch10-protocol_and_behaviour.html#elixir-%E7%9A%84%E5%AE%9E%E7%8E%B0","title":"第十章 协议与行为 - Elixir 的实现","type":"extras"},{"doc":"","ref":"ch11-macro.html","title":"第十一章 如何理解宏","type":"extras"},{"doc":"宏是什么? 这似乎是一个非常容易掌握的概念. 我的理解是这样的: 宏是写给编译器的指令. 这个定义非常宽泛, 从 C 这样的最简单的文本替换宏, 到 Lisp 这样的对抽象语法树做处理的宏, 都可以涵盖. 这样的理解不能说错误, 但是取没有抓住宏的本质. 我发现, 这就是为什么, 我现在学习 Elixir 的时候, 时常遇到困惑的一个根本原因. 所以如此, 和我的知识储备有关系. 我学习和熟练掌握的编程语言中, 宏在其中要么基本上没有地位(Python, Javascript), 要么只有非常非常小的作用(C, C++). 所以对宏的理解, 才会一直停留在概念的阶段. 按照我们的定义, 宏只能是编译型语言中才会出现的概念. 因为解释性的语言, 没有编译器的存在. 当然了, 我知道也理解, 现在大部分的解释器, 实际上也是要做编译器要做的工作的. 所以理论上, 也应该有宏的. 但是对于解释性的语言来说, 要区分宏和普通的代码是困难的. 因为代码的执行和宏的执行, 概念上有先后的两个动作, 对于解释性的语言, 从外部观察时, 这两个动作是难以区分的. 但是对于编译型的语言, 因为编译代码和运行程序可以做到时间上间断, 所以可以清楚区分它们. 例如, 同样的关于外部代码的导入的语法, C/C++ 中以 #include 的形式出现, 通过预处理, 我们可以清楚的体会到宏的存在. 反观 Javascript 中, 以 import 语句的形式出现的相同功能, 不难想象, Javascript 解释器与 C 编译器做了大量的相同的工作. 但是 Javascript 解释器为 import 语句做的工作, 从系统外部难以观察出来, 如果不考虑程序的执行的副作用的话. 不那么严格的解释, 可以认为解释性语言, 解释器对源码是解释执行的. 而编译型的语言, 编译器是要编译源码的. 通常情况下, 编译 我理解就是做翻译, 把源码中的文本翻译成中央处理器(CPU) 或者虚拟机(VM) 可以理解的内容. 这样的理解对于普通的代码是没有问题的, 但是当考虑宏的时候, 编译器对宏做的事情就不能这样理解了. 普通的代码, 对编译器来说, 是要处理的数据; 但宏不是编译器要处理的数据, 而是其待执行的指令. 编译器对宏, 正像解释器对源码做的一样: 解释并执行它们. 拿一个社会生活的场景来对比一下, 也许就更清楚了. 一个对翻译品质有担当的翻译者, 在翻译的时候往往会和作者沟通; 如果两人关系更密切的话, 译者甚至拿到的翻译底本, 直接就有原作者的批注. 这些批注是写给译者的, 用来提醒译者原文的正确意图的. 这些内容(批注或者作者的答复), 虽然不是原书的内容, 但是它们对译文来说, 是必要的, 因为它们确确实实的影响译文的呈现, 进而影响读者对原文的理解. 在这里, 译者就是编译器; 原始的书稿内容是常规的代码; 作者的批注和答复, 就是宏; 译文就是编译后的目标码; 读者就是 CPU 或 VM. 在 C/C++ 以及 Erlang 这些语言中, 宏能完成的工作是非常少的, 大部分的工作还是要编译器完成的. 这正像是, 虽然作者可以答复译者的咨询, 或在书稿中做注释, 但主要的工作还是要由译者完成. 但是这样的意象在处理 Elixir 这样的宏的时候, 就不适用了. 例如, 对于 BEAM 虚拟机的最基本的编译单元--- --- 模块 来说. 在 Elixir 中, 我们必须使用宏 defmodule/2 . 它和 Erlang 中的 -module(MODULE_NAME). 做的工作完全不是一个数量级的. -module(MODULE_NAME). 只是标记了模块的名字, 并没有涉及到模块的正文. defmodule/2 不一样, 它不但包含了模块的名字, 而且包含了模块正文. 所以脚注的意象在这里就不合适了. Elixir 宏的合适意象应该汉语屋的故事 1 . 译者对原文的翻译是智慧型的劳动; 汉语屋中的人做的却是机械的工作. 从语言学的角度来看, C/C++, Erlang 的宏不能构成一个图灵完备的语言, 或者至少设计的初衷不是把它们当作一个图灵完备的语言来设计的 2 . 但是 Elixir 中的宏是图灵完备的, 从这个角度来看 Elixir 的编译器实际上就是宏的解释器. 写常规的 Elixir 代码, 大量的是对内建宏的调用, 这就像是我们在其他语言中调用标准库一样; 而定义自己的宏, 也就是说元编程, 才像是用编程语言来完成编程任务, 只是元编程的任务是对编译器的功能进行扩增或修改.","ref":"ch11-macro.html#%E5%AE%8F%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB","title":"第十一章 如何理解宏 - 宏与语言分类","type":"extras"},{"doc":"Elixir 的编译器是 elixirc . 我们现在来探索一下编译器. IO . puts ( &quot;Hello World!&quot; ) 把上面的代码保存到名为 hello-world.ex 文件中, 然后我们在命令行中输入 elixirc hello-world.ex , 然后我们就看到了 &quot;Hello, World!&quot;, 但是在当前的目录下面, 并没有产生 hello_world.beam 文件. 上面的代码片段, 以及它的运行的结果, 告诉我们, 在模块外的作用域中, 代码直接在编译时运行(输出 &quot;Hello World&quot;), 而不是把编译的结果保存到字节码文件中(所以没有 .beam 文件). 模块的外的代码, 编译器直接解释执行; 模块内的代码, 编译器是如何处理的呢? IO . puts ( &quot;Say hello outside Module!&quot; ) defmodule MyModule do IO . puts ( &quot;Say Hello in MyModule But not in function&quot; ) def hello do IO . puts ( &quot;Say Hello in MyModule.hello()&quot; ) end end 把上面的代码保存到 my_module.ex 文件中, 然后使用 elixirc my_module.ex 命令来编译我们的文件. 在编译的过程中, 我们可以看到第 1 行和第 4 行的输出. 在当前目录下, 还看到了编译器产生的 Elixir.MyMoule.beam 文件. 这说明, defmodule/2 的第二个参数, do ... end 块, 在 defmodule/2 被调用的时候, 得到了执行. 其中的 IO 输出语句(第 4 行) 在编译时执行了, 所以我们在编译器的标准输出中, 看到了它的输出内容. 最后产生的 Elixir.MyModule.beam 文件, 则说明编译器还把其他的内容编译成了字节码. 现在我们启动 iex . 输入 MyModule.hello() , 按下回车后, 第 7 行的输出语句就显示出来了. 这说明, 我们的 hello/0 函数的确被编译到了字节码文件中. 在模块中, 不但可以调用 def* 这些宏, 还可以执行其他语句, 这还是让我十分的惊讶的. 因为 C++ 和 Java 的背景知识, 不由自主的总是把 Elixir 的模块和类的概念联系到一起. 但是在类的定义的作用域中, 基本上只可以使用赋值语句, 而且 = 的右值还必须是编译时常量, 其他控制结构, 或者函数调用都是不允许的. C 语言的全局作用域中, 基本上也是这样的要求. 即使在亲缘关系最近的 Erlang 中, 基本上也是一样. 控制结构, 函数调用, 都只能在函数的定义中使用. 如果一定要在其他语言中寻找对应物的话, 那么可能就是 Java 的静态块了. Elixir 在 defmodule/2 上下文中, def* 外的其他语句的执行情况, 和 Java 中, 对静态块处理还是有不同的: Java 中的静态块是编译到字节码中的, 且每次字节码被加载的时候, 都要被执行的. 而 Elixir defmodule/2 上下文中 , def* 之外的代码, 都是在编译时被解释执行了, 并 没有 被保存到字节码中. 这一点我们可以通过启动 iex 的时候, 并没有看到代码片段中第 4 行的输出而得到确认. 或者, 我们可以可以使用 Elang 提供的库函数 :beam.chunks/2 , 来查看编译后的代码的抽象码(字节码对应的汇编语言), 以此来更直观的证实我们的结论. 在 iex 中输入 :beam_lib.chunks('Elixir.MyModule',[:abstract_code]) , 我们就看到了 Elixir.MyModule.beam 中保存的字节码对应的抽象码. 观察输出的抽象码, 不难发现, 其中的确有我们这里定义的 hello/0 函数; 而且真的找不到第 1 行和第 3 行相关的代码. 这全面的证实了我们上面对编译器的分析.","ref":"ch11-macro.html#%E5%AE%8F%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8","title":"第十一章 如何理解宏 - 宏与编译器","type":"extras"},{"doc":"开始学习 Elixir 的时候, 最不习惯的是控制结构中的逗号和冒号. 比如 defimpl ProtocolName, for: Integer do... , 协议名后面的 , 为什么是必须的呢? 还有 Elixir 中, for 明明是一个保留字, 为什么这里还必须用关键字的语法糖呢? 所以会有这些疑问在于, 初学 Elixir, 把 Elixir 中, 用作控制结构的宏, 当作是其他语言的保留字了. 只有认识到宏不是保留字, 而是特殊的函数, 才能更好的理解上面的问题. 宏是被编译到字节码中的, 我们还知道, Erlang 中只有模块属性和函数可以被编译到字节码中. 所以 Elixir 宏一定是特殊函数. 不然它不能被编码到字节码中. 认识到宏是特殊函数, 那么对宏的调用自然必须遵守对一般函数调用的规则. 这其中最重要的规则就是: 调用函数时, 当参数个数多于一个的时候, 参数之间是用 , 做分隔符的. 这实际上就解释了为什么宏调用的时候, 当宏的参数个数多余一个的时候, 会有 , 了. 在我最初的理解中, 我认为关键字列表语法糖 do: 是对保留字 do 的模仿. 但是认识到宏调用本质上也是函数调用, 那么这个理解就应该反转过来了, 关键字列表 [do: ...] 是合法的数据, 但是 do 保留字不是数据, 函数 (以及宏) 接受的应该是合法的数据, 所以 do 实际上的工作就是要创建 [do: ...] 这样的关键字列表. 如果宏也是函数, 为什么它那么特殊, 必须导入( import ) 或请求 ( require ) 后, 才能调用宏呢? 或者换个角度来说: 宏是如何特殊于普通函数的? 请求( require ) 又是如何帮助我们突破这种特殊性的? 让我们用实验来探索. defmodule Explore.MacroDef do defmacro assign_one ( a ) do IO . puts ( &quot;assign_one running, a: \#{ inspect ( a ) } &quot; ) ast = quote do IO . puts ( &quot;after the assign_one&quot; ) unquote ( a ) = 1 end IO . puts ( &quot;assign_one ending&quot; ) ast end def bar , do : nil end Explore.MacroDef . module_info ( :functions ) 输出为: [ __info__ : 1 , &quot;MACRO-assign_one&quot; : 2 , bar : 0 , module_info : 0 , module_info : 1 ] 上面的代码中, 在模块中, 定义了 assign_one/1 宏 和 bar/0 函数. 调用 module_info(:funstions) 可以看到模块的导出的所有函数. module_info/0-1 是所有的 Elixir/Erlang 模块都有的函数. __info__/1 是 Elixir 的 Module 行为提供的, 所有的 Elixir 模块都实现了这个行为. bar/0 是模块中定义的公开方法 MACRO-assign_one/2 看起来是和我们的宏定义中 assign_one 相关. 这首先证实了, Elixir 宏是特殊的 Erlang 函数. 接下来, 我们来看看 require 帮我们做了哪些工作. 首先我们看看 require 之后, 代码的效果. 然后我们设法不用 require , 达到同样的效果. 如果我们能做到, 而且确切的知道, 做到同样的效果的确切步骤, 那么大概 require 就是帮助我们做这些事情的. 当我们对 require 的运行机制有了大约的了解后, 也许可以帮助我们更轻松的阅读 Elixir 的源码, 从而真正的理解 require . IO . inspect ( &quot;Beign&quot; ) alias Explore.MacroDef , as : M b_reqs = __ENV__ . requires try do M . assign_one ( nil ) rescue e -&gt; IO . inspect ( e ) end require ( M ) |&gt; IO . inspect ( label : &quot;require return&quot; ) #M.assign_one(a) binding ( ) |&gt; IO . inspect ( label : &quot;binding&quot; ) ( __ENV__ . requires -- b_reqs ) |&gt; IO . inspect ( label : &quot;The diff of __ENV__.requires&quot; ) 输出为: &quot;Beign&quot; % UndefinedFunctionError { arity : 1 , function : :assign_one , message : nil , module : Explore.MacroDef , reason : nil } require return : Explore.MacroDef binding : [ b_reqs : [ Application , Kernel , Kernel.Typespec ] ] The diff of __ENV__ . requires : [ Explore.MacroDef ] 上面的代码运行后, 控制台的输出结果不难预测. 但是去掉 M.assion_one(a) 注释后, 控制台的输出是这样的: assign_one running , a : { :a , [ line : 12 ] , nil } assign_one ending &quot;Beign&quot; % UndefinedFunctionError { arity : 1 , function : :assign_one , message : nil , module : Explore.MacroDef , reason : nil } require return : Explore.MacroDef after the assign_one binding : [ a : 1 , b_reqs : [ Application , Kernel , Kernel.Typespec ] ] The diff of __ENV__ . requires : [ Explore.MacroDef ] 为什么宏调用的输出会先于第 1 行的输出呢? 这时因为宏的调用是在 Elixir 的编译器中运行的, Elixir 编译器 把普通的函数调用编译为字节码 ; 而 对宏调用, 则在编译时执行宏调用, 然后把宏调用返回的 ast 编译为字节码 . 编译结束后, 这些字节码, 交给 Erlang 运行时系统 (Erlang Runtime System, ERTS) 来执行的这些字节码. 因此, 输出中的 1, 2 行是 Elixir 编译器的输出结果, 其他的则是 ERTS 执行字节码的结果. 如果我们把上面代码中第 5 行中的 nil 改为其他的变量, 像第 12 行中那样, 那么编译器会报错, 提示变量不存在. 而调用 require 后, 第 12 行代码中, a 被转化为了 ast: {:a, [line: 12], nil} . 这是 require 在编译时做的工作. 观察输出, 可以知道 require 返回请求的模块名 (输出的 11 行), 而且修改了运行时的环境(输出的倒数第二行). 这是 require 对运行时的影响. 现在只剩下最后一点了. 我们定义的 assign_one 是一个一元的宏, 但是 MACRO-assing_one 是一个二元的函数. 所以, require 除了帮助我们把 a 转化为 ast 外, 还自动为我们提供了第一个参数. 这个参数就是当前的执行环境, 也就是 __ENV__ 的值. 下面, 让我们看看, 不借助 require , 如何来调用宏. fun = fn -&gt; ast = M . &quot;MACRO-assign_one&quot; ( __ENV__ , { :b , [ ] , nil } ) IO . puts ( &quot;MARCO-assign_one have run.&quot; ) IO . puts ( &quot;Now run the ast in ERTS.&quot; ) Code . eval_quoted ( ast ) |&gt; elem ( 1 ) |&gt; IO . inspect ( ) end IO . puts ( &quot;before call fun.()&quot; ) IO . puts ( &quot;=========================&quot; ) fun . ( ) 上面的代码的输出为: before call fun . ( ) === === === === === === === === = assign_one running , a : { :b , [ ] , nil } assign_one ending MARCO - assign_one have run . Now run the ast in ERTS . after the assign_one [ b : 1 ] 注意这里的输出顺序. 可以看出, 这完全是 ERTS 对字节码执行的结果. 在匿名函数 fun 的定义中: 我们执行了 MACRO-sign_one/2 函数, 它返回了 ast , 这模拟的是 Elixir 编译器对宏的调用. 把 ast 交给 Code.eval_quote 执行. 这是模拟 REST 对字节码的执行. REST 执行字节码后, 会影响 REST 的环境. Code.eval_quote 返回一个二元元组, {value, binding} , value 是 ast 代码运行的最终结果, bingding 表示代码运行后, 环境的状态. 上面的步骤缺少了对 ast 的编译. Code.compile_quote 可以用来编译 ast, 但是如果 ast 对应的代码不是一个模块, 那么 Code.compile_quote 就只是执行这些 ast, 而不是把他们编译为字节码. 并且 Code.compile_quote 还抛弃了执行 ast 对环境造成的影响. 所以, 在 Erlang 的环境中, 没有办法使用 Elixir 宏提供的便利. &amp;#x21A9; 百度百科词条 ≪中文房间≫ &amp;#x21A9; 有关 C 语言宏的图灵完备性的讨论见 https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete","ref":"ch11-macro.html#%E5%AE%8F%E4%B8%8E%E5%87%BD%E6%95%B0","title":"第十一章 如何理解宏 - 宏与函数","type":"extras"},{"doc":"","ref":"ch12-process.html","title":"第十二章 进程","type":"extras"},{"doc":"OTP 平台中, 进程与操作系统的进程不是同一个东西, 它们有许多相同的地方, 比如都是资源的调度单位, 但是 OTP 平台的进程是轻量级的, 比常规编程语言中的线程还轻量. OTP 平台的天然的并发性与服务的自愈等特性, 都是建立在进程上的. 学习 Elixir, 基本语法之外, 更重要的就是对 OTP 平台的学习. 而要理解 OTP, 我们需要首先对 OTP 平台的进程模型有基本的认知. 在 OTP 平台, 进程是执行流和资源的分配单位. 每个进程都有自己的执行流, 自己独立的调用栈和堆内存. 一个进程就是一个函数的执行环境. 当这个函数执行结束的时候, 进程的寿命也就结束了. 为了让进程可以持续的提供服务, 就必须使用递归调用, 在进程函数完成工作结束之前, 调用自己. 递归调用使得进程可以完成服务的工作, 但是这只是第一步, 一个无限循环如果不能从外部接受数据, 并给出回应的话, 除了消耗计算机的电力, 不见得有什么作用. OTP 平台提供了 send(pid,message) 函数向 pid 代表的进程发送信息; receive/1 函数, 在进程内部接受数据. 这样在循环中, 通过 receive/1 接受外部的请求, 处理后通过 send(pid,message) 回应请求, 一个进程就可以向外部提供服务支持. 如果进程启动了, 但是并没有理会其他程序发送的消息, 该如何处理这些消息呢? OTP 平台为每个进程提供了消息队列, 接收到消息后, 首先就是放到消息队列中, 程序执行的过程中, 遇到了 receive/1 语句, 就会对消息队列中的消息迭代 receive/1 方法, 如果消息匹配 receive/1 中模式, 那么这个消息就被消费掉了, 如果消息不匹配, 那么这个消息依旧保留在队列中. 当进程执行结束了, 如果进程中还有消息没有被处理, 这些消息会随着进程的结束而一起被系统归为垃圾. 启动一个进程的是核心模块的 Kernel.spawn(fun) 或 Kernel.spawn(module,fun,args) . receive/1 每次每次都只处理邮箱中的一个消息, 如果没有可以处理的消息, 而且 recieve/1 中没有 after 子句的话, receive/1 会阻塞进程, 等待匹配的消息到来. 如果有 after 子句, 超过指定的时间后, 没有消息进入邮箱的话, receive/1 会跳转到 after 子句, 执行后面的处理逻辑. server_receive = fn this -&gt; { :messages , messages } = Process . info ( self ( ) , :messages ) IO . inspect ( messages , label : &quot;server message box have fellow messages&quot; ) receive do { :add , a , b , client } -&gt; send ( client , { :add , a + b } ) { :sub , a , b , client } -&gt; send ( client , { :sub , a - b } ) { :times , a , b , client } -&gt; send ( client , { :times , a * b } ) { :divs , a , b , client } -&gt; send ( client , { :div , a / b } ) end this . ( this ) end server_fun = fn -&gt; Process . sleep ( 100 ) server_receive . ( server_receive ) end server = spawn ( server_fun ) client = self ( ) send ( server , { :hello , client } ) send ( server , { :add , 0 , 1 , client } ) send ( server , { :sub , 3 , 1 , client } ) send ( server , { :times , 1 , 3 , client } ) send ( server , { :divs , 8 , 2 , client } ) 在上面的代码中, server_fun 在另外一个进程中运行, 进程一启动, 立刻休眠了 100 ms, 这样可以显示出消息队列的变化. 控制台的输出中, 我们可以看到消息队列, 从五个慢慢减少为一个. 匹配消息按照入队的顺序被依次的处理, 不匹配 receive 模式的消息则留在队列中. server message box have fellow messages : [ { :hello , # PID &lt; 0 . 417 . 0 &gt; } , { :add , 0 , 1 , # PID &lt; 0 . 417 . 0 &gt; } , { :sub , 3 , 1 , # PID &lt; 0 . 417 . 0 &gt; } , { :times , 1 , 3 , # PID &lt; 0 . 417 . 0 &gt; } , { :divs , 8 , 2 , # PID &lt; 0 . 417 . 0 &gt; } ] server message box have fellow messages : [ { :hello , # PID &lt; 0 . 417 . 0 &gt; } , { :sub , 3 , 1 , # PID &lt; 0 . 417 . 0 &gt; } , { :times , 1 , 3 , # PID &lt; 0 . 417 . 0 &gt; } , { :divs , 8 , 2 , # PID &lt; 0 . 417 . 0 &gt; } ] server message box have fellow messages : [ { :hello , # PID &lt; 0 . 417 . 0 &gt; } , { :times , 1 , 3 , # PID &lt; 0 . 417 . 0 &gt; } , { :divs , 8 , 2 , # PID &lt; 0 . 417 . 0 &gt; } ] server message box have fellow messages : [ { :hello , # PID &lt; 0 . 417 . 0 &gt; } , { :divs , 8 , 2 , # PID &lt; 0 . 417 . 0 &gt; } ] server message box have fellow messages : [ hello : # PID &lt; 0 . 417 . 0 &gt; ] 接下来, 让通过 IEx.Helpers.flush/0 来查看当前进程接收到的消息. server_receive 函数只能回应四则运算对应的请求, 所以, {:hello, pid} 一直都留在邮箱中. 通过 Process.alive?(pid) , 可以检查一个进程是否还活着. IEx.Helpers . flush ( ) Process . alive? ( server ) |&gt; IO . inspect ( label : &quot;Is server live? Answere&quot; ) { :add , 1 } { :sub , 2 } { :times , 3 } { :div , 4.0 } Is server live? Answere : true 上面的代码输出显示服务进程依旧活着, 那么我们可以继续的向其发送请求. 现在向服务进程发送两个消息. send ( server , { :add , 3 , 4 , client } ) send ( server , { :sub , 5 , 4 , client } ) 控制台输出为: server message box have fellow messages : [ { :hello , # PID &lt; 0 . 417 . 0 &gt; } , { :sub , 5 , 4 , # PID &lt; 0 . 417 . 0 &gt; } ] server message box have fellow messages : [ hello : # PID &lt; 0 . 417 . 0 &gt; ] 进程运行遇到 receive 语句后, 如果没有消息可以匹配 receive 语句中的模式, 那么进程就会暂停. 等向服务器进程发送 {:add,3,4, client} 和 {:sub,5,4,client} 之后, 服务进程立刻匹配了第一个消息; 处理结束后, 进入下一次循环, 输出了第一行. 第二个循环处理 :sub 消息后, 开始下一个循环, 输出了第二行. 至此, 我们已经知道了如何启动一个服务, 如何处理和回应请求. 但是如何停止这个递归调用的服务进程呢? 这里有几种方法, 最常规的就是明确的用函数命令进程退出: Process.exit(pid,reason) . 如果服务程序运行的过程出错了, 自然也是要退出的. 在我们上面的代码中, 执行的四则运算, 四则运算是可能引发错误的. 因此, 通过向服务进程发送不能作四则运算的请求数据, 可以引发服务进程异常退出. 例如像下面这样: send ( server , { :add , :atom , :atom2 , client } ) Process . alive? ( server ) |&gt; IO . inspect ( label : &quot;Is server alive? The answer is&quot; ) 上面的代码说明, 直接把发送消息的接口暴露给客户端, 是非常危险的. 永远不要信任客户的输入. Elixir 中通常的做法是, 客户端的接口, 通过代理函数来完成. 在代理函数中完成对客户输入的检查. 上面的例子, 我们自己定义了一个服务. 我们上面的代码中, 除了我们已经指出的, 把与服务器交互的接口直接暴露给客户端, 容易引发服务进程的奔溃外, 还有一个问题, 服务进程直到死亡, 也没有把 {:hello, pid} 消费掉. 如果我们的进程没有退出, 这个消息将会一直存在于内存空间中, 而且不会被垃圾收集. 如果程序中存在大量这样的垃圾, 最后系统会因为内存不足, 而影响系统. 对于服务程序来说, 一方面, 都需要写 server_fun 这样重复性的框架代码, 另一方面, 每个人写的框架代码多少都会有些不同, 这样对代码的其他阅读者来说, 需要比较多的心智负担. 更加糟糕的是, 如果框架代码没有经过仔细的测试, 像我们上面的例子中那样, 还可能会有这样那样的 bug 存在. OTP 平台在进程的基础上, 做了进一步的抽象, 使我们可以更统一, 规范的写服务相关的代码. Elixir 在 OTP 的基础上, 通过 GenServer 模块, 提供了通用的服务模块的 API. 接下来, 我们学习 GenServer 的用法.","ref":"ch12-process.html#otp-%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%BF%9B%E7%A8%8B","title":"第十二章 进程 - OTP 平台的进程","type":"extras"},{"doc":"GenServer 是一个行为. 它定义了, 8 个回调函数, 9 个和服务交互的辅助函数. 回调回调函数 8 个回调函数, 可以分成以下 4 组: 进程初始化: init(args) 请求处理函数 handle_info(request,state) handle_call(request,from,state) handle_cast(request,state) handle_continue(continue,state) 进程结束时资源清理钩子以及代码热更新钩子 terminate(reason,state) code_change(old_env,state,extra) 状态展示定制函数: format_status(reason, pdict_and_state) 辅助函数 9 个 辅助函数, 可以分成以下几组: 发送请求的辅助函数: GenServer.call GenServer.mutil_call GenServer.cast GenServer.abcast 这四个是对 Kernel.send/2-3 的抽象, 以适应向服务发送请求的通用功能. 启动和结束服务器的函数: GenServer.start GenServer.stat_link GenServer.stop GenServer.start 是对 spawn 的进一步的封装; GenServer.start_link 是对 spawn_link 的封装; 而 GenServer.stop 是对 Process.exit 的抽象. 发送回应的辅助函数: GenServer.reply 是在 send 的基础上, 为发送回应消息而作的封装. 查询服务的函数: GenServer.whereis/1 对应的则是 Process.whereis/1 . 服务进程与状态机 每个 Elixir 服务进程, 可以看作是一个状态机. 状态机是由外部的输入来改变状态的抽象机器. 把 GenServer 看作一个状态机, 用状态图来表示如下: stateDiagram-v2 start_link/1~2 --&gt; init/1 start/1 --&gt; init/1 init/1 --&gt; [*]: `#58;ignore` 或 `{#58;stop, reaseon}` init/1 --&gt; hibernate: 返回 `{#58;ok,state,#58;bibernate}` init/1 --&gt; timeout: `{#58;ok,state,timeout}` timeout --&gt; Loop: `#58;timeout` Loop --&gt; hibernate: 回调函数的返回中包含原子 `#58;hibernate` 且消息队列为空 hibernate --&gt; Loop: 收到消息 init/1 --&gt; Loop: 返回 `{#58;ok,state[,{#58;continue,continue}]}` Loop --&gt; Loop Loop --&gt; terminate/2 terminate/2 --&gt; [*] GenServer.start 和 GenServer.start_link 会启动进程. 它们首先会调用 init/1 回调函数. 根据 init/1 返回类型, 进程可能会进入四个状态: 1) 终止状态; 2) 冬眠状态; 2) 循环状态; 4) 超时. 冬眠状态指的是: 服务的消息队列为空, 服务进程停止执行循环, 开始完成垃圾收集工作. 等新消息被接受后, 服务再次开始循环. 超时状态是指: 当回调函数设置了超时参数后, 在给定的时间内, 消息队列一直都是空的, 这时进程会向自己发送 :timeout 消息, 会触发 回调函数 handle_info . init/1 状态跳转表 init/1 返回值 被触发函数, 或程序状态 返回 {:ok, state} 循环 返回 {:ok, state, timeout} ,且 进程 timeout 毫秒内没有收到消息 进入 timeout 状态, 触发 handle_info 返回 {:ok,state,{:continue, contine}} 触发 handle_continue 返回 {:ok,state,:hibernate} 进程冬眠状态 返回 {:stop, reason} 进程终止 返回 :ignore 进程终止 触发 terminate/2 的行为 terminate/2 用来完成进程所占资源的清理工作, 它会被如下行为触发: 当前进程设置了 :trap_exit ( Process.flag(:trap_exit, ture) , 而父进程发送了退出消息 ( Process.exit(pid,reason) ). GenServer.stop(server,reason) 回调函数 handle_* 返回 第一个元素为 :stop 的元组 回调 返回值 handle_call/3 {:stop, reason, reply, new_state} , {:stop, reason, new_state} handle_cast/2 {:stop, reason :: term, new_state} handle_info/2 {:stop, reason :: term, new_state} handle_continue/2 {:stop, reason :: term(), new_state} 回调函数引发异常 ( raise/2 ), 或者退出 ( exit/1 ) 回调函数返回的非法的值 需要注意的是 init/1 并不会触发 terminate/2 . Loop 节点 stateDiagram-v2 Loop Loop --&gt; info: send/send_after Loop --&gt; cast: GenServer.cast/abcast Loop --&gt; call: GenServer.call/muti_call Loop --&gt; continue: init/1 返回 `{#58;ok, state, #58;continue}` Loop --&gt; [*] call --&gt; continue call --&gt; Loop call --&gt; [*] info --&gt; continue info --&gt; Loop info --&gt; [*] continue --&gt; continue continue --&gt; Loop continue --&gt; [*] cast --&gt; continue cast --&gt; Loop cast --&gt; [*] 循环节点是我们的主节点. 用来处理接受到的消息和改变系统的状态. 循环状态中有四个子状态, cast , call , info 和 continue . 对应四种 回调函数 handle_* . handle_call/3 状态变化 GenServer.call/2-3 或 GenServer.multi_call/4 调用会触发 handle_call/3 . 根据 handle_call/3 的返回值不同, 服务的状态变化表如下: handle_call/3 返回值 服务状态 {:reply, reply, new_state} 以 reply 回应请求, 服务的 state 改变, 继续循环. {:reply, reply, new_state, timeout} 以 reply 回应请求, 服务的 state 改变, 如果 timeout 毫秒内没有消息进来, 进程进入 timeout 状态. {:reply, reply, new_state, :hibernate} 以 reply 回应请求, 服务的 state 改变, 如果消息队列空了, 进程进入冬眠状态 {:reply, reply, new_state, {:continue, term}} 以 reply 回应请求, 服务的 state 改变, 处理下一个消息前, 继续执行 handle_continue 回调 {:noreply, new_state} 更新状态, 不回应求情 1 {:noreply,new_state, timeout} 更新状态, 不回应请求 2 , timeout 毫秒内没有新消息进来, 进程进入 timeout 状态 {:stop, reason, reply, new_state} 以 reply 回应请求, 进程的 state 改变, 服务进入 terminate 状态, terminate/2 被触发 {:stop, reason, new_state} 进程 state 改变, 服务进入 terminate/2 被触发. handle_cast/2 状态变化 GenServer.cast/2 或 GenServer.abcast/2 会触发 handle_cast/2 回调函数. 根据 handle_cast/2 返回值的不同, 进程的状态变化如下表: handle_cast/2 的返回值 服务状态 {:noreply, new_state} 进程的 state 改变, 进入循环, 等待处理下一个消息. {:noreply, new_state, timeout} 进程的 state 改变, 如果 timeout 毫秒内, 消息对立依旧为空, 进程进入冬眠模式 {:noreply, new_state,:hibernate} 进程的 state 改变, 如果消息对立为空, 进程进入冬眠状态 {:noreply, new_state,{:continue, term}} 进程的 state 改变, 在处理其他消息之前, 继续执行 handle_continue {:stop, reason :: term, new_state} 进程的 state 改变, 服务进入 terminate 状态, terminate/2 会被触发 handle_info/2 状态 GenServer.cast , GenServer.abcast , GenServer.call , 和 GenServer.muti_call 之外的方法发送给进程的消息, 都会触发 handle_info 回调函数. 具体来说, 以下方法的调用都会触发相应的服务的 handle_info/2 回调函数: Kernel.send/2 Process.send/3 Process.send_after/3 当服务处于 timeout 状态时, 会向进程自己发送 :timeout 消息. 根据 handle_info/2 返回值的不同, 服务的状态变化有下表表示. handle_info/2 的返回值 服务状态 {:noreply, new_state} 进程 state 改变 {:noreply, new_state, timeout} 进程 state 改变, 如果 timeout 毫秒内, 服务的消息队列中依旧为空, 服务进入 timeout 状态 {:noreply, new_state, :hibernate} 进程 state 改变, 如果服务的消息队列为空, 进程进入冬眠状态. {:noreply, new_state, {:continue, term}} 进程 state 改变, 在处理其他消息之前, 继续执行 handle_continue 回调函数 {:stop, reason :: term(), new_state} 进程 state 改变, 进程进入终止状态, terminate/2 会被调用 超时 当回调的返回值中有超时设置时, 服务进程在指定的时间时间内没有收到新的小时候, 服务进程就会进入超时状态, 这时 handle_info 回调会被触发, 收到 :timeout 消息. 回调函数返回值触发超时状态, 可以用以下表总结. 回调函数 返回值 init/1 {:ok,state,timeout} handle_info/2 {:noreply,new_state,timeout} handle_cast/2 {:noreply,new_state,timeout} handle_call/3 {:reply, new_state, reply, timeout} 或 {:noreply,new_state, timeout} handle_continue/2 {:noreply, new_state,timeout} new_state 表示服务进程新的状态, timeout 时正整数表示的超时时间, 单位为毫秒. handle_continue/2 回调函数 回调函数的返回值中含有 :continue 原子的时候, 会触发 handle_continue/2 回调. handle_continue/2 总是在 handle_* 调用之后立即被调用的, 而不是在下一个的循环中被调用. 触发 handle_continue/2 的其他回调函数的返回情况如下: 回调函数 返回值 handle_call/3 {:reply, reply, new_state, {:continue, term}} handle_cast/2 {:noreply, new_state,{:continue, term}} handle_info/2 {:noreply, new_state, {:continue, term}} handle_continue/2 {:noreply, new_state, {:continue, term()}} handle_continue/2 返回值, 以及引发的服务状态由下表表示: handle_continue/2 返回值 状态 {:noreply, new_state} 修改进程状态 {:noreply, new_state, timeout} 修改进程状态, 如果 timeout 毫秒内, 消息队列依旧为空, 服务进入超时状态, 触发 handle_info {:noreply, new_state,:hibernate} 修改进程状态, 如果消息队列依旧为空, 服务进入冬眠状态 {:noreply, new_state, {:continue, term}} 继续执行 handle_continue/2 子句","ref":"ch12-process.html#genserver-api","title":"第十二章 进程 - GenServer API","type":"extras"},{"doc":"GenServer Elixir 为我们提供的最重要的抽象. 在 GenServer 的基础上, Elixir 还未我们提供了如下的模块: Task 使用进程来完成异步计算 Agent 使用服务进程来保存状态 OTP 的自愈特性, 是基于对进程的监督和重启的. Supervisor 模块是一个行为, 用来帮助我们写出一致的管理者进程. DynamicSupervisor 模型是一个行为, 用来帮助我们些出一致的动态管理者进程. Application 模块是一个行为, 用来帮助我们统一启动进程数的格式和代码. 后面的章节, 会对这些模块作一一介绍. &amp;#x21A9; 要想在后续的代码中回应进程, 必须把 handle_call/3 的第二个参数保存到状态中, 在后续的代码中处理后, 可以通过 GenServer.reply/2 来回应客户的请求. &amp;#x21A9; 同注释1.","ref":"ch12-process.html#%E5%9F%BA%E4%BA%8E-genserver-%E7%9A%84%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97","title":"第十二章 进程 - 基于 GenServer 的其他模块","type":"extras"},{"doc":"","ref":"chx-cold_knowledge.html","title":"附录 冷知识","type":"extras"},{"doc":"在阅读 Elixir 文档的 ≪ 类型规范•内建的类型 ≫ 小节中, 我发现了一个以前没有注意到的知识: Elixir 中函数参数个数的限制. arity() 定义为 0..255 . 这是说, 我们的函数参数个数最多 255个吗? 要写一个有 255 个变量的函数, 这还真的是个体力活. 但是作为程序员, 对于这种重复性体力劳动, 当然要用编程的方式来完成了. Elixir 提供了 Code.compile_string/1 和 Code.eval_string/1 函数, 可以把他们看作是 Elixir 语言为我们提供的编译器和解释器的 API. 我们可以使用这两个函数编译或解释执行对应 Elixir 代码. 通过调整生成的函数参数的个数, 可以找到函数参数个数的上限的设定. defmodule Explore.Arity do defp generate_code ( arity , name_fun? ) do params_list = 1 .. arity |&gt; Enum . map ( &amp; &quot;p \#{ &amp;1 } &quot; ) params_src = Enum . join ( params_list , &quot;,&quot; ) body_src = Enum . join ( params_list , &quot; + &quot; ) if name_fun? do &quot;&quot;&quot; defmodule A do def test( \#{ params_src } ) do \#{ body_src } end end &quot;&quot;&quot; else &quot;fn \#{ params_src } -&gt; \#{ body_src } end&quot; end end @default_opt [ fun_named? : false , compiled? : true ] def check ( arity , opt \\\\ [ ] ) do opt = Keyword . merge ( @default_opt , opt ) src = generate_code ( arity , opt [ :fun_named? ] ) if opt [ :compiled? ] do Code . compile_string ( src ) else Code . eval_string ( src ) end rescue v -&gt; error_tip = if opt [ :compiled? ] , do : &quot;compile error&quot; , else : &quot;praser error&quot; IO . inspect ( v , label : error_tip ) :bad else v -&gt; IO . inspect ( v , label : &quot;check done&quot; ) :ok end end 让我们用单元测试功能来完成我们探索. 用代码, 能更清楚地表达我的意图. ExUnit . start ( auto_run : false ) defmodule ArityTest do use ExUnit.Case , async : true alias Explore.Arity test &quot;the uplimit of arity for anonymous function in complier &quot; do assert Arity . check ( 255 ) == :ok assert Arity . check ( 256 ) == :bad IO . puts ( &quot;&quot; ) end test &quot;the uplimit of arity for named function in complier &quot; do assert Arity . check ( 255 , fun_named? : true ) == :ok assert 1 .. 255 |&gt; Enum . sum ( ) == apply ( A , :test , Enum . to_list ( 1 .. 255 ) ) assert Arity . check ( 256 , fun_named? : true ) == :ok assert_raise UndefinedFunctionError , fn -&gt; apply ( A , :test , Enum . to_list ( 1 .. 256 ) ) end IO . puts ( &quot;&quot; ) end test &quot;the uplimit of arity for anonymous function in parser&quot; do assert Arity . check ( 20 , compiled? : false ) == :ok assert Arity . check ( 21 , compiled? : false ) == :bad IO . puts ( &quot;&quot; ) end test &quot;the uplimit of arity for named function in parser&quot; do assert Arity . check ( 20 , fun_named? : true , compiled? : false ) == :ok assert apply ( A , :test , 1 .. 20 |&gt; Enum . to_list ( ) ) == 1 .. 20 |&gt; Enum . sum ( ) assert Arity . check ( 21 , fun_named? : true , compiled? : false ) == :ok assert_raise UndefinedFunctionError , fn -&gt; A . test ( Enum . to_list ( 1 .. 21 ) ) end IO . puts ( &quot;&quot; ) end end ExUnit . run ( ) 通过上面的实验, 可以得出以下结论: 在编译器中 对于匿名函数, 参数个数多于 255 个, 编译器报 UndefineFuntionError 对于命名函数, 参数个数多于 255 个, 编译器并不报错, 但是调用这个函数, 运行时会产生 UndefineFuntionError 在解析器中 对于匿名函数, 参数个数多于 20 个, 解释器就会报 UndefinedFunctionError 对于命名函数, 参数个数多于 20 个, 解释器不会报错, 但是调用这个函数, 运行时会产生 UndefineFunctionError","ref":"chx-cold_knowledge.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0","title":"附录 冷知识 - 函数参数个数","type":"extras"},{"doc":"BEAM 中原子个数上限默认为: 1048577. 原子的内存长度是固定的. 原子占用系统一个字 (word) 长度的内存. 原子内容最长可以有 255 个字符. 现在有提议对原子也做垃圾收集, 也许以后的 BEAM 实现, 原子个数上限就会被解除, 那么对于嵌入式的系统, 用原子来代替比较长的字符串可以达到节省内存的目的. ExUnit . start ( auto_run : false ) defmodule AtomLimitTest do use ExUnit.Case , async : true test &quot;255 byte long atom is ok&quot; do assert 1 .. 255 |&gt; Enum . map ( fn _ -&gt; &quot;1&quot; end ) |&gt; Enum . join ( &quot;&quot; ) |&gt; String . to_atom ( ) end test &quot;256 byte long auto is up the atom limit&quot; do assert_raise SystemLimitError , fn -&gt; 1 .. 256 |&gt; Enum . map ( fn _ -&gt; &quot;2&quot; end ) |&gt; Enum . join ( &quot;&quot; ) |&gt; String . to_atom ( ) end end end ExUnit . run ( ) 调用 :eralng.memory(:atom_used) 可以看出当前我们的系统中, 原子使用的内存.","ref":"chx-cold_knowledge.html#%E5%8E%9F%E5%AD%90","title":"附录 冷知识 - 原子","type":"extras"},{"doc":"变量名实际上也是原子, 所以变量名接受原子的限制, 也就是说变量名不能长于 255 个字符, 但是实际上, 系统对变量还有一些限制, 在 Elixir 中表示变量的原子有统一的格式: _{var_name}@1 . 所以, 变量名只能由 255-3 = 252 个字节长度. 我们可以通过下面的代码来得出这个结论. create_var = fn l -&gt; 1 .. l |&gt; Enum . map ( fn _a -&gt; &quot;l&quot; end ) |&gt; Enum . join ( &quot;&quot; ) end var = create_var . ( 252 ) assign = &quot; \#{ var } = 1&quot; { 1 , _ } = Code . eval_string ( assign ) IO . puts ( &quot;variable length equal 252 is ok&quot; ) var = create_var . ( 253 ) assign = &quot; \#{ var } = 1&quot; Code . eval_string ( assign )","ref":"chx-cold_knowledge.html#%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E9%99%90%E5%88%B6","title":"附录 冷知识 - 变量名的限制","type":"extras"},{"doc":"可以在 def/2 上下文中定义模块: defmodule EmbedModuleToFun do def createFun ( ) do defmodule :_ do def hello ( ) , do : IO . puts ( &quot;I am in \#{ __MODULE__ } , hello!&quot; ) end |&gt; elem ( 1 ) end end m = EmbedModuleToFun . createFun ( ) m . hello ( ) 这让我想起来 Java 的匿名类. Java 的早期版本中, 不支持匿名函数类型, 所以在当初要在 Java 中模拟函数式编程, 定义高阶函数的时候就不得不使用接口. 使用这些高级函数的时候, 往往用一个匿名类来实现相应的接口. 我们这里使用的方法, 和当年 Java 中使用的方法是一样的. 但是使用这个方法的时候, 还有需要注意的地方. 首先本质上, 这个方法是在运行时动态编译了新模块. 所以每次调用 createFun() 都会产生新的模块, 这就意味着: 1) 效率下降, 2) 如果需要在多个函数中返回模块, 必须留意为函数返回的模块取不同的名字, 以防止名称冲突. 我们可以写一个宏来解决这两个问题. defmodule Nest do import Kernel , except : [ def : 2 ] defmacro def ( call , exp ) do if __CALLER__ . function == nil do raise &quot;Nest.def must cal in def/2&quot; end { name , args } = name_and_args ( call ) str = &quot; \#{ __CALLER__ . module } .nest_ \#{ name } _ \#{ length ( args ) } &quot; module_name = String . to_atom ( str ) make_module ( module_name , call , exp ) end defp name_and_args ( { :when , _ , [ { name , _ , args } , _ ] } ) , do : { name , args } defp name_and_args ( { name , _ , args } ) , do : { name , args } defp make_module ( module_name , call , exp ) do quote do if :code . is_loaded ( unquote ( module_name ) ) do unquote ( module_name ) else defmodule unquote ( module_name ) do IO . puts ( &quot;Compile \#{ unquote ( module_name ) } &quot; ) def unquote ( call ) , unquote ( exp ) end |&gt; elem ( 1 ) end end end end 当我们在 LiveBook 中运行下面的测试代码的时候, 如果是第一次运行, 那么第 10 行的的输出之前, 控制台中应该先输出, 编译内部模块的提示: &quot;Compile Elixir.TestNest.nest_hello_2&quot;, 但是第 11 行再次调用 TestNest.hello() 的时候, 不再输出模块编译的提示了, 这说明的确不是每次调用 TestNest.hello() 都创建新的模块. defmodule TestNest do require Nest def hello ( ) do Nest . def ( hello ( a , b ) , do : a + b ) end end 3 = TestNest . hello ( ) . hello ( 1 , 2 ) IO . puts ( &quot;-----------&quot; ) 3 = TestNest . hello ( ) . hello ( 1 , 2 ) 在 LiveBook 中, 一旦上面的代码计算过一次此后, 再次运行的话, 因为内部模块已经被加载到系统中了, 所以控制台中, 只会有第 10 行的输出, 而不能再看到内部模块的编译提示. 这让我意识到, Erlang 中不是只有进程可以保存状态, 系统内模块的状态结合动态编译, 也可以用来表示状态. 当然了这样做有非常大的效率成本. 但作为理论探索, 不失为一个有趣的话题.","ref":"chx-cold_knowledge.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97","title":"附录 冷知识 - 函数中定义模块","type":"extras"},{"doc":"在 Erlang 和 Elixir 中, 最常用的保持状态的方法是启用一个服务进程. 但是 Erlang 的运行时系统, 自身是有状态的. Erlang 允许在运行时, 动态生成代码. 运行时动态生成的代码改变了 Erlang 运行时的模块的状态. 如果我们把状态信息, 直接保存到模块的元数据中, 在需要改变状态的时候, 重新产生模块, 且以新的状态来设置新产生的模块, 那么外部看来, 这个模块就像一个保有状态的对象一样. defmodule Corner.State do def create ( kv \\\\ [ ] ) do if Keyword . keyword? ( kv ) do now = NaiveDateTime . utc_now ( ) |&gt; to_string ( ) |&gt; String . to_atom ( ) module = Module . concat ( __MODULE__ , now ) make_nest_module ( kv , module ) else raise &quot;Expect a keyword, but get : \#{ inspect ( kv ) } &quot; end end defmacro delete ( module ) do if :code . delete ( module ) do quote do var! ( unquote ( module ) , __CALLER__ ) = nil true end else false end end def set ( module , k , v ) do kv = module . module_info ( :attributes ) |&gt; Enum . filter ( &amp; ( elem ( &amp;1 , 0 ) != :vsn ) ) |&gt; Enum . map ( fn { k , [ v ] } -&gt; { k , v } end ) |&gt; Keyword . merge ( [ { k , v } ] ) make_nest_module ( kv , module ) end defp make_nest_module ( kv , module ) do blocks = make_geter_and_seters ( module , kv , [ ] ) quote do defmodule unquote ( module ) do unquote_splicing ( blocks ) def delete ( ) , do : :code . delete ( unquote ( module ) ) end end |&gt; Code . eval_quoted ( ) |&gt; elem ( 0 ) |&gt; elem ( 1 ) end defp make_geter_and_seters ( _module , [ ] , acc ) , do : acc defp make_geter_and_seters ( module , [ { k , v } | rest ] , acc ) do attr = make_attr ( k , v ) geter = quote do : def ( unquote ( k ) ( ) , do : unquote ( v ) ) seter = quote do def unquote ( k ) ( v ) , do : Corner.State . set ( unquote ( module ) , unquote ( k ) , v ) end make_geter_and_seters ( module , rest , [ attr , geter , seter | acc ] ) end defp make_attr ( k , v ) do [ quote do Module . register_attribute ( __MODULE__ , unquote ( k ) , persist : true ) end , { : @ , [ context : Elixir , import : Kernel ] , [ { k , [ context : Elixir ] , [ v ] } ] } ] end end 我们可以使用 h = Corner.State.create([x: 1]) 来创建一个状态. 并使用 s.x 读取 x 的值, s.x(new_value) 更新 x 的值. import Corner.State s = create ( x : 2 , y : 0 ) s . x |&gt; IO . inspect ( label : :x ) s . y |&gt; IO . inspect ( label : :y ) s . x ( 0 ) s . x |&gt; IO . inspect ( label : :x ) delete ( s ) s |&gt; IO . inspect ( )","ref":"chx-cold_knowledge.html#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E5%A4%96%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81","title":"附录 冷知识 - 进程之外的状态保持","type":"extras"},{"doc":"Elixir 的 receive 结构中支持 after 子句来处理超时问题. after_sent 也可以在指定的时间后向进程发送消息. 这些功能背后使用的都是相同的机制, Elixir 中整数是可以无限大的, 但是表示超时的参数却不能这样, 而是有限制的. 在 Elixir 中, 如果是一个正整数, 那么这个正整数, 必须小于等于 32 位可表示的最大无符号整数, 也就是 $2^{33}-1$ (或十六进制表示: 0xFFFF_FFFF). 让我们实验一下: receive do a -&gt; IO . inspect ( a , label : &quot;a&quot; ) after 0xFFFF_FFFF + 1 -&gt; IO . put ( &quot;timeout&quot; ) end","ref":"chx-cold_knowledge.html#%E8%B6%85%E6%97%B6","title":"附录 冷知识 - 超时","type":"extras"},{"doc":"在模块外, 调用一个模块的函数, 实际上使用的都是远程调用. 但是在 defmodule/2 的上下文中, 私有函数和公开函数都可以使用本地调用的语法来调用. 原来我一直以为, 在 defmodule/2 上下文中, 对模块内的函数, 使用远程调用的语法没有意义. 但是这是错误的. 当代码发生热加载的时候, 在 defmodule/2 上下文中, 远程调用和本地调用之间的差别就显示出来了. Erlang 中热加载是这样实现的: 系统会为每个模块保持两个最新的版本. 假设有两个进程P1, P2; P1 运行的是第一个版本的代码, P2 运行的是第二个版本的代码. 当模块的第 3 个版本被加载到系统后, 第一个版本的代码, 就会从系统中被删除掉, 这是, 如果有进程还在运行第一个版本的代码, 就会因为找不到对应的模块, 而被杀死. 如果被杀死的 P1 运行在监管树下, 那么监控进程会创建新的进程 P3 代替死亡的 P1, 这时 P3 中运行的是第三个版本的代码. 至此, 和远程函数调用还没有关系. 这样的热更新, 导致了进程 P1 退出, 所以还是有风险的. 如果代码更新后, 还在运行的进程可以自动的切换到最新的版本的代码中, 那么热更新的风险就更小了. 要达到这种效果, 在服务器进程的循环函数中, 最后对自己的递归调用, 就必须使用远程调用的语法. 远程调用语法, 调用的都是模块的最新版本的代码. 下面让我们用代码来实验一下. 首先, 定义第一个版本. 在 loop/0 递归调用自己的时候, 使用的是本地函数调用的语法: loop() . 模块编译完成后, 立刻启东进程 p1 运行这个版本. defmodule RemoteAndLocalCall do def loop ( ) do receive do :ok -&gt; IO . puts ( &quot; \#{ inspect ( self ( ) ) } version1&quot; ) Process . send_after ( self ( ) , :ok , 100 ) loop ( ) :stop -&gt; IO . puts ( &quot;stop version1&quot; ) end end end p1 = spawn ( &amp; RemoteAndLocalCall . loop / 0 ) |&gt; IO . inspect ( label : &quot;p1&quot; ) 然后我们定义第二个版本, 这里, loop/0 对自己递归调用的时候, 使用的是远程函数调用的语法: __MODULE__.loop() . 模块编译后, 我们启动进程 p2 来运行我们的代码. 这时 p1 和 p2 都在等待消息进来. 所以, 通过向他们分别发送一个 :ok 消息来启动这两个进程的循环. 这时控制台中会交替的输出 &quot;PID{} version1&quot;, &quot;PID{} version2&quot;. defmodule RemoteAndLocalCall do def loop ( ) do receive do :ok -&gt; IO . puts ( &quot; \#{ inspect ( self ( ) ) } version2&quot; ) Process . send_after ( self ( ) , :ok , 100 ) __MODULE__ . loop ( ) :stop -&gt; IO . puts ( &quot;stop version2&quot; ) end end end p2 = spawn ( &amp; RemoteAndLocalCall . loop / 0 ) |&gt; IO . inspect ( label : &quot;p2&quot; ) Process . alive? ( p1 ) |&gt; IO . inspect ( label : &quot;Is v1 alive?&quot; ) for p &lt;- [ p1 , p2 ] do send ( p , :ok ) end 最后, 定义第三个版本, 模块编译通过后会发现: 进程 p1 死亡了. 进程 p2 还活着, 但是其中运行的代码更新了. 控制台输出变成了 PID{} version3 . defmodule RemoteAndLocalCall do def loop ( ) do receive do :ok -&gt; IO . puts ( &quot; \#{ inspect ( self ) } version3&quot; ) Process . send_after ( self , :ok , 100 ) __MODULE__ . loop ( ) :stop -&gt; IO . puts ( &quot;stop version3&quot; ) end end end Process . alive? ( p1 ) |&gt; IO . inspect ( label : &quot;Is v1 live?&quot; ) Process . alive? ( p2 ) |&gt; IO . inspect ( label : &quot;Is v2 live?&quot; ) IO . inspect ( p2 , label : &quot;P2&quot; ) 最后运行下面的代码, 退出进程 p2. send ( p2 , :stop )","ref":"chx-cold_knowledge.html#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%92%8C%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8","title":"附录 冷知识 - 远程调用和本地调用","type":"extras"}]