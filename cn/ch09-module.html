<!DOCTYPE html>
<html lang="encn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="The Corner of Elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第九章 模块 — The Corner of Elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-1785d4c7ff.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="https://keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
The Corner of Elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch09.module.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第九章 模块</span>
</h1>

<h2 id="模块概念" class="section-heading">
  <a href="#模块概念" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模块概念</p>
  </a>
  模块概念
</h2>
<p>在 Elixir 中, 说到模块的时候, 可以指以下三个相关的概念:</p><ol><li><a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 这个宏</li><li><a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 这个 Elixir 模块</li><li>源码编译后的 <code class="inline">.beam</code> 文件</li></ol><p>这三个概念当然是相互联系的, 但是又是三个不同的实体.</p><p><code class="inline">.beam</code> 是最后 Erlang 运行环境用来加载的单位,
 当我们要讨论虚拟机如何使用模块的时候, 我们指的往往是这个意义上的模块.</p><p><a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 是 Elixir 标准库中提供的一个模块,
 它提供了一系列函数, 可以用来帮助我们更好的定义自己的模块.</p><p><a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 是一个宏, 用来定义模块. 可以认为对 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 宏的调用,
就是要求 Elixir 编译器把传递给这个宏的参数, 转化为 Erlang 的字节码.</p><p>这里我使用 <em><a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 上下文</em> 或 <em>函数定义时</em>,
表示表达式 <code class="inline">defmodule Name, do: ...</code> 中 <code class="inline">...</code> 代表的代码的情形.</p><p>而 <em>模块中/内</em>, 表示对 <code class="inline">.beam</code> 文件结构或其加载后, 在内存中分布方式的讨论.</p><h2 id="模块属性" class="section-heading">
  <a href="#模块属性" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模块属性</p>
  </a>
  模块属性
</h2>
<p>Erlang 中, 模块和 <code class="inline">.beam</code> 文件之间的关系是非常的明确的.
模块这个概念, 在源码层面对应的就是一个 Erlang 源文件(.erl),
而在字节码层面, 对应的就是一个 <code class="inline">.beam</code> 文件.
Erlang 的一个源文件 (.erl) 编译后对应一个 <code class="inline">.beam</code> 文件.</p><p>所以模块的概念, 在 Erlang 中, 几乎可以和代码文件来对换.</p><p>而模块属性的作用在 Erlang 中也非常的清晰, 就是告诉编译器,
如何来填充 <code class="inline">.beam</code> 文件的相关段落 (chunk) 的.</p><p>在 Erlang 中, 大部分属性和 <code class="inline">.beam</code> 段落名之间是有直接对应关系的,
还有一部分属性有多个值, 比如 <code class="inline">-callback</code>, 这些值集合到一起,
放在一个段落中的. 用户自定义的属性, 与 <code class="inline">-vsn</code> 一起记录到 <code class="inline">attributes</code> 段落中.</p><p>其实不用关心属性是记录在字节码的什么段落中,
只要理解这些内容都是要反应到模块中的, 就能很好的理解 Erlang 中模块属性了.</p><p>例如下面的 Erlang 代码</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">module</span><span class="p" data-group-id="8114472788-1">(</span><span class="ss">hello</span><span class="p" data-group-id="8114472788-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="8114472788-2">(</span><span class="p" data-group-id="8114472788-3">[</span><span class="ss">say_hi</span><span class="p">/</span><span class="mi">1</span><span class="p">,</span><span class="ss">say_bye</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="8114472788-3">]</span><span class="p" data-group-id="8114472788-2">)</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>不难推测出, <code class="inline">.beam</code> 文件中, 记录模块名的位置上记录的内容一定就是 <code class="inline">hello</code>.
而记录模块导出函数的段落中, 一定有 <code class="inline">say_hi</code> <code class="inline">say_bye</code> 这样的内容.</p><p>上面的 Erlang 代码, 对应的 Elixir 代码应该是这样的:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="ss">:hello</span><span class="w"> </span><span class="k" data-group-id="3044153138-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">say_hi</span><span class="p" data-group-id="3044153138-2">(</span><span class="n">a</span><span class="p" data-group-id="3044153138-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">say_bye</span><span class="p" data-group-id="3044153138-3">(</span><span class="n">a</span><span class="p" data-group-id="3044153138-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="3044153138-1">end</span></code></pre><p>Elixir 中, 源文件和字节码文件之间不再是一一对应关系, 而且模块属性的内容,
分散源码的所有地方, 而不是像 Erlang 那样集中到文件的头部.
所以从 Elixir 代码来理解模块属性, 就不那么直观了.</p><h3 id="内建属性" class="section-heading">
  <a href="#内建属性" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">内建属性</p>
  </a>
  内建属性
</h3>
<table><thead><tr><th style="text-align: left;">Erlang 预定义的属性示例</th><th style="text-align: left;">意义</th><th style="text-align: left;">Elixir对应语法结构</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">-module(MODULE_NAME)</code></td><td style="text-align: left;">设置模块的名字</td><td style="text-align: left;"><a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a></td></tr><tr><td style="text-align: left;"><code class="inline">-export(Functions)</code></td><td style="text-align: left;">模块中导出函数</td><td style="text-align: left;"><code class="inline">def</code></td></tr><tr><td style="text-align: left;"><code class="inline">-import(Module,Functions)</code></td><td style="text-align: left;">导入其他模块中的函数</td><td style="text-align: left;"><code class="inline">import Module, only: [Functions]</code></td></tr><tr><td style="text-align: left;"><code class="inline">-compile(Options)</code></td><td style="text-align: left;">模块中指定编译选项</td><td style="text-align: left;"><code class="inline">@compile([options])</code></td></tr><tr><td style="text-align: left;"><code class="inline">-vsn(Vsn)</code></td><td style="text-align: left;">模块版本</td><td style="text-align: left;"><code class="inline">@vsn(&quot;VSN&quot;)</code></td></tr><tr><td style="text-align: left;"><code class="inline">-on_load(Function)</code></td><td style="text-align: left;">指定模块加载时调用的函数名</td><td style="text-align: left;"><code class="inline">@on_load ...</code></td></tr><tr><td style="text-align: left;"><code class="inline">-nifs(Functions)</code></td><td style="text-align: left;">指定了模块中定义的哪些函数, 可能会被作为外部语言接口 (NIF) 使用 <code class="inline">erlang:load_nif/2</code> 加载</td><td style="text-align: left;">(?TODO?)</td></tr><tr><td style="text-align: left;"><code class="inline">-behaviour(Behaviour)</code></td><td style="text-align: left;">指定模块实现了行为(Behaviour).</td><td style="text-align: left;"><code class="inline">@behaviour</code> <code class="inline">@impl</code></td></tr><tr><td style="text-align: left;"><code class="inline">-callback Name(Argument) -&gt; Result.</code><a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a></td><td style="text-align: left;">定义 Behaveiour 的回调函数</td><td style="text-align: left;"><code class="inline">@callback function_spec</code></td></tr><tr><td style="text-align: left;"><code class="inline">-record(Record, Fields).</code></td><td style="text-align: left;">定义记录</td><td style="text-align: left;">Record 模块中的 <code class="inline">defrecord</code></td></tr><tr><td style="text-align: left;"><code class="inline">-include(&quot;SomeFile.hrl&quot;).</code></td><td style="text-align: left;">包含预处理</td><td style="text-align: left;"><code class="inline">require</code></td></tr><tr><td style="text-align: left;"><code class="inline">-define(Macro, Replacement).</code></td><td style="text-align: left;">定义宏</td><td style="text-align: left;"><code class="inline">defmacro</code>, <code class="inline">defmacrop</code></td></tr><tr><td style="text-align: left;"><code class="inline">-file(File,Line)</code></td><td style="text-align: left;">修改了预定义的宏 <code class="inline">?File</code> 和 <code class="inline">?Line</code> 的值.</td><td style="text-align: left;"><code class="inline">__ENV__.file</code>, <code class="inline">__ENV__.line</code>, <code class="inline">@file</code></td></tr><tr><td style="text-align: left;"><code class="inline">-type my_type() :: other_have_defined_type()</code></td><td style="text-align: left;">类型定义</td><td style="text-align: left;"><code class="inline">@type my_type() :: other_have_define_type()</code></td></tr><tr><td style="text-align: left;"><code class="inline">-spec function(type()) -&gt; return_type()</code></td><td style="text-align: left;">为 <code class="inline">function</code> 指定规范</td><td style="text-align: left;"><code class="inline">@spec spec function(type()) -&gt; return_type()</code></td></tr></tbody></table><p>较旧的 Erlang 版本的不支持 <code class="inline">-callback</code> 模块属性, 而通过定义导出函数
<code class="inline">behviour_info/1</code> 来定义行为. 就像下面的代码这样.</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="8852039379-1">(</span><span class="p" data-group-id="8852039379-2">[</span><span class="ss">behaviour_info</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="8852039379-2">]</span><span class="p" data-group-id="8852039379-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
</span><span class="nf">behaviour_info</span><span class="p" data-group-id="8852039379-3">(</span><span class="ss">callback</span><span class="p" data-group-id="8852039379-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="p" data-group-id="8852039379-4">[</span><span class="p" data-group-id="8852039379-5">{</span><span class="ss">func1</span><span class="p">,</span><span class="w"> </span><span class="n">Arity1</span><span class="p" data-group-id="8852039379-5">}</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="8852039379-4">]</span><span class="p">;</span><span class="w">
</span><span class="nf">behaviour_info</span><span class="p" data-group-id="8852039379-6">(</span><span class="p">_</span><span class="p" data-group-id="8852039379-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">undefined</span><span class="p">.</span></code></pre><p>Elixir 中与 Erlang 对应的内建模块属性, 除了 <strong>模块, 函数, 宏,
结构以及记录</strong> 的定义是使用特定的宏外, 其他的模块属性都使用 <code class="inline">@</code> 的语法.</p><p>编程语言中, 以 <code class="inline">@</code> 作为语法结构的, 除了 Elixir 的模块属性外, 还有别的几种用法,
而且这几种用法在 Elixir 中, 某种程度上, 也都可以由模块属性来提供.</p><p>也就是, 模块属性在 Elixir 中不再只是用来记录字节码的元数据了,
还承担了其他的语法功能, 这就更进一步的加大了, 我对 Elixir 模块和模块属性,
这两个概念的理解的困难.</p><h2 id="elixir-中模块属性承担的语法功能" class="section-heading">
  <a href="#elixir-中模块属性承担的语法功能" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">elixir-中模块属性承担的语法功能</p>
  </a>
  Elixir 中模块属性承担的语法功能
</h2>
<p>Elixir 的模块属性, 我认为至少对应三种其他语言的功能:</p><ol><li>Java 的注解.</li><li>Python 的修饰器</li><li>Ruby 的实例与类属性</li></ol><h3 id="java-注解-anotation" class="section-heading">
  <a href="#java-注解-anotation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">java-注解-anotation</p>
  </a>
  Java 注解(Anotation)
</h3>
<p>Java 中使用注解语法, 为代码添加元数据.
Elixir 中, 以下的模块属性用来完成类似的工作.
<code class="inline">@deprecated</code>, <code class="inline">@moduledoc</code>,<code class="inline">@doc</code>, <code class="inline">@impl</code>,<code class="inline">@typedoc</code>. 但是这里的语法稍微不同.
例如下面两个片段都是表明 <code class="inline">parser</code> 这个函数被废弃了:</p><pre><code class="java">@Deprecated
int parser(String str){
  ....
}</code></pre><p>对应的 Eixir 中的代码是:</p><pre><code class="makeup elixir" translate="no"><span class="na">@deprecated</span><span class="w"> </span><span class="s">&quot;Use `String.parser/1` replace.&quot;</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">parser</span><span class="p" data-group-id="1102294157-1">(</span><span class="n">str</span><span class="p" data-group-id="1102294157-1">)</span><span class="w"> </span><span class="k" data-group-id="1102294157-2">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="1102294157-2">end</span></code></pre><p>除了字母大小写的不同外, 需要注意的是, Elixir 的模块属性是必须有对应的属性值的;
Java 的注解一般不需要参数, 因为注解的作用对象就是其后的代码或字段.
Java 的注解只是表明了, 后面的 API 被遗弃了, 之于应该用那个新的 API 来代替,
只能靠文档来补充了. Elixir 中情况不一样, 编译时给出 API 过期的警告后,
立刻就能给出具体的建议. Java 中注解如果要完成相同的功能必须使用带有参数的注解才行.</p><h3 id="python-修饰器" class="section-heading">
  <a href="#python-修饰器" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">python-修饰器</p>
  </a>
  Python 修饰器
</h3>
<p>Python 中的修饰器语法, 是通过高阶函数提供的语法糖,
来简化函数或方法定义中的重复性的模板内容. 例如下面的代码:</p><pre><code class="python">def trace(fun):
  def warper(arg):
    print(&quot;call %s(\&quot;%s\&quot;)&quot; %(fun.__name__, arg) )
    ret = fun(arg)
    print(&quot;get: %s\n&quot;%ret)
    return ret
  return warper

@trace
def hello(a):
  return &quot;Hello, %s&quot; %(a)

@trace
def hi(a):
  return &quot;Hi, %s&quot; %(a)

hw = hello(&quot;world&quot;)
hi_white = hi(&quot;Mr. White&quot;)
print(hw)
print(hi_white)</code></pre><p>其输出为:</p><pre><code class="makeup elixir" translate="no"><span class="n">call</span><span class="w"> </span><span class="n">hello</span><span class="p" data-group-id="2255872457-1">(</span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="2255872457-1">)</span><span class="w">
</span><span class="ss">get</span><span class="p">:</span><span class="w"> </span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="w">

</span><span class="n">call</span><span class="w"> </span><span class="n">hi</span><span class="p" data-group-id="2255872457-2">(</span><span class="s">&quot;Mr. White&quot;</span><span class="p" data-group-id="2255872457-2">)</span><span class="w">
</span><span class="ss">get</span><span class="p">:</span><span class="w"> </span><span class="nc">Hi</span><span class="p">,</span><span class="w"> </span><span class="nc">Mr</span><span class="o">.</span><span class="w"> </span><span class="nc">White</span><span class="w">

</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="w">
</span><span class="nc">Hi</span><span class="p">,</span><span class="w"> </span><span class="nc">Mr</span><span class="o">.</span><span class="w"> </span><span class="nc">White</span></code></pre><p>Elixir 不支持修饰器. 但是修饰器, 本质上不过是高阶函数生产新函数, 来代理被修饰的函数.
Elixir 强大的元编程能力, 再借助编译相关的模块属性钩子(Hook): <code class="inline">@before_compile</code> 和
<code class="inline">@on_defination</code>, 是可以实现类似 Python 的修饰器这样的功能. 实际上,
早就有人做到了这一点<a href="#fn:2" id="fnref:2" class="footnote" title="see footnote">2</a>.</p><p>首先安装我们需要的库: <code class="inline">decorator</code>
LiveBook 中使用:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Mix</span><span class="o">.</span><span class="n">install</span><span class="p" data-group-id="1021296665-1">(</span><span class="ss">decorator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;~&gt; 1.2&quot;</span><span class="p" data-group-id="1021296665-1">)</span></code></pre><p>本地运行的话, 修改 <code class="inline">mix.exs</code> 文件. 在 <code class="inline">deps</code> 函数中, 添加 <code class="inline">{:decorator, &quot;~&gt; 1.2&quot;}</code>
就可以了. 然后运行 <a href="https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html"><code class="inline">mix deps.get</code></a> 就会下载对应的代码到本地.</p><p>现在让我们来在定义一个修饰器:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">PrintDecorator</span><span class="w"> </span><span class="k" data-group-id="6717462350-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Decorator.Define</span><span class="p">,</span><span class="w"> </span><span class="ss">print</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">print</span><span class="p" data-group-id="6717462350-2">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="6717462350-2">)</span><span class="w"> </span><span class="k" data-group-id="6717462350-3">do</span><span class="w">
    </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">.</span><span class="n">args</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6717462350-4">do</span><span class="w">
      </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Atom</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="6717462350-5">(</span><span class="k">unquote</span><span class="p" data-group-id="6717462350-6">(</span><span class="n">context</span><span class="o">.</span><span class="n">name</span><span class="p" data-group-id="6717462350-6">)</span><span class="p" data-group-id="6717462350-5">)</span><span class="w">

      </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6717462350-7">(</span><span class="s">&quot;Function called: &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot;(</span><span class="si" data-group-id="6717462350-8">#{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="6717462350-9">(</span><span class="n">args</span><span class="p" data-group-id="6717462350-9">)</span><span class="si" data-group-id="6717462350-8">}</span><span class="s">)&quot;</span><span class="p" data-group-id="6717462350-7">)</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="6717462350-10">(</span><span class="n">body</span><span class="p" data-group-id="6717462350-10">)</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">tap</span><span class="p" data-group-id="6717462350-11">(</span><span class="o">&amp;</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6717462350-12">(</span><span class="s">&quot;get result: </span><span class="si" data-group-id="6717462350-13">#{</span><span class="n">inspect</span><span class="w"> </span><span class="ni">&amp;1</span><span class="si" data-group-id="6717462350-13">}</span><span class="s">&quot;</span><span class="p" data-group-id="6717462350-12">)</span><span class="p" data-group-id="6717462350-11">)</span><span class="w">
    </span><span class="k" data-group-id="6717462350-4">end</span><span class="w">
  </span><span class="k" data-group-id="6717462350-3">end</span><span class="w">
</span><span class="k" data-group-id="6717462350-1">end</span></code></pre><p>上面代码定义了修饰符函数 <code class="inline">print</code>.
当其他函数被 <code class="inline">print</code> 修饰后, 再调用被修饰后的函数,
函数的返回结果和修饰前没什么不一样, 但是在函数返回结果之前,
会首先打印出 &quot;Function called: &lt;fun_name&gt;&quot; 这样的文本,
在返回之前, 而函数返回结果之前会先答应到控制台: &quot;get result: xxxx&quot;.</p><p>现在让我们看看如何使用修饰符函数 <code class="inline">print</code> 来修饰其他的函数.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">DecoratorUseModule</span><span class="w"> </span><span class="k" data-group-id="0744781018-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">PrintDecorator</span><span class="w">

  </span><span class="na">@decorate</span><span class="w"> </span><span class="n">print</span><span class="p" data-group-id="0744781018-2">(</span><span class="p" data-group-id="0744781018-2">)</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">square</span><span class="p" data-group-id="0744781018-3">(</span><span class="n">a</span><span class="p" data-group-id="0744781018-3">)</span><span class="w"> </span><span class="k" data-group-id="0744781018-4">do</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w">
  </span><span class="k" data-group-id="0744781018-4">end</span><span class="w">
</span><span class="k" data-group-id="0744781018-1">end</span><span class="w">

</span><span class="kn">alias</span><span class="w"> </span><span class="nc">DecoratorUseModule</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">DUM</span><span class="w">
</span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DUM</span><span class="o">.</span><span class="n">square</span><span class="p" data-group-id="0744781018-5">(</span><span class="mi">2</span><span class="p" data-group-id="0744781018-5">)</span></code></pre><p>执行上面的代码, 控制台中输出为:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Function</span><span class="w"> </span><span class="ss">called</span><span class="p">:</span><span class="w"> </span><span class="n">square</span><span class="p" data-group-id="6299199986-1">(</span><span class="mi">2</span><span class="p" data-group-id="6299199986-1">)</span><span class="w">
</span><span class="n">get</span><span class="w"> </span><span class="ss">result</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span></code></pre><h3 id="ruby-实例属性" class="section-heading">
  <a href="#ruby-实例属性" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">ruby-实例属性</p>
  </a>
  Ruby 实例属性
</h3>
<p>Elixir 的模块属性, 还和 Ruby 中的定义实例属性的语法类似.
Ruby 中, 用 <code class="inline">@age</code> 这样的语法来定义实例的属性的.
Elixir 大量的语法形式是借鉴自 Ruby 的,
所以一度我也为这两个概念的联系和区别而困惑.</p><p>我认为 Elixir 的这个语法设计是故意的.
和 Erlang 中自定义属性不一样, Elixir 中的自定义模块属性,
除了可以作为模块的元数据来使用外, 还有更加实用的功能.</p><ol><li>在编译时, 可以作为在元编程的临时结果的存储所;</li><li>作为模块内的常量.</li></ol><p>例如, 在上面我们用的 <code class="inline">decorator</code> 库中,
当编译回调钩子执行 <code class="inline">on_defination/6</code> 后,
在被修饰的函数所在的模块被添加了 <code class="inline">:decorated</code> 属性<a href="#fn:3" id="fnref:3" class="footnote" title="see footnote">3</a>.
在模块被编译之前, <code class="inline">before_compile/2</code> 宏被调用,
在这个宏执行的过程, 读取模块的属性 <code class="inline">:decorated</code> 的值后,
就把这个属性从模块中删除了<a href="#fn:4" id="fnref:4" class="footnote" title="see footnote">4</a>.
所以要这样做, 是因为 <code class="inline">:decorated</code> 记录的内容需要被进一步的处理,
而不应作为模块的元信息记录到字节码中.</p><p>最后的一个问题就是, 为什么不可以使用模块作用域的变量来做中转呢?
这是因为 Elixir 作为一个函数式编程语言, 变量的值是不变的.
这样作用域嵌套形成的闭包, 因为变量值的不可变, 使得内部作用域和外部作用域不会相互影响.</p><p>对内部的作用域来说, 它访问的自由变量的值永远都是同一个值,
内部作用域不用担心, 因自由变量值的改变, 而破坏了内部作用域的逻辑前提.</p><p>对外部作用域来说, 内部作用域, 虽然可以定义同名变量来覆盖外部的变量,
但是在内部作用域中, 无论如何对变量重新绑定值,
都是对内部作用域的同名的新变量的操作, 而绝对不会改变外部作用域中变量的值.
所以外部作用域的代码, 也不用担心代码在运行期间, 内部作用域的代码破坏自己的数据.</p><p>函数式编程带来的好处, 不用我在此鼓吹. 但是如此一来,
遇到不同的作用域中的代码需要共享数据的时候, 就比较麻烦了.
模块的属性, 在编译时, 是整个模块中可读可写的,
所以刚好可以用来保存编译钩子 (Hook) 执行中产生的副作用.</p><p>Elixir 的模块属性和 Ruby 的实例属性, 除了语法上的相似外,
其相联系之处还在于它们都是属性, 都是可以用来表示相应的概念的状态;
而区别在于, 它们表征的概念实体的生命周期不一样.</p><p>Elixir 的模块属性, 活跃于编译时, 如果没有特殊设置的话, 编译结束后,
其生命也就结束了.</p><p>通过特殊的设置, 可以把属性值作为模块的元数据保存到字节码中,
那么这些数据, 将伴随着模块的存在而存在的. 但是在模块运行的期间,
这些模块的元数据是恒常不变的. 无变化, 也就无所谓生死了.</p><p>因此, 我认为, Elixir 的模块属性, 如果说有生命周期的话,
它的生命周期是模块编译期间. 而 Ruby 的实例属性, 存活于运行时, 贯穿于实例的生命周期内.</p><p>Ruby 中用类属性来表示整个类都共享的数据, 其使用的语法为 <code class="inline">@@classAttr</code>.
Ruby 可以用类属性来完成的数据复用.</p><p>Elixir 模块内是不支持常量定义的, 模块属性可以用来充当模块内的常量, 以完成数据复用.</p><p>假如我们要定义一个数学相关的模块, 其中涉及到角度于弧度的转化,
那么我们可以这样来写:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Angle</span><span class="w"> </span><span class="k" data-group-id="2188581190-1">do</span><span class="w">
  </span><span class="na">@pi</span><span class="w"> </span><span class="mf">3.14</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">convert</span><span class="p" data-group-id="2188581190-2">(</span><span class="p" data-group-id="2188581190-3">{</span><span class="ss">:degrate</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="2188581190-3">}</span><span class="p" data-group-id="2188581190-2">)</span><span class="w"> </span><span class="k" data-group-id="2188581190-4">do</span><span class="w">
    </span><span class="na">@pi</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="w">
  </span><span class="k" data-group-id="2188581190-4">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">convert</span><span class="p" data-group-id="2188581190-5">(</span><span class="p" data-group-id="2188581190-6">{</span><span class="ss">:radian</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="2188581190-6">}</span><span class="p" data-group-id="2188581190-5">)</span><span class="w"> </span><span class="k" data-group-id="2188581190-7">do</span><span class="w">
    </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="na">@pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="w">
  </span><span class="k" data-group-id="2188581190-7">end</span><span class="w">
</span><span class="k" data-group-id="2188581190-1">end</span></code></pre><p>上面的代码中, 多个地方用到了常量 $\pi$, 如果不提供数据复用的方法,
$\pi$ 常量的字面量将散落于系统的各个角落.
当提高计算的精度提高, 需要使用更精确的 $\pi$ 值时,
修改散落再各处的字面量, 那将会是一个通过且易错过程.</p><p>像上面的代码中那样, 用模块属性做编译时常量,
更新 $\pi$ 常量的值, 我们只需要修改第 2 行代码就可以了.</p><p>此外, 模块属性的值, 不但可以为字面量, 还可以是其他的函数的返回值.
但是, 模块最后记录的属性值, 必须是可以用字面量定义的类型.
像 <code class="inline">PID</code>, <code class="inline">Reference</code>, 匿名函数等, 必须通过函数或宏调用才能产生的数据类型,
是不可以记录于模块属性中的.</p><p>合理的使用模块常量, 可以提高代码的执行效率.
假设我们的代码中, 多个地方需要使用斐波那契数列的第 1000 项.
那么每次调用都会重新计算这个值, 会拖累程序的效率.</p><p>但是, 当我们使用模块属性来保存, 那么只需要在编译的时候,
计算一次斐波那契数第 1000 项的值.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Fib</span><span class="w"> </span><span class="k" data-group-id="4973362388-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fib</span><span class="p" data-group-id="4973362388-2">(</span><span class="n">n</span><span class="p" data-group-id="4973362388-2">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-3">do</span><span class="w">
    </span><span class="n">do_fib</span><span class="p" data-group-id="4973362388-4">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4973362388-5">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4973362388-5">]</span><span class="p" data-group-id="4973362388-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4973362388-6">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;fin(</span><span class="si" data-group-id="4973362388-7">#{</span><span class="n">n</span><span class="si" data-group-id="4973362388-7">}</span><span class="s">)&quot;</span><span class="p" data-group-id="4973362388-6">)</span><span class="w">
  </span><span class="k" data-group-id="4973362388-3">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_fib</span><span class="p" data-group-id="4973362388-8">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4973362388-9">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="4973362388-9">]</span><span class="p" data-group-id="4973362388-8">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_fib</span><span class="p" data-group-id="4973362388-10">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4973362388-11">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="4973362388-11">]</span><span class="p" data-group-id="4973362388-10">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-12">do</span><span class="w">
    </span><span class="n">do_fib</span><span class="p" data-group-id="4973362388-13">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4973362388-14">[</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="4973362388-14">]</span><span class="p" data-group-id="4973362388-13">)</span><span class="w">
  </span><span class="k" data-group-id="4973362388-12">end</span><span class="w">
</span><span class="k" data-group-id="4973362388-1">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">UR</span><span class="w"> </span><span class="k" data-group-id="4973362388-15">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fun1</span><span class="p" data-group-id="4973362388-16">(</span><span class="p" data-group-id="4973362388-16">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-17">do</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Fib</span><span class="o">.</span><span class="n">fib</span><span class="p" data-group-id="4973362388-18">(</span><span class="mi">1000</span><span class="p" data-group-id="4973362388-18">)</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4973362388-17">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fun2</span><span class="p" data-group-id="4973362388-19">(</span><span class="p" data-group-id="4973362388-19">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-20">do</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Fib</span><span class="o">.</span><span class="n">fib</span><span class="p" data-group-id="4973362388-21">(</span><span class="mi">1000</span><span class="p" data-group-id="4973362388-21">)</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4973362388-20">end</span><span class="w">
</span><span class="k" data-group-id="4973362388-15">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">UC</span><span class="w"> </span><span class="k" data-group-id="4973362388-22">do</span><span class="w">
  </span><span class="na">@fib1000</span><span class="w"> </span><span class="nc">Fib</span><span class="o">.</span><span class="n">fib</span><span class="p" data-group-id="4973362388-23">(</span><span class="mi">1000</span><span class="p" data-group-id="4973362388-23">)</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fun1</span><span class="p" data-group-id="4973362388-24">(</span><span class="p" data-group-id="4973362388-24">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-25">do</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="na">@fib1000</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4973362388-25">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fun2</span><span class="p" data-group-id="4973362388-26">(</span><span class="p" data-group-id="4973362388-26">)</span><span class="w"> </span><span class="k" data-group-id="4973362388-27">do</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="na">@fib1000</span><span class="w">
    </span><span class="n">fib1000</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4973362388-27">end</span><span class="w">
</span><span class="k" data-group-id="4973362388-22">end</span><span class="w">

</span><span class="c1"># 每次调用控制台都会输出 `fin(1000):....`</span><span class="w">
</span><span class="nc">UR</span><span class="o">.</span><span class="n">fun1</span><span class="p" data-group-id="4973362388-28">(</span><span class="p" data-group-id="4973362388-28">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4973362388-29">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;UR.fun1()&quot;</span><span class="p" data-group-id="4973362388-29">)</span><span class="w">
</span><span class="nc">UR</span><span class="o">.</span><span class="n">fun2</span><span class="p" data-group-id="4973362388-30">(</span><span class="p" data-group-id="4973362388-30">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4973362388-31">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;UR.fun2()&quot;</span><span class="p" data-group-id="4973362388-31">)</span><span class="w">

</span><span class="c1"># 编译时输出一次 `fin(1000): ...`, 运行时不在输出</span><span class="w">
</span><span class="nc">UC</span><span class="o">.</span><span class="n">fun1</span><span class="p" data-group-id="4973362388-32">(</span><span class="p" data-group-id="4973362388-32">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4973362388-33">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;UC.fun1()&quot;</span><span class="p" data-group-id="4973362388-33">)</span><span class="w">
</span><span class="nc">UC</span><span class="o">.</span><span class="n">fun2</span><span class="p" data-group-id="4973362388-34">(</span><span class="p" data-group-id="4973362388-34">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4973362388-35">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;UC.fun2()&quot;</span><span class="p" data-group-id="4973362388-35">)</span></code></pre><h2 id="持久化属性值" class="section-heading">
  <a href="#持久化属性值" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">持久化属性值</p>
  </a>
  持久化属性值
</h2>
<p>模块属性在编程中, 最常用的语法功能,
就是上面小节中介绍: 1) 用来保存临时的状态信息, 2) 作为运行时常量.
但是, 持久化到字节码中的模块属性值, 不只是可以用来做模块的元数据,
也可以有其他用途<a href="#fn:5" id="fnref:5" class="footnote" title="see footnote">5</a>, 所以有必要学习如何把模块属性持久化到字节码中.</p><p><a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 模块中为我们提供了相应的 API:
<code class="inline">Module.register_attribute(module, attribute, options)</code>.
当我们不使用这个函数, 而直接在 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 上下文中, 使用 <code class="inline">@attr</code>
来定义模块属性的时候, 默认的 <code class="inline">options</code> 是 <code class="inline">[accumulate: flase, persist: false]</code>.
也就是说, <code class="inline">@attr</code> 的值默认是单值, 且不持续化的.</p><p>如果我们想要持续化, 那么必须在使用 <code class="inline">@attr</code> 之前, 先调用
<a href="https://hexdocs.pm/elixir/Module.html#register_attribute/3"><code class="inline">Module.register_attribute/3</code></a>.</p><p>还是让我们用代码来探索吧:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.ModuleAttr</span><span class="w"> </span><span class="k" data-group-id="1090839515-1">do</span><span class="w">
  </span><span class="na">@x</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="na">@x</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-2">(</span><span class="na">@x</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;@x&quot;</span><span class="p" data-group-id="1090839515-2">)</span><span class="w">

  </span><span class="nc">Module</span><span class="o">.</span><span class="n">register_attribute</span><span class="p" data-group-id="1090839515-3">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="ss">persist</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="1090839515-3">)</span><span class="w">
  </span><span class="na">@y</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="na">@y</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-4">(</span><span class="na">@y</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;@y&quot;</span><span class="p" data-group-id="1090839515-4">)</span><span class="w">

  </span><span class="nc">Module</span><span class="o">.</span><span class="n">register_attribute</span><span class="p" data-group-id="1090839515-5">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="ss">:z</span><span class="p">,</span><span class="w"> </span><span class="ss">accumulate</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="1090839515-5">)</span><span class="w">
  </span><span class="na">@z</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="na">@z</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-6">(</span><span class="na">@z</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;@z&quot;</span><span class="p" data-group-id="1090839515-6">)</span><span class="w">

  </span><span class="nc">Module</span><span class="o">.</span><span class="n">register_attribute</span><span class="p" data-group-id="1090839515-7">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="ss">:i</span><span class="p">,</span><span class="w"> </span><span class="ss">accumulate</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">persist</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="1090839515-7">)</span><span class="w">
  </span><span class="na">@i</span><span class="w"> </span><span class="p" data-group-id="1090839515-8">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1090839515-8">]</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-9">(</span><span class="na">@i</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;@i&quot;</span><span class="p" data-group-id="1090839515-9">)</span><span class="w">
  </span><span class="na">@i</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-10">(</span><span class="na">@i</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;@i&quot;</span><span class="p" data-group-id="1090839515-10">)</span><span class="w">
</span><span class="k" data-group-id="1090839515-1">end</span><span class="w">

</span><span class="nc">Corner.ModuleAttr</span><span class="o">.</span><span class="c">__info__</span><span class="p" data-group-id="1090839515-11">(</span><span class="ss">:attributes</span><span class="p" data-group-id="1090839515-11">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1090839515-12">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;attrs&quot;</span><span class="p" data-group-id="1090839515-12">)</span></code></pre><p><code class="inline">persist: true</code> 可以把属性持久化到模块属性中;
<code class="inline">accumulate: true</code> 使得属性的值可以累积.
上面的代码在控制台中的输出为:</p><pre><code class="makeup elixir" translate="no"><span class="na">@x</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="na">@y</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="na">@z</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-1">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="2599514255-1">]</span><span class="w">
</span><span class="na">@i</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-2">[</span><span class="p" data-group-id="2599514255-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2599514255-3">]</span><span class="p" data-group-id="2599514255-2">]</span><span class="w">
</span><span class="na">@i</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-4">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2599514255-5">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2599514255-5">]</span><span class="p" data-group-id="2599514255-4">]</span><span class="w">
</span><span class="ss">attrs</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-6">[</span><span class="ss">vsn</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-7">[</span><span class="mi">178793915849767856111007519148929511895</span><span class="p" data-group-id="2599514255-7">]</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-8">[</span><span class="mi">2</span><span class="p" data-group-id="2599514255-8">]</span><span class="p">,</span><span class="w"> </span><span class="ss">i</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-9">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2599514255-9">]</span><span class="p">,</span><span class="w"> </span><span class="ss">i</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2599514255-10">[</span><span class="mi">2</span><span class="p" data-group-id="2599514255-10">]</span><span class="p" data-group-id="2599514255-6">]</span></code></pre><p>当属性值累计时, 在编译过程中, 属性值记录于一个列表中, 每次对属性赋值,
都是向列表头部添加新值.</p><p>但是持久化的时候, 像上面的输出中, 最后一行显示的那样:</p><ol><li>所有需要持久化的属性值都被记录为列表,</li><li>每次赋值都当作列表中的一项, 被单独记录, 而不是根据相同属性名合并后记录.
最后, <code class="inline">__info__/1</code> 是 <a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 模块中定义的回调函数.
Elixir 定义的所有模块, 都实现了 <a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 行为.</li></ol><h2 id="defmodule-上下文中的内容" class="section-heading">
  <a href="#defmodule-上下文中的内容" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">defmodule-上下文中的内容</p>
  </a>
  defmodule 上下文中的内容
</h2>
<p>以前的章节中, 我们知道 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 上下文中, 除了 <code class="inline">def*</code> 系列宏之外,
还可以使用其他语法结构. 现在我们来讨论, 只能在 <code class="inline">defmoulde/2</code>
相关的上下分中才能使用的语法结构.</p><p>函数必须定义在模块中, 这是来自 Erlang 的规定; 所以 <code class="inline">def</code> 和 <code class="inline">defp</code> 只能在模块中使用,
非常容易理解. 但是为什么结构, 记录, 异常这些定义也必须在模块中呢?
<code class="inline">defstruct</code>, <code class="inline">defexpect</code> 以及 <code class="inline">defrecord</code> 这些宏到底做了什么呢?</p><p>在 <code class="inline">defstruct</code> 文档中<a href="#fn:6" id="fnref:6" class="footnote" title="see footnote">6</a>, 讲到 <code class="inline">defstruct</code> 还在模块中定义了
<code class="inline">__struct__/0</code> 函数. 正是因为 <code class="inline">defstruct</code> 被调用的时候,
会向被调用者的上下文中注入函数, 所以 <code class="inline">defstruct</code>
被调用的上下文就只能被限制为在模块内了.</p><p>和 <code class="inline">defstruct</code> 类似, 但是在 Elixir 中很少使用还有宏  <code class="inline">defrecord</code>.
这个宏做的工作与 <code class="inline">defstruct</code> 非常类似, 只是他们选用的表示数据的容器类型不同.
<code class="inline">defstruct</code> 选 map 作为组合数据的基础; 而 <code class="inline">defrecord</code> 以元组为基础.
这是他们之间的不同.</p><p>其相同点在于: 这两个宏被调用的时候, 都要向调用它的上下文中注入函数.
所以 <code class="inline">defrecord</code> 也必然的就被限制在了模块中了.</p><p><code class="inline">defexpect</code> 所以被限制在模块内, 原因更容易理解. 因为它是基于 <code class="inline">defstruct</code> 工作的,
或者说, 它是特化的 <code class="inline">defstruct</code>; <code class="inline">defstruct</code> 都被限制在模块内, <code class="inline">defexpect</code>
都被限制也就顺利成章了.</p><h2 id="协议和行为" class="section-heading">
  <a href="#协议和行为" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">协议和行为</p>
  </a>
  协议和行为
</h2>
<p>上一节, 我们讨论了为什么有些宏, 被限制只能在模块中使用.
在上面的讨论中, 有意无意地, 已经认定了:
Elixir 中, 只有 <a href="https://hexdocs.pm/elixir/Kernel.html#defmodule/2"><code class="inline">defmodule/2</code></a> 这个宏可以被编译器编译为字节码文件.</p><p>但是这种认识是错误的. <code class="inline">defprotocol</code> 和 <code class="inline">defimple</code> 宏的调用结果,
也一样是产生 <code class="inline">.beam</code> 文件的.</p><p>Elixir 在这里的处理和 Java 中的处理非常的类似.
我们可以用下表来做个比较.</p><table><thead><tr><th style="text-align: left;">对应项</th><th style="text-align: left;">Java</th><th style="text-align: left;">Elixir</th></tr></thead><tbody><tr><td style="text-align: left;">字节码后缀</td><td style="text-align: left;"><code class="inline">.class</code></td><td style="text-align: left;"><code class="inline">.beam</code></td></tr><tr><td style="text-align: left;">最常用的编译单元</td><td style="text-align: left;">类定义</td><td style="text-align: left;">模块定义</td></tr><tr><td style="text-align: left;">嵌套处理</td><td style="text-align: left;">类定义可以嵌套, 字节码平铺</td><td style="text-align: left;">模块可以嵌套, 字节码平铺</td></tr><tr><td style="text-align: left;">API</td><td style="text-align: left;">接口(Interface)</td><td style="text-align: left;">协议(Protocol)</td></tr><tr><td style="text-align: left;">API 的实现</td><td style="text-align: left;">匿名类</td><td style="text-align: left;">协议实现</td></tr><tr><td style="text-align: left;">API 复用代码的机制</td><td style="text-align: left;">抽象类</td><td style="text-align: left;">行为</td></tr></tbody></table><p>在 Java 语言中, 类和接口的定义都会被编译为 <code class="inline">.class</code>文件.
在 Elixir 中模块定义和协议定义也都要产生对应的字节码文件.</p><p>在上表中, 我把 Elixir 中的行为和 Java 中的抽象类做对比,
因为它们都是为了在定义 API 的时候最大化的复用代码,
这是从语言外部对比来看.</p><p>如果从 Elixir 语言内部来看, 协议实际上是以行为 (Behaviour) 为基础,
抽象出的模块动态调度的通用方法.</p><p>有关协议与行为的更多讨论, 见后面的
<a href="ch10-protocol_and_behaviour.html">≪协议与行为≫</a> 章节.</p><h2 id="模块内省" class="section-heading">
  <a href="#模块内省" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模块内省</p>
  </a>
  模块内省
</h2>
<p>这一小节, 我们探索如何在运行时获取一个模块的信息.</p><p>前面的小结中, 我们说到, Elixir 中定义的模块, 都实现了 <a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> 行为.
也就是说都有 <code class="inline">__info__/1</code> 函数.
Erlang 的编译器自动的为每个模块插入了两个导出函数 <code class="inline">module_info/0-1</code>.
每个 Elixir 代码, 最后也是要编译为 Erlang 字节码的,
所以每个 Elixir 模块, 哪怕时空模块, 至少都有这三个导出函数的.
这三个函数是模块内省的基础.</p><h3 id="module_info-0" class="section-heading">
  <a href="#module_info-0" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">module_info-0</p>
  </a>
  <code class="inline">module_info/0</code>
</h3>
<p><code class="inline">module_info/0</code> 给出的模块信息包括:</p><ol><li>模块名字 <code class="inline">:module</code></li><li>所有的导出 <code class="inline">:exports</code></li><li>持久化的属性 <code class="inline">:attributes</code></li><li>模块编译时的信息 <code class="inline">:compile</code></li><li>模块的数字签名 <code class="inline">:md5</code></li></ol><p>其他两个函数, 接受的参数都是原子, 其中大部分和 <code class="inline">module_info/0</code> 返回 Keyword 的
key 相同.</p><h3 id="module_info-1" class="section-heading">
  <a href="#module_info-1" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">module_info-1</p>
  </a>
  <code class="inline">module_info/1</code>
</h3>
<p><code class="inline">module_info/1</code> 支持的的输入参数除了 <code class="inline">module_info/0</code> 的五个原子外,
还包含: <code class="inline">:functions</code>, <code class="inline">:nifs</code> 和 <code class="inline">:native</code><a href="#fn:7" id="fnref:7" class="footnote" title="see footnote">7</a>.</p><h3 id="__info__-1" class="section-heading">
  <a href="#__info__-1" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">__info__-1</p>
  </a>
  <code class="inline">__info__/1</code>
</h3>
<p><code class="inline">__info__</code> 支持以 6 原子为输入.
<code class="inline">module_info/0</code> 的 5 个原子中, <code class="inline">__info__</code>, 不支持以 <code class="inline">:exports</code> 为参数;
增加了<code class="inline">:functions</code> 和 <code class="inline">:macros</code>.</p><h3 id="差异" class="section-heading">
  <a href="#差异" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">差异</p>
  </a>
  差异
</h3>
<p>这里 <code class="inline">__info__/1</code> 和 <code class="inline">__module__/1</code> 都支持 <code class="inline">:functions</code>, 但其含义不同.</p><p><strong><code class="inline">__info__(:functions)</code> 返回的是 Elixir 模块的定义的公开函数的子集</strong>,
模块中以 <code class="inline">_</code> 为前缀的函数在不显示.</p><p><strong><code class="inline">module_info(:functions)</code> 返回的是模块内所有的函数</strong>,
包括没有被导出的私有函数.</p><h3 id="模块探索" class="section-heading">
  <a href="#模块探索" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模块探索</p>
  </a>
  模块探索
</h3>
<p>知道了这些信息, 就不难写一个模块来帮助我们完成模块内省的工作了.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Module.Explorer</span><span class="w"> </span><span class="k" data-group-id="4624725559-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">funs</span><span class="p" data-group-id="4624725559-2">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-2">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-3">do</span><span class="w">
    </span><span class="n">m</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="4624725559-4">(</span><span class="ss">:functions</span><span class="p" data-group-id="4624725559-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reject</span><span class="p" data-group-id="4624725559-5">(</span><span class="o">&amp;</span><span class="n">macro?</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="4624725559-5">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">pub_funs</span><span class="p" data-group-id="4624725559-6">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-6">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-7">do</span><span class="w">
    </span><span class="n">m</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="4624725559-8">(</span><span class="ss">:exports</span><span class="p" data-group-id="4624725559-8">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reject</span><span class="p" data-group-id="4624725559-9">(</span><span class="o">&amp;</span><span class="n">macro?</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="4624725559-9">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-7">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">priv_funs</span><span class="p" data-group-id="4624725559-10">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-10">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-11">do</span><span class="w">
    </span><span class="n">funs</span><span class="p" data-group-id="4624725559-12">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-12">)</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">pub_funs</span><span class="p" data-group-id="4624725559-13">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-13">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-11">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">macro?</span><span class="p" data-group-id="4624725559-14">(</span><span class="p" data-group-id="4624725559-15">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="4624725559-15">}</span><span class="p" data-group-id="4624725559-14">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-16">do</span><span class="w">
    </span><span class="s">&quot;</span><span class="si" data-group-id="4624725559-17">#{</span><span class="n">atom</span><span class="si" data-group-id="4624725559-17">}</span><span class="s">&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/MACRO-/</span><span class="w">
  </span><span class="k" data-group-id="4624725559-16">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">macros</span><span class="p" data-group-id="4624725559-18">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-18">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-19">do</span><span class="w">
    </span><span class="n">m</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="4624725559-20">(</span><span class="ss">:functions</span><span class="p" data-group-id="4624725559-20">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="4624725559-21">(</span><span class="o">&amp;</span><span class="n">macro?</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="4624725559-21">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="4624725559-22">(</span><span class="o">&amp;</span><span class="n">fun_2_macro</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="4624725559-22">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-19">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">pub_macros</span><span class="p" data-group-id="4624725559-23">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-23">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-24">do</span><span class="w">
    </span><span class="n">m</span><span class="o">.</span><span class="c">__info__</span><span class="p" data-group-id="4624725559-25">(</span><span class="ss">:macros</span><span class="p" data-group-id="4624725559-25">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-24">rescue</span><span class="w">
    </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="4624725559-26">[</span><span class="p" data-group-id="4624725559-26">]</span><span class="w">
  </span><span class="k" data-group-id="4624725559-24">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">priv_macros</span><span class="p" data-group-id="4624725559-27">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-27">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-28">do</span><span class="w">
    </span><span class="n">macros</span><span class="p" data-group-id="4624725559-29">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-29">)</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">pub_macros</span><span class="p" data-group-id="4624725559-30">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-30">)</span><span class="w">
  </span><span class="k" data-group-id="4624725559-28">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">fun_2_macro</span><span class="p" data-group-id="4624725559-31">(</span><span class="p" data-group-id="4624725559-32">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="4624725559-32">}</span><span class="p" data-group-id="4624725559-31">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-33">do</span><span class="w">
    </span><span class="s">&quot;MACRO-&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="4624725559-34">#{</span><span class="n">atom</span><span class="si" data-group-id="4624725559-34">}</span><span class="s">&quot;</span><span class="w">
    </span><span class="p" data-group-id="4624725559-35">{</span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="4624725559-36">(</span><span class="n">name</span><span class="p" data-group-id="4624725559-36">)</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4624725559-35">}</span><span class="w">
  </span><span class="k" data-group-id="4624725559-33">end</span><span class="w">

  </span><span class="k">for</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="4624725559-37">[</span><span class="ss">:md5</span><span class="p">,</span><span class="w"> </span><span class="ss">:compile</span><span class="p">,</span><span class="w"> </span><span class="ss">:attributes</span><span class="p">,</span><span class="w"> </span><span class="ss">:module</span><span class="p" data-group-id="4624725559-37">]</span><span class="w"> </span><span class="k" data-group-id="4624725559-38">do</span><span class="w">
    </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4624725559-39">(</span><span class="n">name</span><span class="p" data-group-id="4624725559-39">)</span><span class="p" data-group-id="4624725559-40">(</span><span class="n">m</span><span class="p" data-group-id="4624725559-40">)</span><span class="w"> </span><span class="k" data-group-id="4624725559-41">do</span><span class="w">
      </span><span class="n">m</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="4624725559-42">(</span><span class="k">unquote</span><span class="p" data-group-id="4624725559-43">(</span><span class="n">name</span><span class="p" data-group-id="4624725559-43">)</span><span class="p" data-group-id="4624725559-42">)</span><span class="w">
    </span><span class="k" data-group-id="4624725559-41">end</span><span class="w">
  </span><span class="k" data-group-id="4624725559-38">end</span><span class="w">
</span><span class="k" data-group-id="4624725559-1">end</span></code></pre><h2 id="函数的导入" class="section-heading">
  <a href="#函数的导入" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数的导入</p>
  </a>
  函数的导入
</h2>
<p>为实现代码复用, Elixir 提供了几个特殊表单: <code class="inline">import</code>, <code class="inline">require</code> 和 <code class="inline">use</code>.
从代码的清晰的角度来说, 应该首先使用 <code class="inline">require</code>, 其次 <code class="inline">import</code> 最后 <code class="inline">use</code>.</p><p>我们依次来看它们的用法.</p><h3 id="require" class="section-heading">
  <a href="#require" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">require</p>
  </a>
  require
</h3>
<p><code class="inline">require</code> 的语法为:</p><pre><code class="makeup elixir" translate="no"><span class="kn">require</span><span class="w"> </span><span class="o">&lt;</span><span class="nc">ModuleName</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="5691768037-1">[</span><span class="p">,</span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nc">AliasName</span><span class="o">&gt;</span><span class="p" data-group-id="5691768037-1">]</span></code></pre><p>上面的代码, 不 Elixir 代码, 而是说明语法的 BNF 范式, 方括号中的内容是可省略的部分.</p><p>从语法的形式上来说, <code class="inline">require</code> 和 <code class="inline">alias</code> 非常的相似.
<code class="inline">alias</code> 也有可选的 <code class="inline">:as</code> 选项. 但是, <code class="inline">require</code> 和 <code class="inline">alias</code> 对 <code class="inline">:as</code>
选线的默认处理并不一致. 对 <code class="inline">X.Y</code> 的模块, <code class="inline">require X.Y</code> 语句后,
并不能使用 <code class="inline">Y.fun(...)</code>, 来调用 <code class="inline">X.Y</code> 模块中定义的函数 <code class="inline">fun</code>.
而必须使用 <code class="inline">require X.Y, as: Y</code> 才可以.</p><p>我们可以定义一个新的宏来改变 <code class="inline">require</code> 对 <code class="inline">:as</code> 选项的默认处理,
使得它可以像 <code class="inline">aliase</code> 对 <code class="inline">:as</code> 选项的默认处理那样工作.
按照前面的命名规则, 这个宏命名为 <code class="inline">require!</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Require</span><span class="w"> </span><span class="k" data-group-id="3369920221-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">require!</span><span class="p" data-group-id="3369920221-2">(</span><span class="n">module</span><span class="p" data-group-id="3369920221-2">)</span><span class="w"> </span><span class="k" data-group-id="3369920221-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3369920221-4">do</span><span class="w">
      </span><span class="kn">require</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3369920221-5">(</span><span class="n">module</span><span class="p" data-group-id="3369920221-5">)</span><span class="w">
      </span><span class="kn">alias</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3369920221-6">(</span><span class="n">module</span><span class="p" data-group-id="3369920221-6">)</span><span class="w">
    </span><span class="k" data-group-id="3369920221-4">end</span><span class="w">
  </span><span class="k" data-group-id="3369920221-3">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">require!</span><span class="p" data-group-id="3369920221-7">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="n">as</span><span class="p" data-group-id="3369920221-7">)</span><span class="w"> </span><span class="k" data-group-id="3369920221-8">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3369920221-9">do</span><span class="w">
      </span><span class="kn">require</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3369920221-10">(</span><span class="n">module</span><span class="p" data-group-id="3369920221-10">)</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3369920221-11">(</span><span class="n">as</span><span class="p" data-group-id="3369920221-11">)</span><span class="w">
    </span><span class="k" data-group-id="3369920221-9">end</span><span class="w">
  </span><span class="k" data-group-id="3369920221-8">end</span><span class="w">
</span><span class="k" data-group-id="3369920221-1">end</span></code></pre><p>如果模块中没有宏定义, 那么 <code class="inline">require</code> 唯一作用就是确保要求的模块在系统中是可用的.
如果系统中不存在要求的模块, 那么编译时, 编译器会提前报错, 而不用等到调用函数或宏的时候,
才报错.</p><pre><code class="makeup elixir" translate="no"><span class="kn">require</span><span class="w"> </span><span class="nc">NoExist.Module</span></code></pre><p>上面的代码, 会给类似于下面的编译错误:</p><blockquote><p>** (CompileError) ch09.module.livemd#cell:1: module NoExist.Module is not loaded and could not be found</p></blockquote><p>如果要求的模块中存在宏, 要想调用模块内定义的宏, 就必须使用 <code class="inline">require</code> 语句.</p><p><strong>总结</strong>: <code class="inline">require</code> 语句的作用就是确保要求的模块存在,
且使得模块中定义的宏在当前上下文中可见.</p><h3 id="import" class="section-heading">
  <a href="#import" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">import</p>
  </a>
  import
</h3>
<p><code class="inline">import</code> 语句不但可以用来导入模块中的宏,
而且还可以在当前上下文中使用是本地函数调用的语法来调用导入的函数或宏.</p><p><code class="inline">import</code> 有三个用法:</p><ul><li>导入模块中所有的公开的宏和函数, 但是以下划线为前缀的除外: <code class="inline">import ModuleName</code></li><li>导入模块中指定的宏或函数: <code class="inline">import ModuleName, only: [fun_or_macro_name: arity]</code>.</li><li>排除指定的函数外, 导入其他所有函数或宏: <code class="inline">import ModuleName, except: [fun_or_macro_name: arity]</code>.</li></ul><p>不推荐使用第 1 中格式, 因为这样的代码, 在代码中体现不出到底导入了什么函数.
当一个模块从多个其他模块中导入函数后, 如果都是用的是第 1 种方法,
当前文件中调用的外部函数来自那个模块, 就难以确定了. 所以应该优先使用第 2 中格式.</p><p>第 3 中格式一般在覆盖核心模块提供的函数或宏的时候使用.</p><h3 id="use" class="section-heading">
  <a href="#use" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">use</p>
  </a>
  use
</h3>
<p><code class="inline">use</code> 需要被使用地模块中的 <code class="inline">__using__</code> 宏函数配合才能完成功能.</p><p>原则上 <code class="inline">__using__</code> 宏可能在上下中注入任意的内容, 所以不到万不得已不推荐使用
<code class="inline">use</code> 语句. 如果我们要自定义 <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a> 模块中提供的操作符; 在重定义的模块中,
需要使用 <code class="inline">import Kernel, except: [fun_or_macro_name: arity]</code>.
在使用重定义操作符的模块中, 为了避免和核心模块中的操作符冲突, 必须也排除它们.
用代码来说大概是这样的:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">OverWriteAdd</span><span class="w"> </span><span class="k" data-group-id="5145722706-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">execpt</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5145722706-2">[</span><span class="ss">+</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5145722706-2">]</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="o">+</span><span class="p" data-group-id="5145722706-3">(</span><span class="n">number</span><span class="p" data-group-id="5145722706-3">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_numebr</span><span class="p" data-group-id="5145722706-4">(</span><span class="n">n</span><span class="p" data-group-id="5145722706-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">abs</span><span class="p" data-group-id="5145722706-5">(</span><span class="n">n</span><span class="p" data-group-id="5145722706-5">)</span><span class="w">
</span><span class="k" data-group-id="5145722706-1">end</span><span class="w">

</span><span class="c1"># in OverWriteAdd user module</span><span class="w">
</span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5145722706-6">[</span><span class="ss">+</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5145722706-6">]</span><span class="w">
</span><span class="kn">import</span><span class="w"> </span><span class="nc">OverWriteAdd</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5145722706-7">[</span><span class="ss">+</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5145722706-7">]</span><span class="w">
</span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="c1">#...</span></code></pre><p>在每次使用 <code class="inline">OverWriteAdd</code> 的时候, 都需要写 <code class="inline">Kernel, except: ...</code>, 语法上有些啰嗦,
为了减少冗余, 可以在 <code class="inline">OverWriteAdd</code> 模块中添加宏 <code class="inline">__using__</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="6134401628-1">(</span><span class="c">_opt</span><span class="p" data-group-id="6134401628-1">)</span><span class="w"> </span><span class="k" data-group-id="6134401628-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6134401628-3">do</span><span class="w">
    </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6134401628-4">[</span><span class="ss">+</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6134401628-4">]</span><span class="w">
    </span><span class="kn">import</span><span class="w"> </span><span class="nc">OverWriteAdd</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6134401628-5">[</span><span class="ss">+</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6134401628-5">]</span><span class="w">
  </span><span class="k" data-group-id="6134401628-3">end</span><span class="w">
</span><span class="k" data-group-id="6134401628-2">end</span></code></pre><p>然后客户端使用一行代码: <code class="inline">use OverWriteAdd</code> 就可以了, 而不用写两行代码了.</p><h3 id="缺失的部分" class="section-heading">
  <a href="#缺失的部分" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">缺失的部分</p>
  </a>
  缺失的部分
</h3>
<p>在 Javascript 中, <code class="inline">import</code> 语句, 除了按照定义模块中定义的函数名导入函数,
还可以为导入的函数重命名.</p><p>在 Elxiir 中, 缺少这样的语法. <a href="https://hexdocs.pm/elixir/Kernel.html#defdelegate/2"><code class="inline">Kernel.defdelegate/2</code></a> 宏, 
完成的功能和这里的描述的功能非常类似, 但是做的多了一点点,
<a href="https://hexdocs.pm/elixir/Kernel.html#defdelegate/2"><code class="inline">defdelegate/2</code></a> 不但可以为函数改名字, 而且还导出了这个函数.</p><p><a href="https://hexdocs.pm/elixir/Kernel.html#defdelegate/2"><code class="inline">defdelegate/2</code></a> 做的多了一点点. 因为这里的需求只是希望在模块内以自己提供名字,
来调用导入的函数, 而不是把这个函数作作为模块导出函数的一部分.</p><p>也就是说, 需要提供一个对导入函数在模块内, 重命名的机制.
我们可以定义 <code class="inline">rename</code> 宏来实现.
<code class="inline">rename</code> 有两种格式:</p><ul><li>指定函数的参数个数: <code class="inline">rename ModuleName.fun_name/arity, to: new_fun_name</code>.</li><li>不指定函数的参数个数: <code class="inline">rename ModuleName.fun_name, to: new_fun_name</code>.</li></ul><p>使用第二中格式时, 如果模块中有多个同名的函数, 那么这几个函数都会导入的当前的上下文中.</p><p>实际上, <code class="inline">rename</code> 是在当前的上下文中定义私有函数. 所以 <code class="inline">rename</code> 
必须在模块的上下文中才可以使用.
<code class="inline">rename</code> 宏通过 <code class="inline">do_rename</code> 函数来完成工作.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Rename</span><span class="w"> </span><span class="k" data-group-id="7974375876-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">rename</span><span class="p" data-group-id="7974375876-2">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">new_name</span><span class="p" data-group-id="7974375876-2">)</span><span class="w"> </span><span class="k" data-group-id="7974375876-3">do</span><span class="w">
    </span><span class="n">do_rename</span><span class="p" data-group-id="7974375876-4">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">new_name</span><span class="p" data-group-id="7974375876-4">)</span><span class="w">
  </span><span class="k" data-group-id="7974375876-3">end</span><span class="w">
  </span><span class="c1">#...</span><span class="w">
</span><span class="k" data-group-id="7974375876-1">end</span></code></pre><p><code class="inline">do_rename</code> 函数对 <code class="inline">rename</code> 的两种用法, 使用两个分句, 分别处理.
我们先来看指定参数格式的处理:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">do_rename</span><span class="p" data-group-id="9034874854-1">(</span><span class="p" data-group-id="9034874854-2">{</span><span class="ss">:/</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9034874854-3">[</span><span class="n">m_f</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="9034874854-3">]</span><span class="p" data-group-id="9034874854-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9034874854-4">{</span><span class="n">new_name</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9034874854-4">}</span><span class="p" data-group-id="9034874854-1">)</span><span class="w"> </span><span class="k" data-group-id="9034874854-5">do</span><span class="w">
  </span><span class="p" data-group-id="9034874854-6">{</span><span class="p" data-group-id="9034874854-7">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9034874854-8">[</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="9034874854-8">]</span><span class="p" data-group-id="9034874854-7">}</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9034874854-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_f</span><span class="w">
  </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_private</span><span class="p" data-group-id="9034874854-9">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p">,</span><span class="w"> </span><span class="n">new_name</span><span class="p" data-group-id="9034874854-9">)</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9034874854-10">do</span><span class="w">
    </span><span class="p" data-group-id="9034874854-11">(</span><span class="k">unquote_splicing</span><span class="p" data-group-id="9034874854-12">(</span><span class="n">ast</span><span class="p" data-group-id="9034874854-12">)</span><span class="p" data-group-id="9034874854-11">)</span><span class="w">
  </span><span class="k" data-group-id="9034874854-10">end</span><span class="w">
</span><span class="k" data-group-id="9034874854-5">end</span></code></pre><p>这个函数做的工作非常的简单, 从参数中提取模块, 函数, 参数格式, 以及要重定义的函数名,
然后使用 <code class="inline">make_private/4</code> 来定义匿名函数就好了.</p><p><code class="inline">make_private/4</code> 返回的抽象语法树, 保存与一个列表中, 所以最后, 使用
<code class="inline">unquote_splice/1</code> 去掉外层的列表, 而只保留定义使用函数的抽象语法树.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">make_private</span><span class="p" data-group-id="9595443745-1">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p">,</span><span class="w"> </span><span class="n">new_name</span><span class="p" data-group-id="9595443745-1">)</span><span class="w"> </span><span class="k" data-group-id="9595443745-2">do</span><span class="w">
  </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">generate_arguments</span><span class="p" data-group-id="9595443745-3">(</span><span class="n">arity</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="9595443745-3">)</span><span class="w">
  </span><span class="p" data-group-id="9595443745-4">{</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">asts</span><span class="p" data-group-id="9595443745-4">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9595443745-5">do</span><span class="w">
      </span><span class="na">@compile</span><span class="w"> </span><span class="ss">online</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
      </span><span class="kd">defp</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9595443745-6">(</span><span class="n">new_name</span><span class="p" data-group-id="9595443745-6">)</span><span class="p" data-group-id="9595443745-7">(</span><span class="k">unquote_splicing</span><span class="p" data-group-id="9595443745-8">(</span><span class="n">args</span><span class="p" data-group-id="9595443745-8">)</span><span class="p" data-group-id="9595443745-7">)</span><span class="w"> </span><span class="k" data-group-id="9595443745-9">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="9595443745-10">(</span><span class="n">module</span><span class="p" data-group-id="9595443745-10">)</span><span class="o">.</span><span class="k">unquote</span><span class="p" data-group-id="9595443745-11">(</span><span class="n">fun</span><span class="p" data-group-id="9595443745-11">)</span><span class="p" data-group-id="9595443745-12">(</span><span class="k">unquote_splicing</span><span class="p" data-group-id="9595443745-13">(</span><span class="n">args</span><span class="p" data-group-id="9595443745-13">)</span><span class="p" data-group-id="9595443745-12">)</span><span class="w">
      </span><span class="k" data-group-id="9595443745-9">end</span><span class="w">
    </span><span class="k" data-group-id="9595443745-5">end</span><span class="w">
  </span><span class="n">asts</span><span class="w">
</span><span class="k" data-group-id="9595443745-2">end</span></code></pre><p><code class="inline">make_private</code> 也足够直白, 只是以 <code class="inline">new_name</code> 来代理对被重命名的函数调用而已.</p><p><code class="inline">quote/1</code> 中有多个表达式时, <code class="inline">quote/1</code> 返回一个块表达式.</p><p><code class="inline">make_private</code> 返回的是多个语句的抽象语法树, 而不是块表达式的抽象语法树.</p><p><code class="inline">rename</code> 不带参数个数的用法有 <code class="inline">do_rename</code> 的第二个分句处理:
因为参数中不提供参数个数, 所以 <code class="inline">do_rename</code> 首先需要从模块中提取对应函数的参数个数.
然后依次定义私有函数就好了.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">do_rename</span><span class="p" data-group-id="3578236597-1">(</span><span class="p" data-group-id="3578236597-2">{</span><span class="p" data-group-id="3578236597-3">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">m_f</span><span class="p" data-group-id="3578236597-3">}</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3578236597-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3578236597-4">{</span><span class="n">new_name</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3578236597-4">}</span><span class="p" data-group-id="3578236597-1">)</span><span class="w"> </span><span class="k" data-group-id="3578236597-5">do</span><span class="w">
  </span><span class="p" data-group-id="3578236597-6">[</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun_name</span><span class="p" data-group-id="3578236597-6">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_f</span><span class="w">
  </span><span class="n">aritys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_aritys</span><span class="p" data-group-id="3578236597-7">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun_name</span><span class="p" data-group-id="3578236597-7">)</span><span class="w">
  </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="n">arity</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">aritys</span><span class="w"> </span><span class="k" data-group-id="3578236597-8">do</span><span class="w">
      </span><span class="n">make_private</span><span class="p" data-group-id="3578236597-9">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p">,</span><span class="w"> </span><span class="n">new_name</span><span class="p" data-group-id="3578236597-9">)</span><span class="w">
    </span><span class="k" data-group-id="3578236597-8">end</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">List</span><span class="o">.</span><span class="n">flatten</span><span class="p" data-group-id="3578236597-10">(</span><span class="p" data-group-id="3578236597-10">)</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3578236597-11">do</span><span class="w">
    </span><span class="p" data-group-id="3578236597-12">(</span><span class="k">unquote_splicing</span><span class="p" data-group-id="3578236597-13">(</span><span class="n">ast</span><span class="p" data-group-id="3578236597-13">)</span><span class="p" data-group-id="3578236597-12">)</span><span class="w">
  </span><span class="k" data-group-id="3578236597-11">end</span><span class="w">
</span><span class="k" data-group-id="3578236597-5">end</span></code></pre><p>需要注意的是, 上面代码中的 <code class="inline">module</code>, <code class="inline">fun_name</code> 都是抽象语法树,
所以不能直接通过 <code class="inline">module.module_info(:exports)</code> 来获取模块导出函数的信息.
<code class="inline">get_aritys/2</code> 函数用来获取 <code class="inline">module</code> 中名为 <code class="inline">fun</code> 的所有函数的参数个数.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">get_aritys</span><span class="p" data-group-id="0311116026-1">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="0311116026-1">)</span><span class="w"> </span><span class="k" data-group-id="0311116026-2">do</span><span class="w">
  </span><span class="p" data-group-id="0311116026-3">{</span><span class="n">aritys</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="0311116026-3">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0311116026-4">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="0311116026-5">(</span><span class="n">module</span><span class="p" data-group-id="0311116026-5">)</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="0311116026-6">(</span><span class="ss">:exports</span><span class="p" data-group-id="0311116026-6">)</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="0311116026-7">(</span><span class="k" data-group-id="0311116026-8">fn</span><span class="w"> </span><span class="p" data-group-id="0311116026-9">{</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="c">_v</span><span class="p" data-group-id="0311116026-9">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0311116026-10">(</span><span class="n">fun</span><span class="p" data-group-id="0311116026-10">)</span><span class="w"> </span><span class="k" data-group-id="0311116026-8">end</span><span class="p" data-group-id="0311116026-7">)</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0311116026-11">(</span><span class="k" data-group-id="0311116026-12">fn</span><span class="w"> </span><span class="p" data-group-id="0311116026-13">{</span><span class="c">_key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="0311116026-13">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k" data-group-id="0311116026-12">end</span><span class="p" data-group-id="0311116026-11">)</span><span class="w">
    </span><span class="k" data-group-id="0311116026-4">end</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="0311116026-14">(</span><span class="p" data-group-id="0311116026-14">)</span><span class="w">
  </span><span class="n">aritys</span><span class="w">
</span><span class="k" data-group-id="0311116026-2">end</span></code></pre><p>在编译时, 实际上还时需要执行 <code class="inline">module.module_info(:exports)</code> 调用,
所以 <code class="inline">module</code> 代表的模块, 在调用 <code class="inline">rename</code> 之前必须已经定义完成.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">get_aritys</span><span class="p" data-group-id="8276843780-1">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="8276843780-1">)</span><span class="w"> </span><span class="k" data-group-id="8276843780-2">do</span><span class="w">
  </span><span class="p" data-group-id="8276843780-3">{</span><span class="n">aritys</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8276843780-3">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8276843780-4">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="8276843780-5">(</span><span class="n">module</span><span class="p" data-group-id="8276843780-5">)</span><span class="o">.</span><span class="n">module_info</span><span class="p" data-group-id="8276843780-6">(</span><span class="ss">:exports</span><span class="p" data-group-id="8276843780-6">)</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="8276843780-7">(</span><span class="k" data-group-id="8276843780-8">fn</span><span class="w"> </span><span class="p" data-group-id="8276843780-9">{</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="c">_v</span><span class="p" data-group-id="8276843780-9">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8276843780-10">(</span><span class="n">fun</span><span class="p" data-group-id="8276843780-10">)</span><span class="w"> </span><span class="k" data-group-id="8276843780-8">end</span><span class="p" data-group-id="8276843780-7">)</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="8276843780-11">(</span><span class="k" data-group-id="8276843780-12">fn</span><span class="w"> </span><span class="p" data-group-id="8276843780-13">{</span><span class="c">_key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="8276843780-13">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k" data-group-id="8276843780-12">end</span><span class="p" data-group-id="8276843780-11">)</span><span class="w">
    </span><span class="k" data-group-id="8276843780-4">end</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="8276843780-14">(</span><span class="p" data-group-id="8276843780-14">)</span><span class="w">
  </span><span class="n">aritys</span><span class="w">
</span><span class="k" data-group-id="8276843780-2">end</span></code></pre><p>然后, 就可以这样来使用 <code class="inline">rename</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">RenameTest</span><span class="w"> </span><span class="k" data-group-id="7460313201-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.Rename</span><span class="w">
  </span><span class="n">rename</span><span class="p" data-group-id="7460313201-2">(</span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="p" data-group-id="7460313201-3">(</span><span class="p" data-group-id="7460313201-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">str_len</span><span class="p" data-group-id="7460313201-2">)</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">test</span><span class="p" data-group-id="7460313201-4">(</span><span class="p" data-group-id="7460313201-4">)</span><span class="w"> </span><span class="k" data-group-id="7460313201-5">do</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">
    </span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="p" data-group-id="7460313201-6">(</span><span class="n">a</span><span class="p" data-group-id="7460313201-6">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">str_len</span><span class="p" data-group-id="7460313201-7">(</span><span class="n">a</span><span class="p" data-group-id="7460313201-7">)</span><span class="w">
  </span><span class="k" data-group-id="7460313201-5">end</span><span class="w">
</span><span class="k" data-group-id="7460313201-1">end</span><span class="w">

</span><span class="nc">RenameTest</span><span class="o">.</span><span class="n">test</span><span class="p" data-group-id="7460313201-8">(</span><span class="p" data-group-id="7460313201-8">)</span><span class="w"> </span><span class="c1">#true</span></code></pre><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>Elixir 被废弃的 <a href="https://hexdocs.pm/elixir/Behaviour.html"><code class="inline">Behaviour</code></a> 模块就是为了帮助我们定义自己的
<code class="inline">behaviour_info</code> 函数. 现在因为 Erlang 支持 <code class="inline">-callback</code> 模块属性,
所以 Elixir 也废弃了 <a href="https://hexdocs.pm/elixir/Behaviour.html"><code class="inline">Behaviour</code></a> 模块, 而启用了新的 <code class="inline">@callback</code> 内置模块属性.</p></li><li id="fn:2"><a class="reversefootnote" href="#fnref:2" title="return to article">&amp;#x21A9;</a><p><a href="https://github.com/arjan/decorator">https://github.com/arjan/decorator</a></p></li><li id="fn:3"><a class="reversefootnote" href="#fnref:3" title="return to article">&amp;#x21A9;</a><p>见源码<a href="https://github.com/arjan/decorator/blob/a32053ae884014320940d2a8cefe55181203db93/lib/decorator/decorate.ex#L20">第 20 行</a></p></li><li id="fn:4"><a class="reversefootnote" href="#fnref:4" title="return to article">&amp;#x21A9;</a><p>见源码<a href="https://github.com/arjan/decorator/blob/a32053ae884014320940d2a8cefe55181203db93/lib/decorator/decorate.ex#L37">第37, 38行</a></p></li><li id="fn:5"><a class="reversefootnote" href="#fnref:5" title="return to article">&amp;#x21A9;</a><p>持久化属性值在编程中的使用, 见后面的<a href="chx-cold_knowledge.html">冷知识章节</a>.</p></li><li id="fn:6"><a class="reversefootnote" href="#fnref:6" title="return to article">&amp;#x21A9;</a><p>见<a href="https://hexdocs.pm/elixir/1.13.1/Kernel.html#defstruct/1">Kernel 模块文档 destruct/1 相关内容</a></p></li><li id="fn:7"><a class="reversefootnote" href="#fnref:7" title="return to article">&amp;#x21A9;</a><p>见 Erlang 参考文档, <a href="https://www.erlang.org/doc/reference_manual/modules.html#module_info-1">模块章节</a>.</p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch08-error_handle.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第八章 错误处理
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch10-protocol_and_behaviour.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第十章 协议与行为
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
