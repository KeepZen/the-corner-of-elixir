<!DOCTYPE html>
<html lang="encn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="The Corner of Elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第五章 定制新结构 — The Corner of Elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-b363241ec9.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="https://keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
The Corner of Elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch05.new_constructor.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第五章 定制新结构</span>
</h1>

<h2 id="定义自己的控制控制结构" class="section-heading">
  <a href="#定义自己的控制控制结构" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">定义自己的控制控制结构</p>
  </a>
  定义自己的控制控制结构
</h2>
<p>Elixir 是一个特别灵活的语言, 这不但是说, Elixir 本身提供的语法结构非常灵活,
更加重要的是, 如果我们不满意 Elixir 提供的控制结构, 那么可以按照自己的意图,
来定义自己的控制结构.</p><h2 id="赋值" class="section-heading">
  <a href="#赋值" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">赋值</p>
  </a>
  赋值
</h2>
<h3 id="赋值与思维流" class="section-heading">
  <a href="#赋值与思维流" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">赋值与思维流</p>
  </a>
  赋值与思维流
</h3>
<p>确切的说, <code class="inline">=</code> 叫做匹配操作符, 而不是赋值操作符.
但是变量可以匹配任意的值, 所以实际上, Elixir 中还是用 <code class="inline">=</code> 来做赋值的操作.</p><p>在其他编程语言中, 赋值是一个非常简单的操作, 因为赋值语句非常简短,
基本上一眼就能看清楚赋值的结果是什么.</p><p>其他语言中, 块语句不是表达式, 但是在 Elixir 中语句块也是表达式.
当赋值语句的右侧出现的是语句块的时候, 代码序列往往和思维序列不协调.</p><p>首先让我来描述一下, 我阅读这样代码时的思维过程.
因为是一个块语句, 也就是说 <code class="inline">=</code> 的右边需要多个步骤, 多个操作才能完成最后的结果.
阅读代码的时候, 思维自然要跟随代码, 以理解代码的意图.
当多个步骤执行完成后, 在我的思维中, 往往忘记了 <code class="inline">=</code> 
的左边的表达式是什么了, 因为最后结果和变量之间的距离太远了, 这个距离既是物理上的,
也是心理上的.</p><p>而写一个块语句的时候, 在完成整个功能之前, 实际上我不知道最后的结果会是什么,
甚至不知道, 这个块语句就是函数最后的结果, 还是只是计算的中间过程.
所以基本上, 我也是先完成块语句然后再决定是否需要把结果赋值给一个变量的.</p><p>当我意识到需要把块语句的结果赋值给一个变量的时候,
这时候光标往往是停留在块语句的结尾处, 要完成赋值语法, 只好移动光标,
这让我有些烦恼.</p><p>我更希望写出的代码能和思维流一致, 这样写代码的时候流畅, 阅读的时候也更轻松.</p><h3 id="设计赋值语句" class="section-heading">
  <a href="#设计赋值语句" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">设计赋值语句</p>
  </a>
  设计赋值语句
</h3>
<p>Elixir 支持宏编程, 这就给我们提供了设计自己的赋值语句提供了可能.
但是 <code class="inline">=</code> 是一个特殊形式, 所以不能从新定义它, 而只能利用 <code class="inline">=</code>
提供的功能, 来重新设计新的语法糖.</p><p>首先让我来描述清楚, 我想要的语法是什么样的.</p><pre><code class="makeup elixir" translate="no"><span class="k">if</span><span class="w"> </span><span class="n">exprestion</span><span class="w"> </span><span class="k" data-group-id="3830285669-1">do</span><span class="w">
  </span><span class="ss">:zero</span><span class="w">
</span><span class="k" data-group-id="3830285669-1">else</span><span class="w">
  </span><span class="ss">:is_not_zero</span><span class="w">
</span><span class="k" data-group-id="3830285669-1">end</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="3830285669-2">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="3830285669-2">)</span></code></pre><p>这样简单的, 可以使用 Elixir 提供的语法直接转化成为一行的代码:
 <code class="inline">v = if exprestion, do: :zero, else: :is_not_zero</code>.
这个时候使用 <code class="inline">assign/2</code> 是没有必要的. 但是当 <code class="inline">if</code> 语句不能转化成一行的代码时候,
或者当需要把 <code class="inline">case</code> 或 <code class="inline">cond</code> 结果赋值为一个变量的时候,
代码序列和思维流之间的阻抗就更加的明显了. 这个时候,
使用 <code class="inline">assign/2</code> 能让代码易写易读.</p><p>假设我们要控制一个机器人, 机器人使用一个 GenServer 表示,
它的状态是 <code class="inline">%{x: x, y: y, diriction: direction}</code>,
表示机器人所在的位置 <code class="inline">x, y</code> 和面对的方向
(<code class="inline">:E</code>, 东方; <code class="inline">:W</code>, 西方;<code class="inline">:N</code>, 北方; <code class="inline">:S</code>, 南方).
当机器人接受到转弯的指令后, 就会按照指令转弯, 从而改变自己的状态.
那么处理右转的代码就是这样:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">handler_cast</span><span class="p" data-group-id="3439921789-1">(</span><span class="p" data-group-id="3439921789-2">{</span><span class="ss">:turn</span><span class="p">,</span><span class="w"> </span><span class="ss">:right</span><span class="p" data-group-id="3439921789-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3439921789-3">%{</span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p" data-group-id="3439921789-3">}</span><span class="o">=</span><span class="n">state</span><span class="p" data-group-id="3439921789-1">)</span><span class="w"> </span><span class="k" data-group-id="3439921789-4">do</span><span class="w">
   </span><span class="n">direct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">direct</span><span class="w"> </span><span class="k" data-group-id="3439921789-5">do</span><span class="w">
     </span><span class="ss">:N</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:E</span><span class="w">
     </span><span class="ss">:E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:S</span><span class="w">
     </span><span class="ss">:S</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:W</span><span class="w">
     </span><span class="ss">:W</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:N</span><span class="w">
   </span><span class="k" data-group-id="3439921789-5">end</span><span class="w">

   </span><span class="p" data-group-id="3439921789-6">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3439921789-7">%{</span><span class="n">state</span><span class="o">|</span><span class="w"> </span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">dircet</span><span class="p" data-group-id="3439921789-7">}</span><span class="p" data-group-id="3439921789-6">}</span><span class="w">
</span><span class="k" data-group-id="3439921789-4">end</span></code></pre><p>那么在 <code class="inline">assign/2</code> 的帮助下, 可以把上面的代码重构为:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">handler_cast</span><span class="p" data-group-id="6794129227-1">(</span><span class="p" data-group-id="6794129227-2">{</span><span class="ss">:turn</span><span class="p">,</span><span class="w"> </span><span class="ss">:right</span><span class="p" data-group-id="6794129227-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6794129227-3">%{</span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p" data-group-id="6794129227-3">}</span><span class="o">=</span><span class="n">state</span><span class="p" data-group-id="6794129227-1">)</span><span class="w"> </span><span class="k" data-group-id="6794129227-4">do</span><span class="w">
   </span><span class="k">case</span><span class="w"> </span><span class="n">direct</span><span class="w"> </span><span class="k" data-group-id="6794129227-5">do</span><span class="w">
     </span><span class="ss">:N</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:E</span><span class="w">
     </span><span class="ss">:E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:S</span><span class="w">
     </span><span class="ss">:S</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:W</span><span class="w">
     </span><span class="ss">:W</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:N</span><span class="w">
   </span><span class="k" data-group-id="6794129227-5">end</span><span class="w">
   </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="6794129227-6">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p" data-group-id="6794129227-6">)</span><span class="w">

   </span><span class="p" data-group-id="6794129227-7">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6794129227-8">%{</span><span class="n">state</span><span class="o">|</span><span class="w"> </span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">dircet</span><span class="p" data-group-id="6794129227-8">}</span><span class="p" data-group-id="6794129227-7">}</span><span class="w">
</span><span class="k" data-group-id="6794129227-4">end</span></code></pre><p>这样的代码整洁了不少吧? 现在让我们来看看, 如何来实现 <code class="inline">assgin/2</code>.</p><h3 id="赋值实现" class="section-heading">
  <a href="#赋值实现" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">赋值实现</p>
  </a>
  赋值实现
</h3>
<p>我们需要把 <code class="inline">assgin/2</code> 定义为一个宏, 这个宏的功能非常的简单, 只是 <code class="inline">=</code> 的语法糖嘛, 所以可以这样来实现.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Assign</span><span class="w"> </span><span class="k" data-group-id="8647086580-1">do</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_assign</span><span class="p" data-group-id="8647086580-2">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">pattern</span><span class="p" data-group-id="8647086580-2">)</span><span class="w"> </span><span class="k" data-group-id="8647086580-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8647086580-4">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="8647086580-5">(</span><span class="n">pattern</span><span class="p" data-group-id="8647086580-5">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8647086580-6">(</span><span class="n">value</span><span class="p" data-group-id="8647086580-6">)</span><span class="w">
    </span><span class="k" data-group-id="8647086580-4">end</span><span class="w">
  </span><span class="k" data-group-id="8647086580-3">end</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assign</span><span class="p" data-group-id="8647086580-7">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">pattern</span><span class="p" data-group-id="8647086580-7">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">do_assign</span><span class="p" data-group-id="8647086580-8">(</span><span class="n">value</span><span class="p">,</span><span class="n">pattern</span><span class="p" data-group-id="8647086580-8">)</span><span class="w">
  </span><span class="c1">#...other</span><span class="w">
</span><span class="k" data-group-id="8647086580-1">end</span></code></pre><p>这个实现, 完成了我们期望的工作.</p><p>这里 <code class="inline">assign/2</code> 并不改变直接使用 <code class="inline">=</code> 的语义代码的语义.
调用 <code class="inline">assign(value, to: pattern)</code>,
当 <code class="inline">pattern</code> 和 <code class="inline">value</code> 不匹配的时候, 依旧会抛出匹配错误,</p><p>因为 <code class="inline">assign(value, to: pattern)</code> 本质上就是 <code class="inline">pattern = value</code>,
所以任何可以作为匹配操作符 <code class="inline">=</code> 左值的语法, 都可以作为 <code class="inline">assign/2</code> 的 <code class="inline">:to</code> 的值,
毕竟 <code class="inline">assign/2</code> 仅仅是语法糖.</p><p>这样的语法糖, 让代码更简洁, 美观, 如此而已.</p><p><code class="inline">assgin/2</code> 现在帮助我们减少了代码的序列和思维流之间的阻抗,
但是像上面对 <code class="inline">hanlder_cast/2</code> 的重构那样,
最后的返回语句不能使用管道操作符 <code class="inline">|&gt;</code> 连接起来, 这样的代码序列,
反映到思维流上, 就是思维流的打断.</p><p>如果 <code class="inline">assign/2</code> 能帮助我们把思维流也接续起来, 那么写 elixir 代码就更加愉悦了.</p><p>能让思维流保持连续的代码, 我认为是这样的:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">handler_cast</span><span class="p" data-group-id="3842947301-1">(</span><span class="p" data-group-id="3842947301-2">{</span><span class="ss">:trun</span><span class="p">,</span><span class="w"> </span><span class="ss">:right</span><span class="p" data-group-id="3842947301-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3842947301-3">%{</span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p" data-group-id="3842947301-3">}</span><span class="o">=</span><span class="n">state</span><span class="p" data-group-id="3842947301-1">)</span><span class="w"> </span><span class="k" data-group-id="3842947301-4">do</span><span class="w">
   </span><span class="k">case</span><span class="w"> </span><span class="n">direct</span><span class="w"> </span><span class="k" data-group-id="3842947301-5">do</span><span class="w">
     </span><span class="ss">:N</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:E</span><span class="w">
     </span><span class="ss">:E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:S</span><span class="w">
     </span><span class="ss">:S</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:W</span><span class="w">
     </span><span class="ss">:W</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:N</span><span class="w">
   </span><span class="k" data-group-id="3842947301-5">end</span><span class="w">
   </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="3842947301-6">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3842947301-7">%{</span><span class="n">state</span><span class="o">|</span><span class="w"> </span><span class="ss">direct</span><span class="p">:</span><span class="w"> </span><span class="n">direct</span><span class="p" data-group-id="3842947301-7">}</span><span class="p" data-group-id="3842947301-6">)</span><span class="w">
</span><span class="k" data-group-id="3842947301-4">end</span></code></pre><p>再假设有现在我们有三个函数, 分别是 <code class="inline">step1:: ()-&gt;any</code>,
<code class="inline">step2:: (any) -&gt;{:ok,t}|{:error,any}</code> 和 <code class="inline">step3::(t)-&gt;any</code>.
<code class="inline">step1</code> 的结果作为 <code class="inline">step2</code> 的输入, <code class="inline">step2</code> 返回 <code class="inline">{:ok,v}</code> 时.
<code class="inline">v</code> 作为 <code class="inline">step3</code> 输入.
那么无论是:</p><pre><code class="elxiir">{:ok, v} = step1()
|&gt; step2()

step3(v)</code></pre><p>还是:</p><pre><code class="makeup elixir" translate="no"><span class="n">step1</span><span class="p" data-group-id="3714162301-1">(</span><span class="p" data-group-id="3714162301-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step2</span><span class="p" data-group-id="3714162301-2">(</span><span class="p" data-group-id="3714162301-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="3714162301-3">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3714162301-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="3714162301-4">}</span><span class="p" data-group-id="3714162301-3">)</span><span class="w">

</span><span class="n">step3</span><span class="p" data-group-id="3714162301-5">(</span><span class="n">v</span><span class="p" data-group-id="3714162301-5">)</span></code></pre><p>阅读的时候, 思维流都是被打断的.
但如果 <code class="inline">assign</code> 允许我们写下面的代码, 就能让思维流保持连续.</p><pre><code class="makeup elixir" translate="no"><span class="n">step1</span><span class="p" data-group-id="0474953315-1">(</span><span class="p" data-group-id="0474953315-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step2</span><span class="p" data-group-id="0474953315-2">(</span><span class="p" data-group-id="0474953315-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="0474953315-3">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0474953315-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="0474953315-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="0474953315-3">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step3</span><span class="p" data-group-id="0474953315-5">(</span><span class="p" data-group-id="0474953315-5">)</span></code></pre><p>也就是说, 为<code class="inline">assign/2</code> 在添加一个可省略的 <code class="inline">:do</code> 选项, 就能让思维流接续起来.</p><p>这个实现也非常的容易, 当我们完成 <code class="inline">pattern = value</code> 的赋值后, 再计算 <code class="inline">do: expression</code>
的值可以了.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Assign</span><span class="w"> </span><span class="k" data-group-id="9684507841-1">do</span><span class="w">
  </span><span class="c1">#assing(value, to: pattern)</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_assign</span><span class="p" data-group-id="9684507841-2">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="9684507841-2">)</span><span class="w"> </span><span class="k" data-group-id="9684507841-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9684507841-4">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="9684507841-5">(</span><span class="n">pattern</span><span class="p" data-group-id="9684507841-5">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9684507841-6">(</span><span class="n">value</span><span class="p" data-group-id="9684507841-6">)</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="9684507841-7">(</span><span class="n">block</span><span class="p" data-group-id="9684507841-7">)</span><span class="w">
    </span><span class="k" data-group-id="9684507841-4">end</span><span class="w">
  </span><span class="k" data-group-id="9684507841-3">end</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assign</span><span class="p" data-group-id="9684507841-8">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="9684507841-8">)</span><span class="w"> </span><span class="k" data-group-id="9684507841-9">do</span><span class="w">
    </span><span class="n">do_assign</span><span class="p" data-group-id="9684507841-10">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="9684507841-10">)</span><span class="w">
  </span><span class="k" data-group-id="9684507841-9">end</span><span class="w">
  </span><span class="c1">#...</span><span class="w">
</span><span class="k" data-group-id="9684507841-1">end</span></code></pre><p>有了 <code class="inline">assgin(value,to: pattern, do: block)</code> 的帮助,
上面的多步骤组合的代码就可以这样来写.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Demo</span><span class="w"> </span><span class="k" data-group-id="9828837268-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.Assgin</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9828837268-2">[</span><span class="ss">assign</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="9828837268-2">]</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">step1</span><span class="p" data-group-id="9828837268-3">(</span><span class="p" data-group-id="9828837268-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">step2</span><span class="p" data-group-id="9828837268-4">(</span><span class="n">v</span><span class="p" data-group-id="9828837268-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9828837268-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9828837268-5">}</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">step3</span><span class="p" data-group-id="9828837268-6">(</span><span class="n">v</span><span class="p" data-group-id="9828837268-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="9828837268-7">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;in step3 v&quot;</span><span class="p" data-group-id="9828837268-7">)</span><span class="w">
  
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">do_work</span><span class="p" data-group-id="9828837268-8">(</span><span class="p" data-group-id="9828837268-8">)</span><span class="w"> </span><span class="k" data-group-id="9828837268-9">do</span><span class="w">
    </span><span class="n">step1</span><span class="p" data-group-id="9828837268-10">(</span><span class="p" data-group-id="9828837268-10">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step2</span><span class="p" data-group-id="9828837268-11">(</span><span class="p" data-group-id="9828837268-11">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="9828837268-12">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;after setp2&quot;</span><span class="p" data-group-id="9828837268-12">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="9828837268-13">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9828837268-14">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="9828837268-14">}</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="9828837268-13">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="9828837268-15">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;after assign/2&quot;</span><span class="p" data-group-id="9828837268-15">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step3</span><span class="p" data-group-id="9828837268-16">(</span><span class="p" data-group-id="9828837268-16">)</span><span class="w">
  </span><span class="k" data-group-id="9828837268-9">end</span><span class="w">
</span><span class="k" data-group-id="9828837268-1">end</span><span class="w">

</span><span class="nc">Demo</span><span class="o">.</span><span class="n">do_work</span><span class="p" data-group-id="9828837268-17">(</span><span class="p" data-group-id="9828837268-17">)</span><span class="w">
</span><span class="c1">#after setp2 : {:ok, 2}</span><span class="w">
</span><span class="c1">#after assign/2 : 2</span><span class="w">
</span><span class="c1">#in step3 v: 2</span></code></pre><p>在 <code class="inline">assign/2</code> 的帮助下, 我们写的 Elixir 代码, 几乎也可以做到 point-free 了.</p><p>如果赋值之后, 我们需要做非常多的计算, 那么使用 <code class="inline">do: (...)</code> 就不那么方便,
对这种情况, 可以非常简单的提供一个 <code class="inline">assign(value, [to: pattern] ,do: block)</code>
宏来解决.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assign</span><span class="p" data-group-id="6789294632-1">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6789294632-2">[</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">pattern</span><span class="p" data-group-id="6789294632-2">]</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="6789294632-1">)</span><span class="w"> </span><span class="k" data-group-id="6789294632-3">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="ss">generated</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="k" data-group-id="6789294632-4">do</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="6789294632-5">(</span><span class="n">pattern</span><span class="p" data-group-id="6789294632-5">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6789294632-6">(</span><span class="n">value</span><span class="p" data-group-id="6789294632-6">)</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="6789294632-7">(</span><span class="n">expression</span><span class="p" data-group-id="6789294632-7">)</span><span class="w">
  </span><span class="k" data-group-id="6789294632-4">end</span><span class="w">
</span><span class="k" data-group-id="6789294632-3">end</span></code></pre><p>在导入我们的宏之后, 就可以如此来使用赋值语句了:</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.Assign</span><span class="w">
</span><span class="n">function</span><span class="p" data-group-id="4413497150-1">(</span><span class="p" data-group-id="4413497150-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assing</span><span class="p" data-group-id="4413497150-2">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4413497150-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="4413497150-3">}</span><span class="p" data-group-id="4413497150-2">)</span><span class="w"> </span><span class="k" data-group-id="4413497150-4">do</span><span class="w">
  </span><span class="n">do_lot_of_work_with</span><span class="p" data-group-id="4413497150-5">(</span><span class="n">v</span><span class="p" data-group-id="4413497150-5">)</span><span class="w">
</span><span class="k" data-group-id="4413497150-4">end</span></code></pre><p>可以看出, 在管道操作符右侧, 使用 <code class="inline">do-end</code> 块会使得代码编码的不那么整齐.
所以最终的库中, 我没有提供 <code class="inline">assign/3</code> 这个宏.</p><p>正常的情况下, 使用 <code class="inline">:do</code> 选项中应该只有一个表达式.
如果发现 <code class="inline">:do</code> 选项中, 需要两个或更多的表达式才能完成最终的工作,
那么第一种选择是把 <code class="inline">:do</code> 选项中的语句提取为一个新的函数.
第二种选择是在 <code class="inline">:do</code> 使用变量,绑定中间结果.
然后在后续的代码中, 使用变量绑定的值, 完成剩余的工作.</p><pre><code class="makeup elixir" translate="no"><span class="n">step0</span><span class="p" data-group-id="6786459909-1">(</span><span class="p" data-group-id="6786459909-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step1</span><span class="p" data-group-id="6786459909-2">(</span><span class="p" data-group-id="6786459909-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assgin</span><span class="p" data-group-id="6786459909-3">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6786459909-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="6786459909-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="6786459909-3">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">extract_function_from_do</span><span class="p" data-group-id="6786459909-5">(</span><span class="p" data-group-id="6786459909-5">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step2</span><span class="p" data-group-id="6786459909-6">(</span><span class="p" data-group-id="6786459909-6">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">...</span></code></pre><p>或者</p><pre><code class="makeup elixir" translate="no"><span class="n">step0</span><span class="p" data-group-id="7592088080-1">(</span><span class="p" data-group-id="7592088080-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="7592088080-2">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7592088080-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="7592088080-3">}</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">tem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_sample_with</span><span class="p" data-group-id="7592088080-4">(</span><span class="n">v</span><span class="p" data-group-id="7592088080-4">)</span><span class="w"> </span><span class="p" data-group-id="7592088080-2">)</span><span class="w">

</span><span class="n">the_code_use_tems</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step2</span><span class="p" data-group-id="7592088080-5">(</span><span class="p" data-group-id="7592088080-5">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">...</span></code></pre><p><code class="inline">import</code> 语句非常的方便, 但是问题在于, 如果是全部导入的话, 从文本上,
我们不知道到底导入什么内容. 所以 Elixir 官方的文档中告诉我们, 应该优先使用 <code class="inline">require</code>
其实才是 <code class="inline">import</code> 最后是使用 <code class="inline">use</code>. <code class="inline">assgin</code> 宏不是操作符, 从功能上来说,
完全可以不使用 <code class="inline">import</code> 语句. 使用 <code class="inline">require</code> 语句之后, 我们就可以带着模块名来使用,
<code class="inline">assgin/2</code> 宏了. 例如 <code class="inline">1 |&gt; Corner.Assgin.assgin(to: v, v + 1)</code>.
语法上, 这样显的非常的啰嗦. 可以定义宏 <code class="inline">to/2</code> 来消除这种啰嗦.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">to</span><span class="p" data-group-id="0001957943-1">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">pattern</span><span class="p" data-group-id="0001957943-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">do_assign</span><span class="p" data-group-id="0001957943-2">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">pattern</span><span class="p" data-group-id="0001957943-2">)</span><span class="w">
</span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">to</span><span class="p" data-group-id="0001957943-3">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="0001957943-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">do_assign</span><span class="p" data-group-id="0001957943-4">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="0001957943-4">)</span></code></pre><p>这样, 使用 <code class="inline">require Corner.Assgin, as: Assign</code> 后, 使用 <code class="inline">to/2</code>
可以使得代码变得整洁.</p><pre><code class="makeup elixir" translate="no"><span class="kn">require</span><span class="w"> </span><span class="nc">Corner.Assign</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">Assign</span><span class="w">
</span><span class="n">some_code</span><span class="p" data-group-id="3627015466-1">(</span><span class="p" data-group-id="3627015466-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Assgin</span><span class="o">.</span><span class="n">to</span><span class="p" data-group-id="3627015466-2">(</span><span class="p" data-group-id="3627015466-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="n">v</span><span class="p" data-group-id="3627015466-3">}</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3627015466-2">)</span><span class="w">
</span><span class="c1">#...</span></code></pre><h2 id="with" class="section-heading">
  <a href="#with" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">with</p>
  </a>
  with
</h2>
<p>如果要选<strong>最不喜欢的语言结构</strong>, Elixir 的 <code class="inline">with</code> 是我的答案.</p><p>我所以不喜欢这个语句结构, 首先是像 <code class="inline">with</code> 语句中的 <code class="inline">&lt;-</code> 暗示的那样,
其中的代码序列和逻辑思维流之间存在阻抗. 其次, <code class="inline">with</code> 结构的代码布局非常的不美观.</p><p>例如代码:</p><pre><code class="makeup elixir" translate="no"><span class="k">with</span><span class="w">                     </span><span class="c1"># with 头部开始</span><span class="w">
     </span><span class="p" data-group-id="8984746437-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="8984746437-1">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="8984746437-2">(</span><span class="p" data-group-id="8984746437-2">)</span><span class="p">,</span><span class="w"> </span><span class="c1"># 产生子代码</span><span class="w">
     </span><span class="c1">#...                # 更多产生子代码</span><span class="w">
     </span><span class="p" data-group-id="8984746437-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="8984746437-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="8984746437-4">(</span><span class="n">a</span><span class="p" data-group-id="8984746437-4">)</span><span class="w"> </span><span class="c1"># with 头部结束</span><span class="w">
</span><span class="k" data-group-id="8984746437-5">do</span><span class="w">                       </span><span class="c1"># with 体开始</span><span class="w">
     </span><span class="n">action_with_a_and_b</span><span class="w"> </span><span class="c1"># with 体结束</span><span class="w">
</span><span class="k" data-group-id="8984746437-5">else</span><span class="w">                     </span><span class="c1"># 尾部开始</span><span class="w">
   </span><span class="n">patter1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error1</span><span class="w">
   </span><span class="n">patter2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error2</span><span class="w"> </span><span class="c1"># 尾部结束</span><span class="w">
</span><span class="k" data-group-id="8984746437-5">end</span></code></pre><p>这个 <code class="inline">with</code> 结构, 像代码中注释的那样, 可以分成 3 部分, 分别是<strong>头</strong>, <strong>体</strong>和<strong>尾</strong>.
通常情况下, <code class="inline">with</code> 代码就像上面的片段展示的这样, <code class="inline">with</code> 头往往有多个语句,
而 <code class="inline">with</code> 体却只有一行或很少的几行代码. 像这样的头部或者参数部分, 
多于体或者正文的语法结构, 除了 <code class="inline">with</code> 语句外, 我没有见过别的语法有这样的布局.
这样的布局, 给我的感觉是头重脚轻, 极度不协调.
看到这样的代码, 不由自主地, 我的脑海中总是浮现出有染色体缺陷的畸形儿的形象.
所以我非常的不喜欢这个语法结构.</p><p>如果不使用 <code class="inline">with</code> 语句, 等价的代码应该如何写呢? 我认为可以写成这样:</p><pre><code class="makeup elixir" translate="no"><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="9893633169-1">do</span><span class="w">
  </span><span class="p" data-group-id="9893633169-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="9893633169-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="9893633169-3">(</span><span class="p" data-group-id="9893633169-3">)</span><span class="w">
  </span><span class="p" data-group-id="9893633169-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="9893633169-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="9893633169-5">(</span><span class="n">a</span><span class="p" data-group-id="9893633169-5">)</span><span class="w">
  </span><span class="n">action_with_a_and_b</span><span class="w">
</span><span class="k" data-group-id="9893633169-1">rescue</span><span class="w">
  </span><span class="p" data-group-id="9893633169-6">%</span><span class="nc" data-group-id="9893633169-6">MatchError</span><span class="p" data-group-id="9893633169-6">{</span><span class="ss">term</span><span class="p">:</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="9893633169-6">}</span><span class="o">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="k" data-group-id="9893633169-7">do</span><span class="w">
      </span><span class="n">pattern1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">handler_error1</span><span class="w">
      </span><span class="n">pattern2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">handler_error2</span><span class="w">
    </span><span class="k" data-group-id="9893633169-7">end</span><span class="w">
</span><span class="k" data-group-id="9893633169-1">end</span></code></pre><p>对于没有 <code class="inline">else</code> 部分的 <code class="inline">with</code> 语句, 就更加简单:</p><pre><code class="makeup elixir" translate="no"><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="0679525644-1">do</span><span class="w">
  </span><span class="p" data-group-id="0679525644-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="0679525644-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="0679525644-3">(</span><span class="p" data-group-id="0679525644-3">)</span><span class="w">
  </span><span class="p" data-group-id="0679525644-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="0679525644-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="0679525644-5">(</span><span class="n">a</span><span class="p" data-group-id="0679525644-5">)</span><span class="w">
  </span><span class="n">action_with_a_and_b</span><span class="w">
</span><span class="k" data-group-id="0679525644-1">rescue</span><span class="w">
  </span><span class="p" data-group-id="0679525644-6">%</span><span class="nc" data-group-id="0679525644-6">MatchError</span><span class="p" data-group-id="0679525644-6">{</span><span class="ss">term</span><span class="p">:</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="0679525644-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">term</span><span class="w">
</span><span class="k" data-group-id="0679525644-1">end</span></code></pre><p>而如果语句已经在一个块结构中了, 代码还可以进一步的精简:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">fun</span><span class="w"> </span><span class="k" data-group-id="1142989941-1">do</span><span class="w">
  </span><span class="p" data-group-id="1142989941-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="1142989941-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="1142989941-3">(</span><span class="p" data-group-id="1142989941-3">)</span><span class="w">
  </span><span class="p" data-group-id="1142989941-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="1142989941-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="1142989941-5">(</span><span class="n">a</span><span class="p" data-group-id="1142989941-5">)</span><span class="w">
  </span><span class="n">atction_with_a_and_b</span><span class="w">
</span><span class="k" data-group-id="1142989941-1">rescue</span><span class="w">
  </span><span class="p" data-group-id="1142989941-6">%</span><span class="nc" data-group-id="1142989941-6">MatchError</span><span class="p" data-group-id="1142989941-6">{</span><span class="ss">term</span><span class="p">:</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="1142989941-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">term</span><span class="w">
</span><span class="k" data-group-id="1142989941-1">end</span></code></pre><p>所以我认为本质上, <code class="inline">with</code> 语句只是帮助我们写了 <code class="inline">try</code> 块.
我认为理想的 <code class="inline">with</code> 语句应该只要 <strong>体</strong> 和 <strong>尾</strong> 两部分就够了.</p><h3 id="特殊表达与保留字" class="section-heading">
  <a href="#特殊表达与保留字" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">特殊表达与保留字</p>
  </a>
  特殊表达与保留字
</h3>
<p>在前面的章节中, 已经多次出现 <strong>特殊表单</strong> (Special Forms)这个短语了,
但是特殊表单到底意味着什么呢?</p><p>我最初的理解, 特殊表单就像是别的语言中的关键字或者保留字. 这些符号和词汇,
不但有语言规定的意义而且不能用作变量名和函数名, 现在不少的语言,
对保留字的限制有所放宽, 比如 Javascript 中, 保留字虽然还不允许作为变量存在,
但是已经可以作为对象的方法或者字段名了.</p><p>在 Elixir 中, 有些特殊表单是没法用 Elixir 的语法来实现的.</p><p>比如 <code class="inline">with</code> 这个特殊表单, 它的特殊就在于其参数个数是不定的,
而 Elixir 中, 无论是函数还是宏的定义, 都不允许不定参数,
所以使用 Elixir 自身的语法是没法定义 <code class="inline">with</code> 这样的参数个数不定的宏.
但是 <code class="inline">with</code> 可以作为变量吗? 可以作为我们的函数名吗?
让我们来探索一下.</p><pre><code class="makeup elixir" translate="no"><span class="k">with</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4627853868-1">(</span><span class="k">with</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;with can used as variable&quot;</span><span class="p" data-group-id="4627853868-1">)</span><span class="w">

</span><span class="k">with</span><span class="w"> </span><span class="p" data-group-id="4627853868-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="4627853868-2">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="4627853868-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4627853868-3">}</span><span class="p">,</span><span class="w">
     </span><span class="p" data-group-id="4627853868-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="4627853868-4">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="4627853868-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4627853868-5">}</span><span class="w"> </span><span class="k" data-group-id="4627853868-6">do</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="k" data-group-id="4627853868-6">end</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">then</span><span class="p" data-group-id="4627853868-7">(</span><span class="o">&amp;</span><span class="p" data-group-id="4627853868-8">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="4627853868-8">)</span><span class="p" data-group-id="4627853868-7">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4627853868-9">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;with can still work&quot;</span><span class="p" data-group-id="4627853868-9">)</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="k" data-group-id="4627853868-10">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">with</span><span class="p" data-group-id="4627853868-11">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="4627853868-11">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="k" data-group-id="4627853868-10">end</span><span class="w">

</span><span class="nc">A</span><span class="o">.</span><span class="k">with</span><span class="p" data-group-id="4627853868-12">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4627853868-12">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">then</span><span class="p" data-group-id="4627853868-13">(</span><span class="o">&amp;</span><span class="p" data-group-id="4627853868-14">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4627853868-14">)</span><span class="p" data-group-id="4627853868-13">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4627853868-15">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;with can use as function name&quot;</span><span class="p" data-group-id="4627853868-15">)</span></code></pre><p>特殊表居然可以用作变量和函数名. 而且即使用作变量, 也不影响它作为特殊表单的功能.</p><p>但是保留字不一样, Elixir 中也有保留字, 虽然非常非常的少.
只有: <code class="inline">true</code>, <code class="inline">false</code>, <code class="inline">nil</code>,<code class="inline">when</code>, <code class="inline">and</code>, <code class="inline">or</code>, <code class="inline">not</code>,<code class="inline">in</code>, <code class="inline">fn</code>, <code class="inline">do</code>,
<code class="inline">end</code>,<code class="inline">throw</code>, <code class="inline">catch</code>,<code class="inline">rescue</code>, <code class="inline">after</code> 和 <code class="inline">else</code>, 共 16 个.
但是 <code class="inline">with</code> 不是, 只要不是保留字, 就可以作为变量, 以及函数名, 甚至模块名.</p><p>从上面的代码的输出中, 我们可以看出, 实际上 Elixir 对 <code class="inline">with</code> 几乎没有做限制.</p><p>我不满意 <code class="inline">with</code> 结构, 现在知道, 我们可以使用 <code class="inline">with</code> 来定义宏.
但是这不是一个好决定.</p><p>首先, 使用 <code class="inline">with</code> 作为宏的名字, 使得定义的宏不能直接导入到客户端的上下文中,
而只能用 <code class="inline">require</code> 加载宏, 然后带着模块名来使用我们定义的宏,
像上面的代码第 15 行展示的那样, 使用模块前缀来调用模块中的, 以 <code class="inline">with</code> 命名的宏.
因为特殊表单 (这里是 <code class="inline">with</code>) 不允许被覆盖, 我们不能通过
<code class="inline">import Kernel.SpecialForms, expect: [with: 1]</code> 来排除它.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">CanNotExceptSpecailForm</span><span class="w"> </span><span class="k" data-group-id="8284164994-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel.SpecialForms</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8284164994-2">[</span><span class="ss">with</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8284164994-2">]</span><span class="w">
  </span><span class="c1"># ... other code not use Kernel.with</span><span class="w">
</span><span class="k" data-group-id="8284164994-1">end</span></code></pre><p>所以, 只要向环境导入特殊表单同名且参数个数一样的函数或宏, 比如 <code class="inline">A.with/1</code>,
就会引发了编译器的报错.</p><p>最后, 即使不是特殊表达, 而是一般的宏, 如果我们自定义的和 <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a> 模块中的不兼容的话,
还是不建议使用同名覆盖的策略. 让我们看以下, 假如我们要覆盖 <a href="https://hexdocs.pm/elixir/Kernel.html#if/2"><code class="inline">if/2</code></a> 这个宏会发生什么吧.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">IF</span><span class="w"> </span><span class="k" data-group-id="3616982470-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3616982470-2">[</span><span class="ss">if</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3616982470-2">]</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="3616982470-3">(</span><span class="c">_opt</span><span class="p" data-group-id="3616982470-3">)</span><span class="w"> </span><span class="k" data-group-id="3616982470-4">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3616982470-5">do</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3616982470-6">[</span><span class="ss">if</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3616982470-6">]</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">IF</span><span class="w">
    </span><span class="k" data-group-id="3616982470-5">end</span><span class="w">
  </span><span class="k" data-group-id="3616982470-4">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">if</span><span class="p" data-group-id="3616982470-7">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="3616982470-7">)</span><span class="w"> </span><span class="k" data-group-id="3616982470-8">do</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w">
  </span><span class="k" data-group-id="3616982470-8">end</span><span class="w">
</span><span class="k" data-group-id="3616982470-1">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ExceptIfButStillUseIt</span><span class="w"> </span><span class="k" data-group-id="3616982470-9">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">IF</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k">if</span><span class="p" data-group-id="3616982470-10">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="3616982470-11">(</span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="3616982470-11">)</span><span class="p" data-group-id="3616982470-10">)</span><span class="w">
  </span><span class="c1"># ... other code use the IF.if</span><span class="w">
  </span><span class="nc">Kernel</span><span class="o">.</span><span class="k">if</span><span class="p" data-group-id="3616982470-12">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="3616982470-13">(</span><span class="n">a</span><span class="p" data-group-id="3616982470-13">)</span><span class="p" data-group-id="3616982470-12">)</span><span class="w">
</span><span class="k" data-group-id="3616982470-9">end</span></code></pre><p>这里的问题主要是两点:</p><ol><li>对于不熟悉我们的模块的人来说, 看到第 19 行的 <code class="inline">if</code> 语句会让非常的困惑.</li><li>在已经导入我们的宏的上下文中, 如 19 行那样, 必须使用 <code class="inline">Kernel.if</code> 的时候,
就只能带着 <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a> 模块前缀了.</li></ol><p>核心模块中提供的宏, 特殊表单和保留字, 编译器对它们的限制, 可以总结为下表.
| 标识符类型 | 举例 | 用作普通标志? | 可以被覆盖? |
|--------|----|----|---|
| 一般标识符 | <code class="inline">if</code> | 可以 | 是的 |
| 特殊表达 | <code class="inline">with</code>, <code class="inline">case</code> <code class="inline">cond</code> | 可以  | 不可以 |
| 保留字 | <code class="inline">fn</code>, <code class="inline">do</code> 等 | 不可以 | 不可以 |</p><p>回到 <code class="inline">with</code> 的话题上, 现在知道, 我们定义的新宏, 不应该命名为 <code class="inline">with</code>,
那么应该叫什么呢?</p><p>Erlang 的新版本 OTP 25 中引入了新的特性 <code class="inline">maybe</code><a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a>.
它实际上和 <code class="inline">with</code> 解决一样的问题. 因此, 为了向 Erlang 靠拢,
我们以 <code class="inline">maybe</code> 来命名我们定义的宏.</p><h3 id="maybe-的用法" class="section-heading">
  <a href="#maybe-的用法" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">maybe-的用法</p>
  </a>
  maybe 的用法
</h3>
<p>首先, 让我们确定如何使用 <code class="inline">maybe</code>.
对于使用 <code class="inline">with</code> 的代码:</p><pre><code class="makeup elixir" translate="no"><span class="k">with</span><span class="w">                     </span><span class="c1"># with 头部开始</span><span class="w">
     </span><span class="p" data-group-id="8304904879-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="8304904879-1">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="8304904879-2">(</span><span class="p" data-group-id="8304904879-2">)</span><span class="p">,</span><span class="w"> 
     </span><span class="p" data-group-id="8304904879-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="8304904879-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="8304904879-4">(</span><span class="n">a</span><span class="p" data-group-id="8304904879-4">)</span><span class="w"> </span><span class="c1"># with 头部结束</span><span class="w">
</span><span class="k" data-group-id="8304904879-5">do</span><span class="w"> </span><span class="c1"># with 体开始</span><span class="w">
     </span><span class="n">action_with_a_and_b</span><span class="w"> </span><span class="c1">#with 体结束</span><span class="w">
</span><span class="k" data-group-id="8304904879-5">else</span><span class="w"> </span><span class="c1">#尾部开始</span><span class="w">
   </span><span class="n">patter1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error1</span><span class="w">
   </span><span class="n">patter2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error2</span><span class="w"> </span><span class="c1"># 尾部结束</span><span class="w">
</span><span class="k" data-group-id="8304904879-5">end</span></code></pre><p>和</p><pre><code class="makeup elixir" translate="no"><span class="k">with</span><span class="w">                   </span><span class="c1"># with 头部开始</span><span class="w">
     </span><span class="p" data-group-id="5245058571-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="5245058571-1">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="5245058571-2">(</span><span class="p" data-group-id="5245058571-2">)</span><span class="p">,</span><span class="w"> 
     </span><span class="p" data-group-id="5245058571-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="5245058571-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="5245058571-4">(</span><span class="n">a</span><span class="p" data-group-id="5245058571-4">)</span><span class="w"> </span><span class="c1"># with 头部结束</span><span class="w">
</span><span class="k" data-group-id="5245058571-5">do</span><span class="w"> </span><span class="c1"># with 体开始</span><span class="w">
     </span><span class="n">action_with_a_and_b</span><span class="w"> </span><span class="c1">#with 体结束</span><span class="w">
</span><span class="k" data-group-id="5245058571-5">end</span></code></pre><p>使用 <code class="inline">maybe</code> 应该重构为:</p><pre><code class="makeup elixir" translate="no"><span class="n">maybe</span><span class="w"> </span><span class="k" data-group-id="3787888027-1">do</span><span class="w">                     </span><span class="c1">#maybe body begin</span><span class="w">
  </span><span class="p" data-group-id="3787888027-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="3787888027-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="3787888027-3">(</span><span class="p" data-group-id="3787888027-3">)</span><span class="w">
  </span><span class="p" data-group-id="3787888027-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="3787888027-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="3787888027-5">(</span><span class="n">a</span><span class="p" data-group-id="3787888027-5">)</span><span class="w">
  </span><span class="n">action_with_a_and_b</span><span class="w">        </span><span class="c1">#maybe body end</span><span class="w">
</span><span class="k" data-group-id="3787888027-1">else</span><span class="w">                         </span><span class="c1">#maybe tail start</span><span class="w">
   </span><span class="n">patter1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error1</span><span class="w">
   </span><span class="n">patter2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">hanlder_error2</span><span class="w"> </span><span class="c1">#maybe tail end</span><span class="w">
</span><span class="k" data-group-id="3787888027-1">end</span></code></pre><p>和</p><pre><code class="makeup elixir" translate="no"><span class="n">maybe</span><span class="w"> </span><span class="k" data-group-id="7625526944-1">do</span><span class="w">
  </span><span class="p" data-group-id="7625526944-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="7625526944-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun1</span><span class="p" data-group-id="7625526944-3">(</span><span class="p" data-group-id="7625526944-3">)</span><span class="w">
  </span><span class="p" data-group-id="7625526944-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7625526944-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun2</span><span class="p" data-group-id="7625526944-5">(</span><span class="n">a</span><span class="p" data-group-id="7625526944-5">)</span><span class="w">
  </span><span class="n">action_with_a_and_b</span><span class="w">
</span><span class="k" data-group-id="7625526944-1">end</span></code></pre><p>需要注意的是:</p><ol><li>我们的 <code class="inline">maybe</code> 中使用的是 <code class="inline">=</code> 而不再是 <code class="inline">&lt;-</code>, 而且和 Erlang 中的 <code class="inline">maybe</code> 也不一样,
我们不用引入新操作符(Erlang 的 <code class="inline">maybe</code> 结构中, 引入了新的操作符 <code class="inline">?=</code>).</li><li>新的 <code class="inline">maybe</code> 结构中, 在 <code class="inline">action_with_a_and_b</code> 对应的代码中,
如果发生匹配错误, 会直接返回匹配操作符的右值或跳转到 <code class="inline">else</code> 段落;
在 <code class="inline">with</code> 代码中, <code class="inline">action_with_a_and_b</code> 对应的代码发生匹配错误, 会抛出异常的.
这是一点不同.</li></ol><h3 id="maybe-的定义" class="section-heading">
  <a href="#maybe-的定义" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">maybe-的定义</p>
  </a>
  maybe 的定义
</h3>
<p>现在让我们定义 <code class="inline">maybe</code> 宏.</p><p>我们的 <code class="inline">maybe</code> 接受一个参数, <code class="inline">[do: body, else: tail]</code>,
<code class="inline">maybe</code> 宏把代码转化成为对应的 <code class="inline">try</code> 语句块.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Maybe</span><span class="w"> </span><span class="k" data-group-id="6277107431-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">maybe</span><span class="p" data-group-id="6277107431-2">(</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="6277107431-2">)</span><span class="w"> </span><span class="k" data-group-id="6277107431-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6277107431-4">do</span><span class="w">
      </span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="6277107431-5">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="6277107431-6">(</span><span class="n">body</span><span class="p" data-group-id="6277107431-6">)</span><span class="w">
      </span><span class="k" data-group-id="6277107431-5">catch</span><span class="w">
        </span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6277107431-7">{</span><span class="ss">:badmatch</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="6277107431-7">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w">
      </span><span class="k" data-group-id="6277107431-5">end</span><span class="w">
    </span><span class="k" data-group-id="6277107431-4">end</span><span class="w">
  </span><span class="k" data-group-id="6277107431-3">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">maybe</span><span class="p" data-group-id="6277107431-8">(</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="6277107431-8">)</span><span class="w"> </span><span class="k" data-group-id="6277107431-9">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6277107431-10">do</span><span class="w">
      </span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="6277107431-11">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="6277107431-12">(</span><span class="n">body</span><span class="p" data-group-id="6277107431-12">)</span><span class="w">
      </span><span class="k" data-group-id="6277107431-11">catch</span><span class="w">
        </span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6277107431-13">{</span><span class="ss">:badmatch</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="6277107431-13">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k" data-group-id="6277107431-14">do</span><span class="w">
            </span><span class="k">unquote</span><span class="p" data-group-id="6277107431-15">(</span><span class="n">tail</span><span class="p" data-group-id="6277107431-15">)</span><span class="w">
          </span><span class="k" data-group-id="6277107431-14">end</span><span class="w">
      </span><span class="k" data-group-id="6277107431-11">end</span><span class="w">
    </span><span class="k" data-group-id="6277107431-10">end</span><span class="w">
  </span><span class="k" data-group-id="6277107431-9">end</span><span class="w">
</span><span class="k" data-group-id="6277107431-1">end</span></code></pre><p>要使用 <code class="inline">maybe</code> 只要导入我们的宏就可以了.</p><h2 id="可递归的匿名函数" class="section-heading">
  <a href="#可递归的匿名函数" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">可递归的匿名函数</p>
  </a>
  可递归的匿名函数
</h2>
<p>匿名函数, 因为没有名字, 所以不能直接的在其内部调用自己.
计算机科学中, 这个问题, 可以通过不动点组合子来完成<a href="#fn:2" id="fnref:2" class="footnote" title="see footnote">2</a>.
但是老实说, 对于 Y 组合子, 如果不查看文档的话, 我不能写出正确的表达.
对我来说, Y 组合子太绕了.</p><p>不使用 Y 组合子, 当然也可以完成匿名函数的递归:</p><pre><code class="makeup elixir" translate="no"><span class="n">tem_fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="1641169023-1">fn</span><span class="p" data-group-id="1641169023-2">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="n">acc</span><span class="p" data-group-id="1641169023-2">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="1641169023-3">do</span><span class="w">
    </span><span class="n">acc</span><span class="w">
  </span><span class="k" data-group-id="1641169023-3">else</span><span class="w">
    </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="1641169023-4">(</span><span class="n">fun</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="1641169023-4">)</span><span class="w">
  </span><span class="k" data-group-id="1641169023-3">end</span><span class="w">
</span><span class="k" data-group-id="1641169023-1">end</span><span class="w">
</span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="1641169023-5">fn</span><span class="p" data-group-id="1641169023-6">(</span><span class="n">n</span><span class="p">,</span><span class="n">acc</span><span class="p" data-group-id="1641169023-6">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="n">tem_fun</span><span class="o">.</span><span class="p" data-group-id="1641169023-7">(</span><span class="n">tem_fun</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">acc</span><span class="p" data-group-id="1641169023-7">)</span><span class="w">
</span><span class="k" data-group-id="1641169023-5">end</span></code></pre><p>这样的代码框架几乎是固定的, 所以可以定义一个宏 <code class="inline">fn!</code> 来为自动生产这样的框架.
例如, 我想这样来写代码:</p><pre><code class="makeup elixir" translate="no"><span class="n">fn!</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="k" data-group-id="3454767980-1">do</span><span class="w">
  </span><span class="p" data-group-id="3454767980-2">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="p" data-group-id="3454767980-2">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="3454767980-3">do</span><span class="w">
   </span><span class="n">acc</span><span class="w">
  </span><span class="k" data-group-id="3454767980-3">else</span><span class="w">
    </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="3454767980-4">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="3454767980-4">)</span><span class="w">
  </span><span class="k" data-group-id="3454767980-3">end</span><span class="w">
</span><span class="k" data-group-id="3454767980-1">end</span></code></pre><p><code class="inline">fn!</code> 和 <code class="inline">fn</code> 很像, 通用用来定义匿名函数, 但是在 <code class="inline">fn!</code> 的上下文中,
可以用函数名来完成递归调用. 从这一点上来说, <code class="inline">fn!</code> 可以看作是 <code class="inline">fn</code> 的加强版.</p><h3 id="fn-的定义" class="section-heading">
  <a href="#fn-的定义" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">fn-的定义</p>
  </a>
  <code class="inline">fn!</code> 的定义
</h3>
<p>现在让我们仔细分析 <code class="inline">fn!</code> 到底应该帮助我们做些什么.
首先, 我们分析 <code class="inline">fn!</code> 的输入. 第一个参数是表示递归匿名函数名字的变量.
第二个参数是一个 <code class="inline">do-block</code>, 其中的内容应该一个或多个 <code class="inline">args -&gt; bodys</code> 表达式.</p><p>我们需要把 <code class="inline">do-block</code> 中的内容转化为一个真正的递归调用函数,
而所作的就是为每个分句都添加一个表示递归函数自身的参数.
当分句中没有对 <code class="inline">name</code> 函数的调用时, 新添加的第一个参数, 没有用处,
所以应该添加 <code class="inline">_</code> 前缀, 以避免恼人的编译警告.
虽然这个新添加的变量, 只要不予 <code class="inline">args</code> 中的变量重复, 叫什么都无所谓,
但是为了逻辑的清晰, 我们还是用 <code class="inline">name</code> 来命名这个表示递归函数自己的参数.
在这个整整的递归调用函数内容, 如果有对 <code class="inline">name</code> 函数的调用,
例如 <code class="inline">name.(a,b)</code> 这样的表达式, 需要转化为 <code class="inline">name.(name, a,b)</code>.</p><p>这是我们的 <code class="inline">fn!</code> 宏的最困难的工作, 这个工作由 <code class="inline">make_fn/2</code> 完成.
而 <code class="inline">make_fn/2</code> 要做的就是处理没有命名函数的的分句.
处理所有分句后, 把这些分句组合成为一个匿名函数. 所以 <code class="inline">make_fn/2</code> 的代码也非常简单.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.Fn</span><span class="w"> </span><span class="k" data-group-id="9813477141-1">do</span><span class="w">
  </span><span class="c1"># 其他代码</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_fn</span><span class="p" data-group-id="9813477141-2">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="9813477141-2">)</span><span class="w"> </span><span class="k" data-group-id="9813477141-3">do</span><span class="w">
    </span><span class="n">new_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="9813477141-4">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clause_handler</span><span class="p" data-group-id="9813477141-5">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="9813477141-5">)</span><span class="p" data-group-id="9813477141-4">)</span><span class="w">
    </span><span class="p" data-group-id="9813477141-6">{</span><span class="ss">:fn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9813477141-7">[</span><span class="p" data-group-id="9813477141-7">]</span><span class="p">,</span><span class="w"> </span><span class="n">new_body</span><span class="p" data-group-id="9813477141-6">}</span><span class="w">
  </span><span class="k" data-group-id="9813477141-3">end</span><span class="w">
  </span><span class="c1"># 其他代码</span><span class="w">
</span><span class="k" data-group-id="9813477141-1">end</span></code></pre><p><code class="inline">clause_handler/2</code>函数完成对每个分句的处理.
它做的工作也非常简单, 检查整个函数分句的函数体的语法树, 并修正其中的递归调用的部分.
如果分句的函数体中有修正, 那么修正后的抽象语法树, 也修正前的不一样,
这样, 我们就能知道, 为这个分句新添加的表示递归函数自己的参数, 用不用添加 <code class="inline">_</code> 前缀.</p><p>向参数列表中添加新参数的工作由 <code class="inline">make_args/2</code> 完成.
这个工作相对来说比较简单, 只是向列表头部添加一个元素而已.
唯一需要注意地方就是, 需要考虑参数中的哨兵语句.</p><p>当新的参数和新的函数体都完成后, 最后只需要把它们重新组合为匿名函数,
就完成了对可递归调用匿名函数的定义.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">clause_handler</span><span class="p" data-group-id="9276050821-1">(</span><span class="n">name_ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9276050821-2">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9276050821-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-3">{</span><span class="ss">:-&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-4">[</span><span class="n">args</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="9276050821-4">]</span><span class="p" data-group-id="9276050821-3">}</span><span class="p" data-group-id="9276050821-1">)</span><span class="w"> </span><span class="k" data-group-id="9276050821-5">do</span><span class="w">
  </span><span class="n">new_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">postwalk</span><span class="p" data-group-id="9276050821-6">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">correct_recursive_call</span><span class="p" data-group-id="9276050821-7">(</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="9276050821-7">)</span><span class="p" data-group-id="9276050821-6">)</span><span class="w">
  </span><span class="n">new_args</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">new_body</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="k" data-group-id="9276050821-8">do</span><span class="w">
      </span><span class="n">make_args</span><span class="p" data-group-id="9276050821-9">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">name_ast</span><span class="p" data-group-id="9276050821-9">)</span><span class="w">
    </span><span class="k" data-group-id="9276050821-8">else</span><span class="w">
      </span><span class="n">name_ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;_</span><span class="si" data-group-id="9276050821-10">#{</span><span class="n">atom</span><span class="si" data-group-id="9276050821-10">}</span><span class="s">&quot;</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="9276050821-11">(</span><span class="p" data-group-id="9276050821-11">)</span><span class="w">
      </span><span class="n">make_args</span><span class="p" data-group-id="9276050821-12">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-13">{</span><span class="n">name_ast</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-14">[</span><span class="p" data-group-id="9276050821-14">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="9276050821-13">}</span><span class="p" data-group-id="9276050821-12">)</span><span class="w">
    </span><span class="k" data-group-id="9276050821-8">end</span><span class="w">
  </span><span class="p" data-group-id="9276050821-15">{</span><span class="ss">:-&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-16">[</span><span class="n">new_args</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">new_body</span><span class="p" data-group-id="9276050821-16">]</span><span class="p" data-group-id="9276050821-15">}</span><span class="w">
</span><span class="k" data-group-id="9276050821-5">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_args</span><span class="p" data-group-id="9276050821-17">(</span><span class="p" data-group-id="9276050821-18">[</span><span class="p" data-group-id="9276050821-19">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="9276050821-19">}</span><span class="p" data-group-id="9276050821-18">]</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="9276050821-17">)</span><span class="w"> </span><span class="k" data-group-id="9276050821-20">do</span><span class="w">
  </span><span class="p" data-group-id="9276050821-21">[</span><span class="p" data-group-id="9276050821-22">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9276050821-23">[</span><span class="n">fun</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="9276050821-23">]</span><span class="p" data-group-id="9276050821-22">}</span><span class="p" data-group-id="9276050821-21">]</span><span class="w">
</span><span class="k" data-group-id="9276050821-20">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_args</span><span class="p" data-group-id="9276050821-24">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="9276050821-24">)</span><span class="w"> </span><span class="k" data-group-id="9276050821-25">do</span><span class="w">
  </span><span class="p" data-group-id="9276050821-26">[</span><span class="n">fun</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="9276050821-26">]</span><span class="w">
</span><span class="k" data-group-id="9276050821-25">end</span></code></pre><p>对递归调用的修正工作由函数 <code class="inline">correct_recursive_call/2</code> 完成.
假设我们的匿名的递归函数叫做 <code class="inline">fun</code>, 那么 <code class="inline">correct_recursive_call/2</code> 做的工作就是,
找到 <code class="inline">fun.(a,b)</code> 对应的抽象语法树, 修改为 <code class="inline">fun.(fun,a,b)</code> 对应的抽象语法树.
而其他的语法树, 保持原样.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># call is ast of `atom.(...args)`.</span><span class="w">
</span><span class="c1"># The return is ast of `atom.(atom,...args)`.</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">correct_recursive_call</span><span class="p" data-group-id="7360932766-1">(</span><span class="w">
       </span><span class="n">atom</span><span class="p">,</span><span class="w">
       </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7360932766-2">{</span><span class="p" data-group-id="7360932766-3">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7360932766-4">[</span><span class="p" data-group-id="7360932766-5">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7360932766-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="7360932766-4">]</span><span class="p" data-group-id="7360932766-3">}</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="7360932766-2">}</span><span class="w">
     </span><span class="p" data-group-id="7360932766-1">)</span><span class="w"> </span><span class="k" data-group-id="7360932766-6">do</span><span class="w">
  </span><span class="n">call</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">.</span><span class="n">delete_at</span><span class="p" data-group-id="7360932766-7">(</span><span class="mi">2</span><span class="p" data-group-id="7360932766-7">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">.</span><span class="n">append</span><span class="p" data-group-id="7360932766-8">(</span><span class="p" data-group-id="7360932766-9">[</span><span class="n">fun</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="7360932766-9">]</span><span class="p" data-group-id="7360932766-8">)</span><span class="w">
</span><span class="k" data-group-id="7360932766-6">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">correct_recursive_call</span><span class="p" data-group-id="7360932766-10">(</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p" data-group-id="7360932766-10">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">ast</span></code></pre><p>最后, <code class="inline">fn!</code> 函数完成的的工作就非常简单了. 首先检查递归匿名函数的所有的分句,
都有相同个数的参数. 然后创建与递归匿名函数参数个数相同的匿名函数,
在其内部代理已经定义好的可递归的匿名函数.</p><p>这里有一点点风险, 最后定义的代理匿名函数的变量是自动生成的.
作为中间变量存储可递归匿名函数的变量, 必须和它们不一样.
为了保证这一点, 我们当然可以自己定义参数生产函数.
这里并没有这样做, 而是使用了一点小技巧, 可以确保用来保存可递归匿名函数的变量绝对不会和
<a href="https://hexdocs.pm/elixir/Macro.html#generate_arguments/2"><code class="inline">Macro.generate_arguments/2</code></a> 产生的参数重复.
<a href="https://hexdocs.pm/elixir/Macro.html#generate_arguments/2"><code class="inline">Macro.generate_arguments/2</code></a> 产生的参数, 都是小写字母开头的,
所以只要定义的变量, 以大写字母开头就可以了.
在常规的 Elixir 中, 是不能定义大写字母开头的变量的,
但是在宏定义中, 可以这样做.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">fn!</span><span class="p" data-group-id="6759167987-1">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="6759167987-1">)</span><span class="w"> </span><span class="k" data-group-id="6759167987-2">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="n">syntax_check</span><span class="p" data-group-id="6759167987-3">(</span><span class="n">block</span><span class="p" data-group-id="6759167987-3">)</span><span class="w"> </span><span class="k" data-group-id="6759167987-4">do</span><span class="w">
    </span><span class="p" data-group-id="6759167987-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="6759167987-5">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6759167987-6">{</span><span class="ss">:TEM_fun</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6759167987-7">[</span><span class="p" data-group-id="6759167987-7">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="6759167987-6">}</span><span class="w">
      </span><span class="n">tem_fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_fn</span><span class="p" data-group-id="6759167987-8">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="6759167987-8">)</span><span class="w">
      </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">generate_arguments</span><span class="p" data-group-id="6759167987-9">(</span><span class="n">arity</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="6759167987-9">)</span><span class="w">
      </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6759167987-10">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="6759167987-11">(</span><span class="n">name</span><span class="p" data-group-id="6759167987-11">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="6759167987-12">fn</span><span class="w"> </span><span class="k">unquote_splicing</span><span class="p" data-group-id="6759167987-13">(</span><span class="n">params</span><span class="p" data-group-id="6759167987-13">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">unquote</span><span class="p" data-group-id="6759167987-14">(</span><span class="n">var</span><span class="p" data-group-id="6759167987-14">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6759167987-15">(</span><span class="n">tem_fun</span><span class="p" data-group-id="6759167987-15">)</span><span class="w">
          </span><span class="k">unquote</span><span class="p" data-group-id="6759167987-16">(</span><span class="n">var</span><span class="p" data-group-id="6759167987-16">)</span><span class="o">.</span><span class="p" data-group-id="6759167987-17">(</span><span class="k">unquote</span><span class="p" data-group-id="6759167987-18">(</span><span class="n">var</span><span class="p" data-group-id="6759167987-18">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote_splicing</span><span class="p" data-group-id="6759167987-19">(</span><span class="n">params</span><span class="p" data-group-id="6759167987-19">)</span><span class="p" data-group-id="6759167987-17">)</span><span class="w">
        </span><span class="k" data-group-id="6759167987-12">end</span><span class="w">
      </span><span class="k" data-group-id="6759167987-10">end</span><span class="w">
    </span><span class="ss">:error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="k">raise</span><span class="w"> </span><span class="nc">SyntaxError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;the clauses must have the same arity.&quot;</span><span class="w">
  </span><span class="k" data-group-id="6759167987-4">end</span><span class="w">
</span><span class="k" data-group-id="6759167987-2">end</span></code></pre><p>对递归函数子句参数个数做检查的工作有 <code class="inline">syntax_chexk/1</code> 完成.
它的工作非常的简单, 如果只有一个子句, 那么无论这个子句有多少参数, 都是合法的.
返回 <code class="inline">{:ok,arity}</code> 就可以了, 子句多于一个, 那么后续子句的参数个数,
必须和第一个子句的参数个数一样. 这是非常典型对列表的递归检查.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">syntax_check</span><span class="p" data-group-id="9524660260-1">(</span><span class="p" data-group-id="9524660260-2">[</span><span class="p" data-group-id="9524660260-3">{</span><span class="ss">:-&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9524660260-4">[</span><span class="n">args</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9524660260-4">]</span><span class="p" data-group-id="9524660260-3">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">others</span><span class="p" data-group-id="9524660260-2">]</span><span class="p" data-group-id="9524660260-1">)</span><span class="w"> </span><span class="k" data-group-id="9524660260-5">do</span><span class="w">
  </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">get_args</span><span class="p" data-group-id="9524660260-6">(</span><span class="n">args</span><span class="p" data-group-id="9524660260-6">)</span><span class="w">
  </span><span class="n">check_args_length</span><span class="p" data-group-id="9524660260-7">(</span><span class="n">others</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p" data-group-id="9524660260-8">(</span><span class="n">args</span><span class="p" data-group-id="9524660260-8">)</span><span class="p" data-group-id="9524660260-7">)</span><span class="w">
</span><span class="k" data-group-id="9524660260-5">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">check_args_length</span><span class="p" data-group-id="9524660260-9">(</span><span class="p" data-group-id="9524660260-10">[</span><span class="p" data-group-id="9524660260-10">]</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9524660260-9">)</span><span class="w"> </span><span class="k" data-group-id="9524660260-11">do</span><span class="w">
  </span><span class="p" data-group-id="9524660260-12">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9524660260-12">}</span><span class="w">
</span><span class="k" data-group-id="9524660260-11">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">check_args_length</span><span class="p" data-group-id="9524660260-13">(</span><span class="p" data-group-id="9524660260-14">[</span><span class="p" data-group-id="9524660260-15">{</span><span class="ss">:-&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9524660260-16">[</span><span class="n">args</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9524660260-16">]</span><span class="p" data-group-id="9524660260-15">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">others</span><span class="p" data-group-id="9524660260-14">]</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9524660260-13">)</span><span class="w"> </span><span class="k" data-group-id="9524660260-17">do</span><span class="w">
  </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">get_args</span><span class="p" data-group-id="9524660260-18">(</span><span class="n">args</span><span class="p" data-group-id="9524660260-18">)</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">length</span><span class="p" data-group-id="9524660260-19">(</span><span class="n">args</span><span class="p" data-group-id="9524660260-19">)</span><span class="w"> </span><span class="k" data-group-id="9524660260-20">do</span><span class="w">
    </span><span class="n">check_args_length</span><span class="p" data-group-id="9524660260-21">(</span><span class="n">others</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9524660260-21">)</span><span class="w">
  </span><span class="k" data-group-id="9524660260-20">else</span><span class="w">
    </span><span class="ss">:error</span><span class="w">
  </span><span class="k" data-group-id="9524660260-20">end</span><span class="w">
</span><span class="k" data-group-id="9524660260-17">end</span></code></pre><p>最后, 让我们来检验一下我们劳动成果.</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.Fn</span><span class="w">

</span><span class="n">fn!</span><span class="w"> </span><span class="n">sum_from_one_to</span><span class="w"> </span><span class="k" data-group-id="1332437808-1">do</span><span class="w">
  </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="n">n</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum_from_one_to</span><span class="o">.</span><span class="p" data-group-id="1332437808-2">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="1332437808-2">)</span><span class="w">
</span><span class="k" data-group-id="1332437808-1">end</span><span class="w">

</span><span class="n">sum</span><span class="o">.</span><span class="p" data-group-id="1332437808-3">(</span><span class="mi">100</span><span class="p" data-group-id="1332437808-3">)</span><span class="w"> </span><span class="c1"># 5050 </span></code></pre><p>看起来, 我们成功了.</p><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>详细内容见, <a href="https://www.erlang.org/doc/reference_manual/expressions.html#maybe">https://www.erlang.org/doc/reference_manual/expressions.html#maybe</a></p></li><li id="fn:2"><a class="reversefootnote" href="#fnref:2" title="return to article">&amp;#x21A9;</a><p>见 Wikipedia<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">≪不动点组合子≫</a>词条.</p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch04-parenthese.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第四章 括号
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch06-async_programe.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第六章 异步编程
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
