<!DOCTYPE html>
<html lang="encn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="The Corner of Elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第二章 加和减 — The Corner of Elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-1785d4c7ff.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="https://keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
The Corner of Elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch02.plus_and_minus.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第二章 加和减</span>
</h1>

<h2 id="问题的描述" class="section-heading">
  <a href="#问题的描述" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">问题的描述</p>
  </a>
  问题的描述
</h2>
<p>使用 Elixir 编程的时候, 第一个让我困惑的地方就是加减运算符了.
<code class="inline">-</code> 和 <code class="inline">+</code> 运算符号如此简单, 大部分情况下, 我们都不到会意识有什么问题存在.
但是在 Elixir 中, 我不止一次在这个地方被编译器无情的打脸.
而且刚开始, 挨打了还莫名其妙.</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="4995508870-1">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4995508870-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4995508870-2">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;1 -1&quot;</span><span class="p" data-group-id="4995508870-2">)</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p" data-group-id="4995508870-3">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="n">a</span><span class="p" data-group-id="4995508870-3">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4995508870-4">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;1 -a&quot;</span><span class="p" data-group-id="4995508870-4">)</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span></code></pre><p>在上面的代码示例, 是我学习 Elixir 中, 按照书籍示例的代码, 在 IEx 中输入的.
当我按照书中的代码, 输入 <code class="inline">a - 1</code> 时, 不小心写成了 <code class="inline">a -1</code>, 就像上面的片段中最后一行那样.
IEx 居然抛出了错误. 这出乎我的意料. 我完全想象不出, 为什么这里会有错误.</p><p>首先, 我知道变量 <code class="inline">a</code> 的值为 1, 难道 Elixir 中 <code class="inline">1 - 1</code> 不等于 0, 而是抛出错误?
我快速的在 IEx 中输入 <code class="inline">1 - 1</code>, 当然没有问题了.</p><p>那会不会什么时候, 变量 <code class="inline">a</code> 的值类型改变了呢?
<code class="inline">a</code> 的值不是数值 1, 而是字符串 &quot;1&quot; ?
于是我又加入调试语句, <code class="inline">IO.inspect(a,label: &quot;a&quot;)</code>.
<code class="inline">a</code> 的值的确是数值 1, 那么我就更困惑了, 那怎么会出错呢?
困惑中, 我再试了一下, 这次输成了  <code class="inline">1 - a</code>, 居然得到了正确答案 0.
仔细比较后发现, 出错的代码, 变量在减号的后面, 那么改回去,
<code class="inline">a - 1</code>, 怎么又正确了? 灵异事件?</p><p>当时, 我刚开始学习 Elixir, 还有很多的内容等待我去学习,
既然正确了, 我就没有仔细追究背后的原因.</p><p>等我开始用 Elixir 写更长代码后, 当这个问题再次出现的时候,
错误提示更加莫名奇妙了. 但是总是和 <code class="inline">-</code> 或 <code class="inline">+</code> 相关,
而且最后问题的解决往往也就只是在 <code class="inline">-</code> 或 <code class="inline">+</code> 之前加一个空格.</p><p>但是为什么呢? 为什么会出现这样的问题呢? 因为不知道错误的原因,
所以即使了解了该如何解决, 还是让我非常的疑惑.
直到有一天我认真的阅读了编译器的错误提示.</p><pre><code class="makeup elixir" translate="no"><span class="s">&quot;a -1&quot;</span><span class="w"> </span><span class="n">looks</span><span class="w"> </span><span class="n">like</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="o">.</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="p">,</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="ss">parentheses</span><span class="p">:</span><span class="w">
</span><span class="n">a</span><span class="p" data-group-id="7031613289-1">(</span><span class="o">-</span><span class="mi">1</span><span class="p" data-group-id="7031613289-1">)</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kn">use</span><span class="w">
</span><span class="n">spaces</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">unary</span><span class="w"> </span><span class="n">operator</span></code></pre><p>如果不是因为理解了  <code class="inline">&quot;a - 1&quot; 看起来像函数调用, 但是存在一个变量命名为 &quot;a&quot;</code>,
那么这段提示就算我很早就注意到, 也依然是不知所云的.</p><h3 id="为什么" class="section-heading">
  <a href="#为什么" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">为什么</p>
  </a>
  为什么?
</h3>
<p>但是为什么会是这个样子呢? 其他编程语言, 写 <code class="inline">a -1</code> 不都没问题的吗?</p><p>这是几个知识点组合起来引发的迷惑.</p><h4>1. Elixir 中函数调用时可以省略小括号</h4><p>这就是为什么, 在 IEx 中, 我们可以像使用 shell 命令那样使用 <code class="inline">cd</code>, <code class="inline">r</code> <code class="inline">h</code>
等等函数的原因.</p><p>函数定义在模块中, 当被导入到其他环境后, 可以不带模块名, 而直接使用函数名来调用.
对于整数除法来说, 可以使用 <code class="inline">div(1, 2)</code> 来代替 <code class="inline">Kernel.div(1,2)</code>,
进一步地, 函数调用的小括号也是可以省略的, 省略小括号后, 就成了 <code class="inline">div 1, 2</code>.</p><p>函数调用可以省略括号, 为什么要这样做呢? 我认为有以下两个原因.</p><ol><li>零元无副作用的函数来实际上和常量一样. Elixir 和 Erlang 中,
也正是如此来使用零元无副作用的函数的. 比如 <code class="inline">:math.pi</code>. 如果必须加上小括号,
像<code class="inline">:math.pi()</code> 的话, 就太不像常量了.</li><li>Elixir 中使用宏来做元编程, 调用宏的时候不写括号, 代码的可读性更强.
 不带括号, 使得宏调用, 看起来像是其他语言中的关键字. 对比一下:</li></ol><table><thead><tr><th style="text-align: right;">不带括号的宏调用看起来更像关键字</th><th style="text-align: left;">加上括号的宏调用更像函数调用</th></tr></thead><tbody><tr><td style="text-align: right;"><code class="inline">import Module, only: [fun1: 1]</code></td><td style="text-align: left;"><code class="inline">import(Module, only: [fun1: 1])</code></td></tr></tbody></table><h4>2. 操作符 <code class="inline">-</code> 身兼二职</h4><ol><li><a href="https://hexdocs.pm/elixir/Kernel.html#-/2"><code class="inline">-/2</code></a> 是减法操作符.</li><li><a href="https://hexdocs.pm/elixir/Kernel.html#-/1"><code class="inline">-/1</code></a> 是取反操作符.</li></ol><h4>3. 变量和函数名使用的标识符规则一样</h4><p>让我们再来看一下, <code class="inline">a -1</code> 引发的编译错误:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="9085830928-1">(</span><span class="nc">CompileError</span><span class="p" data-group-id="9085830928-1">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">&quot;a -1&quot;</span><span class="w"> </span><span class="n">looks</span><span class="w"> </span><span class="n">like</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="o">.</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="p">,</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="ss">parentheses</span><span class="p">:</span><span class="w">
</span><span class="err">`</span><span class="n">a</span><span class="p" data-group-id="9085830928-2">(</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="9085830928-2">)</span><span class="err">`</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w">
</span><span class="kn">use</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">unary</span><span class="w"> </span><span class="n">operator</span></code></pre><p>看起来是因为编译器优先把标识符 <code class="inline">a</code> 解释为函数, 而实际上它是一个变量, 所以才引发错误的.
可是为什么编译器不首先把标识符解释为变量呢? 这样, 就可以把 <code class="inline">a -1</code> 解释为对 <code class="inline">a</code> 减去 1,
而不是以 <code class="inline">-1</code> 为参数来调用函数 <code class="inline">a</code>.</p><p>答案是编译器实际上就是优先把标识符解释为变量的, 但是有些时候, 编译器不能区分变量和函数.</p><p>首先, 让我来证明, 编译器的确是优先把小写字母开头的标识符解释为变量的.</p><h2 id="标识符优先被解释为变量" class="section-heading">
  <a href="#标识符优先被解释为变量" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">标识符优先被解释为变量</p>
  </a>
  标识符优先被解释为变量
</h2>
<p>首先, 我们导入一个零元函数 <a href="https://www.erlang.org/doc/man/math.html#pi-0"><code class="inline">:math.pi/0</code></a>, 然后再定义一个同名的变量 <code class="inline">pi</code>,
让我们看看, 使用标识符 <code class="inline">pi</code> 的时候, 得到的 <code class="inline">:math.pi</code> 的返回值,
还是我们自定义的变量的值.</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="ss">:math</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7691858823-1">[</span><span class="ss">pi</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="7691858823-1">]</span><span class="w">
</span><span class="n">pi</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7691858823-2">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;before define variable pi&quot;</span><span class="p" data-group-id="7691858823-2">)</span><span class="w">
</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is variabel pi!&quot;</span><span class="w">
</span><span class="n">pi</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7691858823-3">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;after  define variable pi&quot;</span><span class="p" data-group-id="7691858823-3">)</span></code></pre><p>在定义变量 <code class="inline">pi</code> 之前, 我们使用标识符 <code class="inline">pi</code>, 用到的是当然是导入的零元函数.
但当我们定义变量 <code class="inline">pi</code> 之后, 再使用标识符 <code class="inline">pi</code>, 得到的是变量 <code class="inline">pi</code> 的值.
那么有没有可能是变量 <code class="inline">pi</code> 遮盖 (shadow) 了函数 <a href="https://www.erlang.org/doc/man/math.html#pi-0"><code class="inline">:math.pi/0</code></a>? 或者说,
如果先定义变量, 后导入零元函数, 编译器会不会把标识符 <code class="inline">pi</code> 解释为对函数
<a href="https://www.erlang.org/doc/man/math.html#pi-0"><code class="inline">:math.pi/0</code></a> 的调用呢?</p><p>当前的 IEx 环境中, 已经导入了 <code class="inline">pi/0</code> 函数, 如果读者跟随我的思路,
在你的 IEx 中实验的话, 那么你的环境中, 也已经导入了 <code class="inline">pi/0</code>. 为了清晰起见,
让我们定义一个新的变量 <code class="inline">e</code> 和零元函数 <code class="inline">e/0</code>, 来实验我们最新的假设.</p><pre><code class="makeup elixir" translate="no"><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;var e&quot;</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TempModule</span><span class="w"> </span><span class="k" data-group-id="7625706342-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">e</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">exp</span><span class="p" data-group-id="7625706342-2">(</span><span class="mi">1</span><span class="p" data-group-id="7625706342-2">)</span><span class="w">
</span><span class="k" data-group-id="7625706342-1">end</span><span class="w">
</span><span class="kn">import</span><span class="w"> </span><span class="nc">TemModule</span><span class="w">
</span><span class="n">e</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="7625706342-3">(</span><span class="p" data-group-id="7625706342-3">)</span></code></pre><p>输出为: <code class="inline">&quot;var e&quot;</code>.</p><p>因此, 我们可以得出结论, 同名的零元函数和变量, 出现在同一个上下文的时候,
无论变量和函数出现的顺序如何, 编译器都优先把标识符解释为变量.</p><h2 id="函数其实没有被覆盖" class="section-heading">
  <a href="#函数其实没有被覆盖" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数其实没有被覆盖</p>
  </a>
  函数其实没有被覆盖
</h2>
<p>前面的章节, 我们说, 零元函数被同名的变量覆盖的了. 实际上不是的.
零元函数, 依旧是可访问的, 只是当有同名的变量存在的时候,
对零元函数的调用就不能省略小括号了.
例如下面的代码:</p><pre><code class="makeup elixir" translate="no"><span class="n">pi</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4472716581-1">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;pi&quot;</span><span class="p" data-group-id="4472716581-1">)</span><span class="w">
</span><span class="n">pi</span><span class="p" data-group-id="4472716581-2">(</span><span class="p" data-group-id="4472716581-2">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="4472716581-3">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;pi() still is&quot;</span><span class="p" data-group-id="4472716581-3">)</span></code></pre><p>其输出为:</p><pre><code class="makeup elixir" translate="no"><span class="ss">pi</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;This is variabel pi!&quot;</span><span class="w">
</span><span class="n">pi</span><span class="p" data-group-id="5243224733-1">(</span><span class="p" data-group-id="5243224733-1">)</span><span class="w"> </span><span class="n">still</span><span class="w"> </span><span class="ss">is</span><span class="p">:</span><span class="w"> </span><span class="mf">3.141592653589793</span></code></pre><p>对于有元函数来说, 函数没有不覆盖, 就更加清楚了.
我们以 <a href="https://hexdocs.pm/elixir/Kernel.html#abs/1"><code class="inline">Kernel.abs/1</code></a> 为例, 核心模块 <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a> 中的函数都是默认导入的,
当我们定义了 <code class="inline">abs</code> 的变量后, 上下文中, 就同时出现了同名的变量和函数 --- --- <code class="inline">abs</code>.
但是像下面的代码所展示的那样:
当我们需要一个变量的时候, 获得就是一个变量;
当我们需要一个函数的时候, 获得就是一个函数.</p><pre><code class="makeup elixir" translate="no"><span class="n">abs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w">

</span><span class="n">abs</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">abs</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6571161513-1">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;abs |&gt; abs&quot;</span><span class="p" data-group-id="6571161513-1">)</span><span class="w">

</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6571161513-2">(</span><span class="n">abs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;abs/3&quot;</span><span class="p" data-group-id="6571161513-2">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6571161513-3">(</span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">abs</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;1/abs&quot;</span><span class="p" data-group-id="6571161513-3">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6571161513-4">(</span><span class="o">&amp;</span><span class="n">abs</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;&amp;abs/1&quot;</span><span class="p" data-group-id="6571161513-4">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6571161513-5">(</span><span class="n">abs</span><span class="w"> </span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;abs -9&quot;</span><span class="p" data-group-id="6571161513-5">)</span></code></pre><p>上面的片段中, 第1, 3, 7 和 8 行中的 <code class="inline">abs</code> 都是变量, 而 4, 9 和 10 行的
<code class="inline">abs</code> 都是函数名.</p><p>看起来编译器是可以区分变量和函数的. 但是, 不总是这样的.</p><p>有时候, 代码是有歧义的, 这时编译器不能确定标识符到底是函数还是变量.</p><h2 id="歧义代码" class="section-heading">
  <a href="#歧义代码" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">歧义代码</p>
  </a>
  歧义代码
</h2>
<p>如果遇到这样的代码: <code class="inline">abs - abs</code>, 那么这两个 <code class="inline">abs</code> 怎么区分呢?
显然是有两种解释的:</p><ol><li>两个 <code class="inline">abs</code> 都是变量, 那么结果自然是 0;</li><li>第一个 <code class="inline">abs</code> 是函数, 第二个 <code class="inline">abs</code> 是变量,
那么返回的结果应该是变量  <code class="inline">abs</code> 的绝对值, 也就是 2.</li></ol><p>答案是 0. 也就是说操作符 <code class="inline">-</code> 把两边操作数都当作是变量.</p><p>但是这样的代码 <code class="inline">abs -abs</code> 呢? 也依然有两种解释,
实际上这一次因为 <code class="inline">-</code> 和第二个 <code class="inline">abs</code> 之间没有空格,
更应该优先把 <code class="inline">-</code> 解释为对变量 <code class="inline">abs</code> 的取反.
如果这样解释的话, 那么第一个 <code class="inline">abs</code> 解释成什么呢?
似乎只能解释为函数, 那么结果应该是 2.</p><p>但是实际上, 编译器抛出了一个错误.</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="0784963658-1">(</span><span class="nc">CompileError</span><span class="p" data-group-id="0784963658-1">)</span><span class="w"> </span><span class="ss">:&quot;abs -abs&quot;</span><span class="w"> </span><span class="n">looks</span><span class="w"> </span><span class="n">like</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="s">&quot;abs&quot;</span><span class="o">.</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">call</span><span class="p">,</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="ss">parentheses</span><span class="p">:</span><span class="w">
</span><span class="err">`</span><span class="n">abs</span><span class="p" data-group-id="0784963658-2">(</span><span class="o">-</span><span class="n">abs</span><span class="p" data-group-id="0784963658-2">)</span><span class="err">`</span><span class="w">
</span><span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">abs</span><span class="p">,</span><span class="w">
</span><span class="kn">use</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">unary</span><span class="w"> </span><span class="n">operator</span></code></pre><p>为什么, 编译器不优先把 <code class="inline">-abs</code> 作为一个整体, 来解释为对 <code class="inline">abs</code> 的取反操作呢?
因为在别的语法环境中, <code class="inline">-abs</code> 作为整体解释, 会出现问题.</p><ol><li><p><code class="inline">abs-abs</code> 怎么解释呢?</p><ol><li>优先把 <code class="inline">-abs</code> 作为一组来解析, 得到的是一个数值.
那么把第一个 <code class="inline">abs</code> 解释为函数, 合乎语法;</li><li>把两个 <code class="inline">abs</code> 都解释为变量,语法也是正确的.</li><li>可是两个语义完全不同.</li></ol><p>实际上编译器在这种情况下, 把两个 <code class="inline">abs</code> 都解释为变量.</p></li><li><p><code class="inline">abs -abs -abs</code> 呢?</p><p>如果两个 <code class="inline">-abs</code> 都解释为对变量取反, 而把第一个 <code class="inline">abs</code> 解释为函数,
那么整个表达式等价于 <code class="inline">abs(2 2)</code> 还是 <code class="inline">abs(2) 2</code>?
但是无论<code class="inline">abs(2 2)</code> 还是 <code class="inline">abs(2) 2</code> 都不是 Elixir 的正确语法.</p></li><li><p>要想 <code class="inline">abs -abs -abs</code> 有意义, 只能把两个 <code class="inline">-abs</code> 做不同的解释才行.</p><ol><li>把 <code class="inline">abs -abs -abs</code> 解释为 <code class="inline">(abs) - abs(-abs)</code>, 是可行的,
但是对编译器的实现来说来说, 完成这样的结束, 需要的实现太复杂了.</li><li>把 <code class="inline">abs -abs -abs</code> 解释为 <code class="inline">(abs - abs) - abs</code> 就彻底放弃了对 <code class="inline">-abs</code> 优先解释.</li></ol></li></ol><p>综合起来看, 只好放弃对 <code class="inline">-abs</code> 的优先解释, 而把 <code class="inline">-abs</code> 解析为两个符号(token): <code class="inline">-</code> 与 <code class="inline">abs</code>.</p><h3 id="为什么报错" class="section-heading">
  <a href="#为什么报错" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">为什么报错</p>
  </a>
  为什么报错
</h3>
<p>上面的分析, 我们看到, 只能把 <code class="inline">-abs</code> 解释为 <code class="inline">-</code> 和 <code class="inline">abs</code> 两个符号.
但是这样处理后, 为什么当编译器遇到 <code class="inline">abs -abs</code> 的时候会报错呢?
这是因为, 有时候, 我们写 <code class="inline">-abs</code> 的时候, 我们的真实的意图就是要对 <code class="inline">abs</code> 取反.
如果编译器一律把 <code class="inline">x -abs</code> 解释为 <code class="inline">x</code> 减去 <code class="inline">abs</code>,
那么代码有可能实际上违背了我们的真实意图.</p><p>抛出错误, 强迫程序员明确 <code class="inline">-</code> 的意义, 可以使得 Elixir 代码更强壮,
这符合 Erlang 的 &quot;Let it crash&quot; 哲学. 在编译时奔溃好过在运行时奔溃.</p><p>最后一点, 我们的分析中, 表达式 <code class="inline">token -token1</code> 中,
<code class="inline">token</code> 和 <code class="inline">token1</code> 都是标识符;
但是实际上, 只要 <code class="inline">token</code> 是标识符,<code class="inline">token1</code>  无论是数值字面量还是标识符,
这个表达式都会引发这里讨论的问题.</p><p>我们可以用以下表格来总结表达式的各种情形:</p><table><thead><tr><th style="text-align: left;">表达式</th><th style="text-align: left;">语法正误</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">x-y</code></td><td style="text-align: left;">正确</td><td style="text-align: left;">当 <code class="inline">-</code> 两边的符号与 <code class="inline">-</code> 之间都没有空白时, 解释器把 <code class="inline">-</code> 解释为减法</td></tr><tr><td style="text-align: left;"><code class="inline">1 -1</code></td><td style="text-align: left;">正确</td><td style="text-align: left;">数字是不能作为函数名的, 所以 <code class="inline">-</code> 只能解释为减法.</td></tr><tr><td style="text-align: left;"><code class="inline">1 -a</code></td><td style="text-align: left;">正确</td><td style="text-align: left;">无论 <code class="inline">a</code> 是表达式, 还是变量, 都必须把 <code class="inline">-</code> 解释为在减号, 整个表达式才正确</td></tr><tr><td style="text-align: left;"><code class="inline">a -1</code></td><td style="text-align: left;">错误</td><td style="text-align: left;">表达式存在歧义, 既可以用作解释为函数调用 <code class="inline">a(-1)</code>; 又可以解释为变量 <code class="inline">a</code> 减去 1.</td></tr><tr><td style="text-align: left;"><code class="inline">a -b</code></td><td style="text-align: left;">错误</td><td style="text-align: left;">同上.</td></tr></tbody></table><p>表中 <code class="inline">x</code>, <code class="inline">y</code> 表示可以是数字也可以是变量标识符; <code class="inline">a</code> 和 <code class="inline">b</code> 表示变量标识符;
<code class="inline">1</code> 代表任意的数值字面量.</p><h2 id="加" class="section-heading">
  <a href="#加" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">加</p>
  </a>
  加
</h2>
<p>这章的标题是  <strong>≪加和减≫</strong>, 但是, 到目前为止, 我们的分析只涉及到了 <code class="inline">-</code>.
我不是跑题了, 而是因为 <code class="inline">+</code> 存在的问题, 和 <code class="inline">-</code> 本质是一样的.</p><p><a href="https://hexdocs.pm/elixir/Kernel.html#-/1"><code class="inline">-/1</code></a> 在编程中承担了有意义的工作; <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 不一样.
 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 在 Elixir 中真正的意义, 在编程实践中, 几乎用不到.</p><p>你能想象到 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 的实际意义吗?</p><p>首先, 如果 <code class="inline">b</code> 是一个数字, <code class="inline">+b</code> 并不返回 <code class="inline">b</code> 的绝对值.
从 C 到 Javascirpt, ..., 到 Erlang 再到 Elixir, 都是如此.
这还真是一个有趣的现象, 这样一个赘疣一样的语法弥因 (Meme),
怎么就在编程语言设计的领域中扩散开的?
Elixir 继承自 Erlang, <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 在 Elixir 中就是调用的 Erlang <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a><a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a>.
Erlang 又从哪里继承的, 我就不得而知了.</p><p>但是这个赘疣源远流长. 在最早的高级编程语言 Fortran 和 Lisp 中就有它的身影.
在 Lisp 中, <code class="inline">+</code> 是一个不定参数的函数, 在定义 <code class="inline">+</code> 的时候,
以 0 为初始值, 对所有参数作累加操作, 根本就不需要对单参数的情形作特殊处理.
在 Fortran 中, 为什么也有它的身影, 我就不得而知. 也许是出于与 <a href="https://hexdocs.pm/elixir/Kernel.html#-/1"><code class="inline">-/1</code></a> 的对称考虑?</p><p>对于非操作符前缀的语言, 我认为 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 就是一个赘疣, 乍看无关痛痒, 后期的发展,
有可能危害生命. 我建议编程语言的设计者: 在自己设计的编程语言中, 消灭 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a>;
如果非要为 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 保留一席之地, 那么就给它分配一个有意义的工作; 比如拿来作<strong>取绝对值</strong>的操作符.</p><p>在 Javascirpt 中 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 找到了自己的一席之地: 可以用来完成字符串到数值的转化.</p><pre><code class="makeup js" translate="no"><span class="n">a</span><span class="o">=</span><span class="s">&quot;123&quot;</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="0970224364-1">(</span><span class="o">+</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="0970224364-1">)</span><span class="w"> </span><span class="c1">//124</span></code></pre><p>Elixir 是强类型语言, <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 不提供这个功能.
那么 Elixir 中 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 的用途是什么呢?
我能想到的唯一用途就是: 检查一个值是否为数值类型,
如果是, 返回其值; 如果不是, 则抛出错误. 也就是说, <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 可以这样定义:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="o">+</span><span class="p" data-group-id="3834313582-1">(</span><span class="n">m</span><span class="p" data-group-id="3834313582-1">)</span><span class="w"> </span><span class="k" data-group-id="3834313582-2">do</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">is_number</span><span class="p" data-group-id="3834313582-3">(</span><span class="n">m</span><span class="p" data-group-id="3834313582-3">)</span><span class="w"> </span><span class="k" data-group-id="3834313582-4">do</span><span class="w">
    </span><span class="n">m</span><span class="w">
  </span><span class="k" data-group-id="3834313582-4">else</span><span class="w">
    </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;bad argument in arithmetic expression: +(</span><span class="si" data-group-id="3834313582-5">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">m</span><span class="si" data-group-id="3834313582-5">}</span><span class="s">)&quot;</span><span class="w">
    </span><span class="k">raise</span><span class="w"> </span><span class="nc">ArithmeticError</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="w">
  </span><span class="k" data-group-id="3834313582-4">end</span><span class="w">
</span><span class="k" data-group-id="3834313582-2">end</span></code></pre><p>但是在 Elixir 和 Erlang 中, 抛出错误不是一个常规的编程操作, 所以, 我从来没见过有人用过这个语法.</p><p>如果 Elixir 中取消了 <a href="https://hexdocs.pm/elixir/Kernel.html#+/1"><code class="inline">+/1</code></a> 的定义, 只把 <code class="inline">+</code> 解释为加法, 那么 <code class="inline">a +1</code>, <code class="inline">a +b</code>,
这些表达式中的语法歧义就消除了.</p><p><code class="inline">-</code> 引发错误是不得已; <code class="inline">+</code> 引发的错误, 是赘疣恶化的结果. 你同意吗?</p><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>见 Elixir 核心模块<a href="https://github.com/elixir-lang/elixir/blob/33f9d04851a2664aeae5f5f78eeef9e5b4c38030/lib/elixir/lib/kernel.ex#L1347">源码 1347~1349 行</a>.</p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch01-intruction.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第一章 前言
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch03-pattern_match.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第三章 模式匹配
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
