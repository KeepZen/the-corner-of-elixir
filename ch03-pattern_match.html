<!DOCTYPE html>
<html lang="cn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="the_corner_of_elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第三章 模式匹配 — the_corner_of_elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-a0514d8df2.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
the_corner_of_elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch03.pattern_match.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第三章 模式匹配</span>
</h1>

<h2 id="模式匹配的作用" class="section-heading">
  <a href="#模式匹配的作用" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模式匹配的作用</p>
  </a>
  模式匹配的作用
</h2>
<p>模式匹配完成以下的两个工作:</p><ol><li>确认数据具有某种模式</li><li>以某种模式, 从数据中提取信息</li></ol><p>在其他语言中, 这两个功能有着清晰的分界, 但是在 Elixir 中, 有清晰分界的情况是少数的,
大部分是两个功能混合在一起的.</p><h2 id="模式确认" class="section-heading">
  <a href="#模式确认" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模式确认</p>
  </a>
  模式确认
</h2>
<p>Elixir 特意提供了一个专门完成模式检查工作的宏 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a>. 这个宏返回的是一个布尔值.</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">match?</span><span class="p" data-group-id="3020158799-1">(</span><span class="p" data-group-id="3020158799-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="3020158799-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3020158799-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3020158799-3">}</span><span class="p" data-group-id="3020158799-1">)</span><span class="w">
</span><span class="ss">:b</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="3020158799-4">(</span><span class="n">binding</span><span class="p" data-group-id="3020158799-5">(</span><span class="p" data-group-id="3020158799-5">)</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">keys</span><span class="p" data-group-id="3020158799-6">(</span><span class="p" data-group-id="3020158799-6">)</span><span class="p" data-group-id="3020158799-4">)</span><span class="w">
</span><span class="no">false</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">match?</span><span class="p" data-group-id="3020158799-7">(</span><span class="p" data-group-id="3020158799-8">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3020158799-8">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:error</span><span class="p" data-group-id="3020158799-7">)</span></code></pre><p>上面的代码, 第 1 行表明, 当 <code class="inline">match?</code> 第一个参数作为模式, 可以匹配第二个值得时候,
返回值是 <code class="inline">true</code>. 第 2 行, 通过检查 <code class="inline">binding()</code>, 确认即使匹配成功,
这个宏也并不在环境中引入新的变量. <a href="https://hexdocs.pm/elixir/Kernel.html#binding/1"><code class="inline">binding/1</code></a> 是一个宏, 返回指定的上下文函数的绑定值.
<code class="inline">biding/0</code> 返回当前环境中的绑定情况. 这个函数返回的是一个 Keyword.
代码  <code class="inline">binding()|&gt;Keyword.keys()</code> 返回了当前的上下文中所有的变量 (以原子表示).</p><p>第 3 行, 展示了当 <code class="inline">match?</code> 的两个参数匹配失败的时候,
返回 <code class="inline">false</code> 而不是引发一个异常.</p><p>和 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 完成的工作非常相似, 但是只专注于字符串匹配的是操作符 <code class="inline">=~</code>.
<code class="inline">=~</code> 返回的也是布尔值.</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">
</span><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/hel.{2}/</span></code></pre><p>对参数的要求, <code class="inline">Kerner.match?/2</code> 和匹配操作符 <code class="inline">=</code> 一样, 第一个参数作为模式,
第二个参数作为需要匹配的值. 字符匹配操作符 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 与它们不一样.
<a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 的第一个参数是要匹配的数据 --- --- 具体说是字符串,
第二个参数是模式: 字符串或者正则表达式. 这是一点小不同.</p><p>其实, 我更希望能够使用操作符, 来完成更多的模式确认的工作.
<code class="inline">=</code> 在 Elixir 和 Eralng 中已经被命名为模式匹配操作符了, 为了避免混淆,
我把将要定义的 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 宏, 叫做 <strong>模式确认操作符 (Pattern Confirm Operater)</strong>.</p><p>将要定义的模式确认操作符 <code class="inline">=~</code> 除了完成字符串匹配外,
还可以完成其他的模式确认的工作.</p><p>如果模式确认操作 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 接受的第一个操作符是字符串,
那么就代理  <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 函数来执行字符串匹配.
为了和 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">Kernel.match?/2</code></a> 的参数顺序保持一致, 
我们还支持正则表达式字面量 (<code class="inline">~r</code> 或 <code class="inline">~R</code>) 作为第一个参数,
字符串作为第二个参数, 来完成模式确认的工作.</p><p>其他情况, 全部有 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">Kernel.match?/2</code></a> 来完成.</p><p>但是 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">Kernel.match?/2</code></a> 有一个小小的问题:
当我们使用一般的变量来作为匹配的模式时, 编译器会给出恼人的警告.
例如 <code class="inline">match?([a,b],[1,2])</code> 会警告: 变量 <code class="inline">a</code> 和 <code class="inline">b</code> 都没有被使用.
实际上,  就像我们上面已经解释过的, <code class="inline">match?([a,b],[1,2])</code> 
根本不向运行时环境引入变量, 那么这样的警告就显得有些古怪.</p><p>为什么 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 要给出这样的警告呢?</p><p>想想看, 如果首先定义了一个变量, <code class="inline">a=[1,2]</code>, 然后期望当 <code class="inline">value</code> 的值为 <code class="inline">[1,2]</code> 时,
<code class="inline">match?(a,value)</code> 返回 <code class="inline">true</code>. 这样的代码, 正确吗?
因为 <code class="inline">match?</code> 接受的第一个参数是一个模式, 而变量是可以匹配任意值的,
所以无论 <code class="inline">value</code> 的值是什么内容, <code class="inline">match?(a,value)</code> 都会返回 <code class="inline">true</code>.
要表达按照变量的值来匹配, 正确语法是 <code class="inline">match?(^a,value)</code>.
这就是为什么 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 遇到第一个参数中有不以下划线开头的变量时, 给出警告的原因.
对于这个问题, 模式确认操作符时这样处理的, 模式操作符的第一个参数是一个变量,
那么抛出一个错误. 其他的情况, 在把模式传递给 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 前,
给普通的变量加上下划线前缀, 这样就能最大限度的消除 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 给出的古怪警告.</p><p>现在让我们看看如何实现.</p><h2 id="模式确认操作符的实现" class="section-heading">
  <a href="#模式确认操作符的实现" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模式确认操作符的实现</p>
  </a>
  模式确认操作符的实现
</h2>
<p>模式确认操作符, 是要覆盖 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 这个函数的. 
新定义的宏, 兼容了 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 这个函数, 使用者不用关心其使用的 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 到底是
<a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 还是我们定义的宏. 为了方便使用者, 我们在模块中定义 <code class="inline">__using__/1</code> 宏.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.PatternConfirmer</span><span class="w"> </span><span class="k" data-group-id="1461392009-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="1461392009-2">(</span><span class="c">_opt</span><span class="p" data-group-id="1461392009-2">)</span><span class="w"> </span><span class="k" data-group-id="1461392009-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1461392009-4">do</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1461392009-5">[</span><span class="ss">=~</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1461392009-5">]</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.PatternConfirmer</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1461392009-6">[</span><span class="ss">=~</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1461392009-6">]</span><span class="w">
    </span><span class="k" data-group-id="1461392009-4">end</span><span class="w">
  </span><span class="k" data-group-id="1461392009-3">end</span><span class="w">
  </span><span class="c1">#...</span><span class="w">
</span><span class="k" data-group-id="1461392009-1">end</span></code></pre><p>这样, 在使用的时候, 只需要一个 <code class="inline">use</code> 语句 <code class="inline">use Corner.PatternConfirmer</code>
就可以完成宏导入的工作. 上面的代码片段是非常常见的 <code class="inline">__using__/1</code> 宏的写法.
这个宏完成的实际工作也非常的直观. 可以认为, 它完成了 C 或 Erlang 宏的文本替换的工作:
在编译时, 用 <code class="inline">quote do..end</code> 中的两个 <code class="inline">import</code> 语句替换了
<code class="inline">use Corner.PatternConfirmer</code>.</p><p>模式确认操作符 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 定义稍微复杂一点.
根据第一个参数, 也就是我们要确认的模式, 可以分成 4 中情况:</p><ol><li>模式为字符串</li><li>模式为正则表达式常量</li><li>模式为一个单独的变量</li><li>其他情况</li></ol><p>第一种情况最简单, 我们的宏只需要代理 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 函数就可以了.
第二种情况, 稍微复杂一点, 主要是对正则表达式的确认上有一点点的麻烦.
对这两种情况的处理代码为:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="k" data-group-id="8937708122-1">do</span><span class="w">
  </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="8937708122-2">do</span><span class="w">
    </span><span class="n">is_binary</span><span class="p" data-group-id="8937708122-3">(</span><span class="n">left</span><span class="p" data-group-id="8937708122-3">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">text_match</span><span class="p" data-group-id="8937708122-4">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="8937708122-4">)</span><span class="w">

    </span><span class="p" data-group-id="8937708122-5">(</span><span class="n">match?</span><span class="p" data-group-id="8937708122-6">(</span><span class="p" data-group-id="8937708122-7">{</span><span class="ss">:sigil_r</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8937708122-7">}</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p" data-group-id="8937708122-6">)</span><span class="w"> </span><span class="ow">or</span><span class="w">
       </span><span class="n">match?</span><span class="p" data-group-id="8937708122-8">(</span><span class="p" data-group-id="8937708122-9">{</span><span class="ss">:sigil_R</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8937708122-9">}</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p" data-group-id="8937708122-8">)</span><span class="p" data-group-id="8937708122-5">)</span><span class="w"> </span><span class="ow">and</span><span class="w">
        </span><span class="n">is_binary</span><span class="p" data-group-id="8937708122-10">(</span><span class="n">right</span><span class="p" data-group-id="8937708122-10">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">text_pattern_confirm</span><span class="p" data-group-id="8937708122-11">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="8937708122-11">)</span><span class="w">
  </span><span class="c1">#... other condtion</span><span class="w">
  </span><span class="k" data-group-id="8937708122-2">end</span><span class="w">
</span><span class="k" data-group-id="8937708122-1">end</span></code></pre><p>不难猜到 <code class="inline">text_match</code> 和 <code class="inline">text_pattern_confirm</code> 的代码:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">text_match</span><span class="p" data-group-id="3726555236-1">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="3726555236-1">)</span><span class="w"> </span><span class="k" data-group-id="3726555236-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3726555236-3">do</span><span class="w">
    </span><span class="nc">Kernel</span><span class="o">.</span><span class="o">=~</span><span class="p" data-group-id="3726555236-4">(</span><span class="k">unquote</span><span class="p" data-group-id="3726555236-5">(</span><span class="n">left</span><span class="p" data-group-id="3726555236-5">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3726555236-6">(</span><span class="n">right</span><span class="p" data-group-id="3726555236-6">)</span><span class="p" data-group-id="3726555236-4">)</span><span class="w">
  </span><span class="k" data-group-id="3726555236-3">end</span><span class="w">
</span><span class="k" data-group-id="3726555236-2">end</span><span class="w">

</span><span class="na">@compile</span><span class="w"> </span><span class="ss">online</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">text_pattern_confirm</span><span class="p" data-group-id="3726555236-7">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="3726555236-7">)</span><span class="w"> </span><span class="k" data-group-id="3726555236-8">do</span><span class="w">
  </span><span class="n">text_match</span><span class="p" data-group-id="3726555236-9">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p" data-group-id="3726555236-9">)</span><span class="w">
</span><span class="k" data-group-id="3726555236-8">end</span></code></pre><p><code class="inline">text_match</code> 和 <code class="inline">text_pattern_confirm</code> 作的工作是一样,
只是参数的位置做了调换. 所以要如此写, 是因为这时两个工作.
<code class="inline">text_match</code> 完成的是对 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 函数的兼容,
<code class="inline">text_pattern_confirm</code> 是以正则表达式为模式来作模式确认的.</p><p>第 3 个情形:  对单独的变量作模式的处理, <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 是一个函数,
第一个参数只要是字符串类型就可以, 除了使用字符串字面量外,
也可以用绑定了字符串得变量来作为 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 的第一个参数.
当模式确认操作符宏 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 的第一个参数是一个变量的时候,
宏运行在编译时, 而 Elixir 是一个动态编程语言, 变量绑定的值是什么类型,
只有在运行时才能知道. 所以宏定义中, 无法更具变量的值作进一步的区分.
为了和 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 兼容, 只好把这种情形都用 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 处理. 
当变量绑定的值不是字符串的时候, <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a> 就会抛出异常.
这时单独变量情形的特殊情况. 相关代码如下:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="k" data-group-id="8562074070-1">do</span><span class="w">
  </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="8562074070-2">do</span><span class="w">
    </span><span class="c1"># text_match and regex_confirem</span><span class="w">
    </span><span class="n">match?</span><span class="p" data-group-id="8562074070-3">(</span><span class="p" data-group-id="8562074070-4">{</span><span class="c">_atom</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8562074070-4">}</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p" data-group-id="8562074070-3">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">text_match</span><span class="p" data-group-id="8562074070-5">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="8562074070-5">)</span><span class="w">
    </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">other_pattern_confirm</span><span class="p" data-group-id="8562074070-6">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="8562074070-6">)</span><span class="w">
  </span><span class="k" data-group-id="8562074070-2">end</span><span class="w">
</span><span class="k" data-group-id="8562074070-1">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">other_pattern_confirm</span><span class="p" data-group-id="8562074070-7">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="8562074070-7">)</span><span class="w"> </span><span class="k" data-group-id="8562074070-8">do</span><span class="w">
  </span><span class="n">new_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">prewalk</span><span class="p" data-group-id="8562074070-9">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prewalker</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="8562074070-9">)</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8562074070-10">do</span><span class="w">
    </span><span class="n">match?</span><span class="p" data-group-id="8562074070-11">(</span><span class="k">unquote</span><span class="p" data-group-id="8562074070-12">(</span><span class="n">new_left</span><span class="p" data-group-id="8562074070-12">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8562074070-13">(</span><span class="n">right</span><span class="p" data-group-id="8562074070-13">)</span><span class="p" data-group-id="8562074070-11">)</span><span class="w">
  </span><span class="k" data-group-id="8562074070-10">end</span><span class="w">
</span><span class="k" data-group-id="8562074070-8">end</span></code></pre><p>最复杂的是对其他模式的处理. 主要的困难在于如何为普通的变量添加下划线前缀.
普通变量是指: 1. 变量不是以 <code class="inline">_</code> 为前缀, 2. 变量不是 pin (<code class="inline">^</code>) 操作符的操作数.
要完成对模式中普通变量的修改, 我们需要对模式的抽象语法树作遍历.
这里使用 <a href="https://hexdocs.pm/elixir/Macro.html#prewalk/2"><code class="inline">Macro.prewalk/2</code></a> 对抽象语法树, 执行前序遍历.</p><p>如果存在 <code class="inline">^a</code> 这样的表达式, 那么执行第一个 <code class="inline">prewalker/1</code> 分句,
这个分句是为之后的遍历中区分 <code class="inline">^a</code> 和 <code class="inline">a</code> 而作的准备工作.
这个分句为表达式 <code class="inline">^a</code> 中的 <code class="inline">a</code> 的抽象语法树,
添加元数据, <code class="inline">:exclude</code>, 以标记这个 <code class="inline">a</code> 不需要转化为 <code class="inline">_a</code>.</p><p>相关代码为:</p><pre><code class="makeup elixir" translate="no"><span class="na">@exclude_atoms</span><span class="w"> </span><span class="p" data-group-id="5419874543-1">[</span><span class="ss">:^</span><span class="p">,</span><span class="w"> </span><span class="ss">:%{}</span><span class="p">,</span><span class="w"> </span><span class="ss">:%</span><span class="p">,</span><span class="w"> </span><span class="ss">:{}</span><span class="p" data-group-id="5419874543-1">]</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">prewalker</span><span class="p" data-group-id="5419874543-2">(</span><span class="p" data-group-id="5419874543-3">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="5419874543-3">}</span><span class="p" data-group-id="5419874543-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">atom</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="na">@exclude_atoms</span><span class="w"> </span><span class="k" data-group-id="5419874543-4">do</span><span class="w">
  </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="5419874543-5">(</span><span class="w">
      </span><span class="n">args</span><span class="p">,</span><span class="w">
      </span><span class="k" data-group-id="5419874543-6">fn</span><span class="w">
        </span><span class="p" data-group-id="5419874543-7">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5419874543-7">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="5419874543-8">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5419874543-9">[</span><span class="ss">:exclude</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">meta</span><span class="p" data-group-id="5419874543-9">]</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5419874543-8">}</span><span class="w">
        </span><span class="p" data-group-id="5419874543-10">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p" data-group-id="5419874543-10">}</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">atom</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="na">@exclude_atoms</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="5419874543-11">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">prewalker</span><span class="p" data-group-id="5419874543-12">(</span><span class="n">other</span><span class="p" data-group-id="5419874543-12">)</span><span class="p" data-group-id="5419874543-11">}</span><span class="w">
      </span><span class="k" data-group-id="5419874543-6">end</span><span class="w">
    </span><span class="p" data-group-id="5419874543-5">)</span><span class="w">
  </span><span class="p" data-group-id="5419874543-13">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="5419874543-13">}</span><span class="w">
</span><span class="k" data-group-id="5419874543-4">end</span></code></pre><p>第二个 <code class="inline">prewalker/1</code> 分句处理标记过的变量, 去掉添加的 <code class="inline">:exclude</code> 标记,
还原为起初的样子.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">prewalker</span><span class="p" data-group-id="2079089425-1">(</span><span class="p" data-group-id="2079089425-2">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2079089425-3">[</span><span class="ss">:exclude</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">meta</span><span class="p" data-group-id="2079089425-3">]</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="2079089425-2">}</span><span class="p" data-group-id="2079089425-1">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2079089425-4">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="2079089425-4">}</span></code></pre><p>第三个 <code class="inline">prewalker/1</code> 分句处理没有被标记为 <code class="inline">:exclude</code> 的变量的抽象语法树.
如果变量名以 <code class="inline">_</code> 为前缀, 那么不用处理; 否则为变量添加 <code class="inline">_</code> 前缀. </p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">prewalker</span><span class="p" data-group-id="5122581257-1">(</span><span class="p" data-group-id="5122581257-2">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5122581257-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ast</span><span class="p" data-group-id="5122581257-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="5122581257-3">(</span><span class="n">atom</span><span class="p" data-group-id="5122581257-3">)</span><span class="w"> </span><span class="k" data-group-id="5122581257-4">do</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="5122581257-5">#{</span><span class="n">atom</span><span class="si" data-group-id="5122581257-5">}</span><span class="s">&quot;</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">starts_with?</span><span class="p" data-group-id="5122581257-6">(</span><span class="s">&quot;_&quot;</span><span class="p" data-group-id="5122581257-6">)</span><span class="w"> </span><span class="k" data-group-id="5122581257-7">do</span><span class="w">
    </span><span class="n">ast</span><span class="w">
  </span><span class="k" data-group-id="5122581257-7">else</span><span class="w">
    </span><span class="n">atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;_</span><span class="si" data-group-id="5122581257-8">#{</span><span class="n">atom</span><span class="si" data-group-id="5122581257-8">}</span><span class="s">&quot;</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="5122581257-9">(</span><span class="p" data-group-id="5122581257-9">)</span><span class="w">
    </span><span class="p" data-group-id="5122581257-10">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5122581257-10">}</span><span class="w">
  </span><span class="k" data-group-id="5122581257-7">end</span><span class="w">
</span><span class="k" data-group-id="5122581257-4">end</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">prewalker</span><span class="p" data-group-id="5122581257-11">(</span><span class="n">ast</span><span class="p" data-group-id="5122581257-11">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">ast</span></code></pre><p>最后一个 <code class="inline">prewalker/1</code> 分句对所有其他的抽象语法树, 保持不变, 原样返回.</p><p><a href="https://hexdocs.pm/elixir/Macro.html#prewalk/2"><code class="inline">Macro.prewalk/2</code></a> 在调用第一个分句后, 对其返回的结果, 会继续使用后面的分句作遍历.
后面的三个分句中, 有一个会执行. 这样就完成了对普通变量添加 <code class="inline">_</code> 前缀的工作.</p><p>最后, 让我们看看如何使用我们的模式确认操作符 <code class="inline">=~</code>, 首先我们的定义兼容: <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">Kernel.=~/2</code></a>.</p><pre><code class="makeup elixir" translate="no"><span class="kn">use</span><span class="w"> </span><span class="nc">Corner.PatternConfirmer</span><span class="w">
</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/hell/</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/wolrd/</span><span class="w"> </span><span class="c1"># false</span><span class="w">
</span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">~r/hel{1,2}o/</span><span class="w">
</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="s">&quot;helo&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="s">&quot;world&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w"> </span><span class="c1">#false</span><span class="w">
</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">
</span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">~r/hel{1,2}o/</span><span class="w">
</span><span class="n">str</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w"> </span><span class="c1">#true</span></code></pre><p>当我们使用用魔符来创建表达式得时候, 正则表达式, 也可以作为模式确认操作符 <code class="inline">=~</code>
的第一个操作数.</p><pre><code class="makeup elixir" translate="no"><span class="sr">~r/hell/</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="sr">~R/hel{1,2}o/</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="sr">~R/hel{1,2}o/</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">&quot;helo&quot;</span><span class="w"> </span><span class="c1">#true </span></code></pre><p>但是传递给模式确认操作符 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 的第一个参数为一个变量的时候,
这个变量的绑定值不是字符串, 而是其他值得时候, 就会抛出错误.</p><pre><code class="makeup elixir" translate="no"><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">~r/hell/</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="c1">#raise FunctionClauseError</span></code></pre><p>最后, 对其他模式的支持:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="7112503694-1">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7112503694-1">]</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="p" data-group-id="7112503694-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="7112503694-2">]</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7112503694-3">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="7112503694-3">}</span><span class="w">
</span><span class="p" data-group-id="7112503694-4">{</span><span class="o">^</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7112503694-4">}</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="mi">1</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="p" data-group-id="7112503694-5">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7112503694-5">}</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="p" data-group-id="7112503694-6">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="7112503694-6">}</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="mi">1</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">#false</span><span class="w">
</span><span class="p" data-group-id="7112503694-7">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7112503694-7">]</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="p" data-group-id="7112503694-8">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="7112503694-8">}</span><span class="w"> </span><span class="c1">#false</span><span class="w">
</span><span class="p" data-group-id="7112503694-9">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7112503694-9">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7112503694-10">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="ss">:bad</span><span class="p" data-group-id="7112503694-10">}</span><span class="w"> </span><span class="c1">#true</span></code></pre><h2 id="按模式提取信息" class="section-heading">
  <a href="#按模式提取信息" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">按模式提取信息</p>
  </a>
  按模式提取信息
</h2>
<p>与 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 以及 <code class="inline">~=</code> 提供的功能刚好相反, Elixir 中也提供了,
专注于按模式提取数据的语法结构:</p><ol><li><a href="https://hexdocs.pm/elixir/Kernel.html#destructure/2"><code class="inline">destructure/2</code></a> 针对列表</li><li><a href="https://hexdocs.pm/elixir/Kernel.html#get_in/2"><code class="inline">get_in/2</code></a> 针对 Access 行为</li></ol><p>我喜欢 <code class="inline">descructure</code> 这个函数, 它让我怀念 Javascript 的解构操作.
可惜 <code class="inline">descruture/2</code> 这个函数只支持对列表的解构.
例如下面 Javascript 代码:</p><pre><code class="makeup javascript" translate="no"><span class="kd">let</span><span class="w"> </span><span class="p" data-group-id="2933208713-1">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="2933208713-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2933208713-2">[</span><span class="mi">1</span><span class="p" data-group-id="2933208713-2">]</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="2933208713-3">(</span><span class="n">a</span><span class="p" data-group-id="2933208713-3">)</span><span class="w"> </span><span class="p">\\</span><span class="mi">1</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="2933208713-4">(</span><span class="n">b</span><span class="p" data-group-id="2933208713-4">)</span><span class="w"> </span><span class="p">\\</span><span class="kc">undefined</span></code></pre><p>Elixir 中对应的代码为:</p><pre><code class="makeup elixir" translate="no"><span class="n">destructure</span><span class="p" data-group-id="9010103668-1">(</span><span class="p" data-group-id="9010103668-2">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="9010103668-2">]</span><span class="p">,</span><span class="p" data-group-id="9010103668-3">[</span><span class="mi">1</span><span class="p" data-group-id="9010103668-3">]</span><span class="p" data-group-id="9010103668-1">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="9010103668-4">(</span><span class="n">a</span><span class="p" data-group-id="9010103668-4">)</span><span class="w"> </span><span class="c1"># 1</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="9010103668-5">(</span><span class="n">b</span><span class="p" data-group-id="9010103668-5">)</span><span class="w"> </span><span class="c1">#nil</span></code></pre><p>Javascript 中的结构, 不但可以应用于数组, 也可以应用于对象.
例如</p><pre><code class="makeup javascript" translate="no"><span class="kd">let</span><span class="w"> </span><span class="p" data-group-id="6203407672-1">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="6203407672-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6203407672-2">{</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6203407672-2">}</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="6203407672-3">(</span><span class="n">a</span><span class="p" data-group-id="6203407672-3">)</span><span class="w"> </span><span class="p">\\</span><span class="mi">1</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="6203407672-4">(</span><span class="n">b</span><span class="p" data-group-id="6203407672-4">)</span><span class="w"> </span><span class="p">\\</span><span class="w"> </span><span class="kc">undefined</span></code></pre><p>而 Elixir 的 <a href="https://hexdocs.pm/elixir/Kernel.html#destructure/2"><code class="inline">destructure/2</code></a> 当前版本还不支持其他的类型的解构.</p><p>Javascript 的解构操作, 对嵌套的支持也很好.</p><pre><code class="makeup javascript" translate="no"><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5875487821-1">[</span><span class="n">a</span><span class="p">,</span><span class="p" data-group-id="5875487821-2">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p" data-group-id="5875487821-2">]</span><span class="p" data-group-id="5875487821-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5875487821-3">[</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="5875487821-4">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="5875487821-4">]</span><span class="p" data-group-id="5875487821-3">]</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-5">(</span><span class="n">a</span><span class="p" data-group-id="5875487821-5">)</span><span class="w"> </span><span class="p">\\</span><span class="mi">1</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-6">(</span><span class="n">b</span><span class="p" data-group-id="5875487821-6">)</span><span class="w"> </span><span class="p">\\</span><span class="mi">2</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-7">(</span><span class="n">c</span><span class="p" data-group-id="5875487821-7">)</span><span class="w"> </span><span class="p">\\</span><span class="mi">3</span><span class="w">
</span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5875487821-8">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5875487821-9">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p" data-group-id="5875487821-9">]</span><span class="p" data-group-id="5875487821-8">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5875487821-10">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5875487821-11">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="5875487821-11">]</span><span class="p" data-group-id="5875487821-10">]</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-12">(</span><span class="n">a</span><span class="p" data-group-id="5875487821-12">)</span><span class="w"> </span><span class="p">\\</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-13">(</span><span class="n">b</span><span class="p" data-group-id="5875487821-13">)</span><span class="w"> </span><span class="p">\\</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-14">(</span><span class="n">c</span><span class="p" data-group-id="5875487821-14">)</span><span class="w"> </span><span class="p">\\</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p" data-group-id="5875487821-15">(</span><span class="n">d</span><span class="p" data-group-id="5875487821-15">)</span><span class="w"> </span><span class="p">\\</span><span class="kc">undefined</span></code></pre><p>而 Elixir 的 <a href="https://hexdocs.pm/elixir/Kernel.html#destructure/2"><code class="inline">destructure/2</code></a>, 即使对列表的解构, 列表中嵌套列表是, 
解构操作也不会递归展开. 例如和上面 Javascript 对应的 Elixir 代码, 在当前的版本中,
会抛出 MatchError 错误:</p><pre><code class="makeup elixir" translate="no"><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">nil</span><span class="w">
</span><span class="n">destructure</span><span class="p" data-group-id="2862463836-1">(</span><span class="p" data-group-id="2862463836-2">[</span><span class="n">a</span><span class="p">,</span><span class="p" data-group-id="2862463836-3">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p" data-group-id="2862463836-3">]</span><span class="p" data-group-id="2862463836-2">]</span><span class="p">,</span><span class="p" data-group-id="2862463836-4">[</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2862463836-5">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="2862463836-5">]</span><span class="p" data-group-id="2862463836-4">]</span><span class="p" data-group-id="2862463836-1">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2862463836-6">(</span><span class="n">a</span><span class="p" data-group-id="2862463836-6">)</span><span class="w"> </span><span class="c1">#1</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2862463836-7">(</span><span class="n">b</span><span class="p" data-group-id="2862463836-7">)</span><span class="w"> </span><span class="c1">#2</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2862463836-8">(</span><span class="n">c</span><span class="p" data-group-id="2862463836-8">)</span><span class="w"> </span><span class="c1">#3</span><span class="w">
</span><span class="n">destructure</span><span class="p" data-group-id="2862463836-9">(</span><span class="p" data-group-id="2862463836-10">[</span><span class="n">a</span><span class="p">,</span><span class="p" data-group-id="2862463836-11">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p" data-group-id="2862463836-11">]</span><span class="p" data-group-id="2862463836-10">]</span><span class="p">,</span><span class="p" data-group-id="2862463836-12">[</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2862463836-13">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="2862463836-13">]</span><span class="p" data-group-id="2862463836-12">]</span><span class="p" data-group-id="2862463836-9">)</span><span class="w"> </span><span class="c1">#抛出错误 </span></code></pre><p>和模式确认操作符类似, 我们可以定义一个新的操作符, 来完成按模式提取操作(Extract base
Pattern). 这个宏应该是一个二元宏. 以操作符的形式提供可以让代码的可读性更强.</p><p>向左箭头 <code class="inline">&lt;-</code> 或 <code class="inline">&lt;~</code> 操作符都是我心目中的候选者. 但是 <code class="inline">&lt;-</code> 在 <code class="inline">for</code> 和 <code class="inline">with</code>
结构中承担有一定的功能, 如果以 <code class="inline">&lt;-</code> 作为我们的操作符, 那么我们还需要考虑 <code class="inline">for</code> 和
<code class="inline">with</code> 解构中的 <code class="inline">&lt;-</code> 操作符的兼容容问题. 为了少些一些代码, 同时也减少使用者的迷惑,
<code class="inline">&lt;~</code> 是我最后的选择. 将要定义的 <code class="inline">&lt;~</code> 操作符要完成按模式提取的操作,
因此把它命名为模式提取操作符 (Pattern Extracter).</p><p>Elixir 中, 可以用来完成数据组合的有以下几种类型:</p><ol><li>列表</li><li>元组</li><li>map</li></ol><p>我们将要定义的模式提取操作符 <code class="inline">&lt;~</code>, 第一个参数是一个模式 <code class="inline">pattern</code>;
第二个参数是一个值 <code class="inline">value</code>. <code class="inline">pattern</code> 现在不但可以是列表,
还支持元组和 map 字面量. 而且对嵌套模式提取也提供支持.</p><p>现在, 让我们分析一下模式提取操作应该完成的功能:</p><ol><li>当 <code class="inline">pattern</code> 与 <code class="inline">value</code> 完全匹配, 那么 <code class="inline">pattern</code>
中的变量都会绑定相匹配的值.</li><li>当 <code class="inline">pattern</code> 匹配 <code class="inline">value</code> 的一部分的时候, <code class="inline">pattern</code> 中的变量也完成值绑定,
<em>而不是抛出匹配失败</em>. 就像表达式 <code class="inline">destructure([a,b], [1,2,3])</code>,
完成变量 <code class="inline">a</code> 绑定为 <code class="inline">1</code>, <code class="inline">b</code> 绑定 <code class="inline">2</code> 那样.</li><li>当 <code class="inline">value</code> 的模式是 <code class="inline">pattern</code> 的一部分的时候, 那么 <code class="inline">pattern</code> 中多出的变量,
都绑定为 <code class="inline">nil</code>, 就像 <code class="inline">destructure([a,b,c],[1])</code> 为变量 <code class="inline">a</code> 绑定为 <code class="inline">1</code>,
<code class="inline">b</code> 和 <code class="inline">c</code> 绑定为 <code class="inline">nil</code> 那样.</li></ol><p>和模式确认操作符 <a href="https://hexdocs.pm/elixir/Kernel.html#=~/2"><code class="inline">=~/2</code></a> 类似, 这里我们也根据模式提取操作符 <code class="inline">&lt;~</code> 的模式的不同情形,
分别处理:</p><ol><li>列表</li><li>元组</li><li>map</li><li>其他情形</li></ol><p>将要定义的模式提取操作符, 需要对嵌套解构作处理, 那么必然的涉及到递归调用.
在实现的时候, 我们使用一个私有函数来完成宏的工作.
所以要这样是因为对宏作递归调用比较的麻烦. 而对函数作递归调用就简单了.
所以整个宏, 就只是对私有函数 <code class="inline">my_destructure/2</code> 的调用;
而 <code class="inline">my_destructure/2</code> 函数则根据模式的不同情形完成具体的处理工作.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Corner.PatternExtracter</span><span class="w"> </span><span class="k" data-group-id="5955638784-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k" data-group-id="5955638784-2">do</span><span class="w">
    </span><span class="n">my_destructure</span><span class="p" data-group-id="5955638784-3">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5955638784-3">)</span><span class="w">
  </span><span class="k" data-group-id="5955638784-2">end</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">my_destructure</span><span class="p" data-group-id="5955638784-4">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5955638784-4">)</span><span class="w"> </span><span class="k" data-group-id="5955638784-5">do</span><span class="w">
    </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="5955638784-6">do</span><span class="w">
      </span><span class="n">is_list</span><span class="p" data-group-id="5955638784-7">(</span><span class="n">pattern</span><span class="p" data-group-id="5955638784-7">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">destructure_list</span><span class="p" data-group-id="5955638784-8">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5955638784-8">)</span><span class="w">

      </span><span class="nc">Ast</span><span class="o">.</span><span class="n">is_tuple?</span><span class="p" data-group-id="5955638784-9">(</span><span class="n">pattern</span><span class="p" data-group-id="5955638784-9">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">destructure_tuple</span><span class="p" data-group-id="5955638784-10">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5955638784-10">)</span><span class="w">

      </span><span class="ow">not</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">is_struct?</span><span class="p" data-group-id="5955638784-11">(</span><span class="n">pattern</span><span class="p" data-group-id="5955638784-11">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">is_map?</span><span class="p" data-group-id="5955638784-12">(</span><span class="n">pattern</span><span class="p" data-group-id="5955638784-12">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">destructure_map</span><span class="p" data-group-id="5955638784-13">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5955638784-13">)</span><span class="w">

      </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">raise_syntax_error</span><span class="p" data-group-id="5955638784-14">(</span><span class="n">pattern</span><span class="p" data-group-id="5955638784-14">)</span><span class="w">
    </span><span class="k" data-group-id="5955638784-6">end</span><span class="w">
  </span><span class="k" data-group-id="5955638784-5">end</span><span class="w">
  </span><span class="c1">#...other code</span><span class="w">
</span><span class="k" data-group-id="5955638784-1">end</span></code></pre><p>这样的代码, 非常的清晰明了, 基本上不用作解释. <code class="inline">Ast</code> 是辅助模块,
用来帮助我们完成对某些抽象语法树的确认工作. 比如这里用到的 <code class="inline">Ast.is_tuple?/1</code>,
<code class="inline">Ast.is_map?/1</code> 等, 用来检查输入的 ast 是否是对应类型的字面量表达式的抽象语法树.
这里我们并没有支持结构 (struct).</p><p>所以不支持结构是因为, 编译阶段无法对结构作做出确认.
模式提取操作符关注的是提取, 结构名无关数据而仅关乎匹配确认,
如果模式中附带了结构形式, 对于数据的提取不会有帮助,
但是数据的结构与模式中提供的结构不一致的时候, 还会引发匹配错误.
与其让这种错误在运行时发生, 不如在编译时就直接报错.</p><p>列表, 元组和 map 之外的其他情形, 记录外, 还可以有单个变量表示模式.
单变量模式, 语法上虽然是合法的, 但是其效果应该等同于匹配操作符 <code class="inline">=</code>.
如果不是使用错误, 那么就应该使用匹配操作符 <code class="inline">=</code>.
此外, 模式的最后一种情形就是 pin 操作符与变量的组合表达式 <code class="inline">^pattern</code>,
这种模式是对 <code class="inline">pattern</code> 绑定的值做模式确认的, 在模式确认中或许有意义,
在按模式提取数据是, 完全没有意义. 所以, 其他的情形,
我们的宏抛出错误语法错误.</p><p>首先让来看看列表如何实现模式提取的. 对列表来说,
<a href="https://hexdocs.pm/elixir/Kernel.html#destructure/2"><code class="inline">Kernel.destructure/2</code></a> 已经很好的完成了列表中无嵌套结构的模式匹配了.
所以我们最主要的工作就是如何实现列表中嵌套结构的匹配.
例如这样的 <code class="inline">[a, [b,c,d]] &lt;~ [1, [2]]</code>. 要实现把变量 <code class="inline">a</code> 绑定 <code class="inline">1</code>,
<code class="inline">b</code> 绑定为 <code class="inline">2</code>, <code class="inline">c</code> 和 <code class="inline">d</code> 都绑定为 <code class="inline">nil</code>. 我们可以把这个表达式转化:
<code class="inline">destructure([a,mid_var], [1,[2]])</code> 和 <code class="inline">destructure([b,c,d],mid_var)</code>.</p><p>所以要做的工作就是识别出列表中的嵌套结构,
并通过中间变量作为桥梁来完成内部嵌套结构的解构.</p><p>对应的代码为:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">destructure_list</span><span class="p" data-group-id="5802837848-1">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5802837848-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_list</span><span class="p" data-group-id="5802837848-2">(</span><span class="n">pattern</span><span class="p" data-group-id="5802837848-2">)</span><span class="w"> </span><span class="k" data-group-id="5802837848-3">do</span><span class="w">
  </span><span class="p" data-group-id="5802837848-4">{</span><span class="w">
    </span><span class="n">var_patterns</span><span class="p">,</span><span class="w">
    </span><span class="n">nest_destructure_ast</span><span class="w">
  </span><span class="p" data-group-id="5802837848-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Helpers</span><span class="o">.</span><span class="n">split_nest_pattern</span><span class="p" data-group-id="5802837848-5">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_destructure</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="5802837848-5">)</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="ss">generated</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="k" data-group-id="5802837848-6">do</span><span class="w">
    </span><span class="n">destructure</span><span class="p" data-group-id="5802837848-7">(</span><span class="k">unquote</span><span class="p" data-group-id="5802837848-8">(</span><span class="n">var_patterns</span><span class="p" data-group-id="5802837848-8">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5802837848-9">(</span><span class="n">value</span><span class="p" data-group-id="5802837848-9">)</span><span class="p" data-group-id="5802837848-7">)</span><span class="w">
    </span><span class="k">unquote_splicing</span><span class="p" data-group-id="5802837848-10">(</span><span class="n">nest_destructure_ast</span><span class="p" data-group-id="5802837848-10">)</span><span class="w">
  </span><span class="k" data-group-id="5802837848-6">end</span><span class="w">
</span><span class="k" data-group-id="5802837848-3">end</span><span class="w">
</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Helpers</span><span class="w"> </span><span class="k" data-group-id="5802837848-11">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">split_nest_pattern</span><span class="p" data-group-id="5802837848-12">(</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="5802837848-12">)</span><span class="w"> </span><span class="k" data-group-id="5802837848-13">do</span><span class="w">
    </span><span class="p" data-group-id="5802837848-14">{</span><span class="n">var_patterns</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-14">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">change_composed_pattern_to_variable</span><span class="p" data-group-id="5802837848-15">(</span><span class="n">ast</span><span class="p" data-group-id="5802837848-15">)</span><span class="w">
    </span><span class="n">nest_destruct_ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="5802837848-16">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="5802837848-17">(</span><span class="n">elem</span><span class="p" data-group-id="5802837848-18">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="5802837848-18">)</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span><span class="p" data-group-id="5802837848-19">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5802837848-19">)</span><span class="p" data-group-id="5802837848-17">)</span><span class="p" data-group-id="5802837848-16">)</span><span class="w">
    </span><span class="p" data-group-id="5802837848-20">{</span><span class="n">var_patterns</span><span class="p">,</span><span class="w"> </span><span class="n">nest_destruct_ast</span><span class="p" data-group-id="5802837848-20">}</span><span class="w">
  </span><span class="k" data-group-id="5802837848-13">end</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">change_composed_pattern_to_variable</span><span class="p" data-group-id="5802837848-21">(</span><span class="n">ast</span><span class="p" data-group-id="5802837848-21">)</span><span class="w"> </span><span class="k" data-group-id="5802837848-22">do</span><span class="w">
    </span><span class="p" data-group-id="5802837848-23">{</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-23">}</span><span class="w"> </span><span class="o">=</span><span class="w">
      </span><span class="k">for</span><span class="w"> </span><span class="n">ele</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="ss">reduce</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5802837848-24">{</span><span class="p" data-group-id="5802837848-25">[</span><span class="p" data-group-id="5802837848-25">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5802837848-26">%{</span><span class="p" data-group-id="5802837848-26">}</span><span class="p" data-group-id="5802837848-24">}</span><span class="w"> </span><span class="k" data-group-id="5802837848-27">do</span><span class="w">
        </span><span class="p" data-group-id="5802837848-28">{</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-28">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">if</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">is_composed_type?</span><span class="p" data-group-id="5802837848-29">(</span><span class="n">ele</span><span class="p" data-group-id="5802837848-29">)</span><span class="w"> </span><span class="k" data-group-id="5802837848-30">do</span><span class="w">
            </span><span class="n">mid_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">unique_var</span><span class="p" data-group-id="5802837848-31">(</span><span class="ss">:var_for_destruct</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="5802837848-31">)</span><span class="w">
            </span><span class="n">patterns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5802837848-32">[</span><span class="n">mid_var</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">patterns</span><span class="p" data-group-id="5802837848-32">]</span><span class="w">
            </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="5802837848-33">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">ele</span><span class="p">,</span><span class="w"> </span><span class="n">mid_var</span><span class="p" data-group-id="5802837848-33">)</span><span class="w">
            </span><span class="p" data-group-id="5802837848-34">{</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-34">}</span><span class="w">
          </span><span class="k" data-group-id="5802837848-30">else</span><span class="w">
            </span><span class="p" data-group-id="5802837848-35">{</span><span class="p" data-group-id="5802837848-36">[</span><span class="n">ele</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">patterns</span><span class="p" data-group-id="5802837848-36">]</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-35">}</span><span class="w">
          </span><span class="k" data-group-id="5802837848-30">end</span><span class="w">
      </span><span class="k" data-group-id="5802837848-27">end</span><span class="w">
    </span><span class="p" data-group-id="5802837848-37">{</span><span class="nc">Enum</span><span class="o">.</span><span class="n">reverse</span><span class="p" data-group-id="5802837848-38">(</span><span class="n">patterns</span><span class="p" data-group-id="5802837848-38">)</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p" data-group-id="5802837848-37">}</span><span class="w">
  </span><span class="k" data-group-id="5802837848-22">end</span><span class="w">
</span><span class="k" data-group-id="5802837848-11">end</span></code></pre><p>这里最主要的工作由 <code class="inline">Helpers.split_nest_pattern/2</code> 完成.
它完成两个工作:</p><ol><li>使用中间变量替换 <code class="inline">pattern</code> 中的嵌套解构;</li><li>对中间变量和替换的嵌套解构做递归解构操作.</li></ol><p>第一个工作由 <code class="inline">Helpers.change_composed_pattern_to_variable/1</code> 完成.
第二个工作由 <code class="inline">Enum.map</code> 这个语句完成, 因为 <code class="inline">destructure_list/2</code> 中,
我们传递给 <code class="inline">split_nest_pattern/2</code> 的第二个参数就是我们的 <code class="inline">my_structure/2</code>.</p><p>对元组的处理和列表的处理非常类似.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">destructure_tuple</span><span class="p" data-group-id="4772711150-1">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="p" data-group-id="4772711150-1">)</span><span class="w"> </span><span class="k" data-group-id="4772711150-2">do</span><span class="w">
  </span><span class="n">pattern_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">tuple_size</span><span class="p" data-group-id="4772711150-3">(</span><span class="n">pattern</span><span class="p" data-group-id="4772711150-3">)</span><span class="w">
  </span><span class="p" data-group-id="4772711150-4">{</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">nest_destruct_ast</span><span class="p" data-group-id="4772711150-4">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="nc">Ast</span><span class="o">.</span><span class="n">tuple_to_list</span><span class="p" data-group-id="4772711150-5">(</span><span class="n">pattern</span><span class="p" data-group-id="4772711150-5">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Helpers</span><span class="o">.</span><span class="n">split_nest_pattern</span><span class="p" data-group-id="4772711150-6">(</span><span class="o">&amp;</span><span class="n">my_destructure</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="4772711150-6">)</span><span class="w">
  </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4772711150-7">{</span><span class="ss">:{}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4772711150-8">[</span><span class="p" data-group-id="4772711150-8">]</span><span class="p">,</span><span class="w"> </span><span class="n">patterns</span><span class="p" data-group-id="4772711150-7">}</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4772711150-9">do</span><span class="w">
    </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4772711150-10">(</span><span class="n">tuple</span><span class="p" data-group-id="4772711150-10">)</span><span class="w">
    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4772711150-11">(</span><span class="bp">__MODULE__</span><span class="p" data-group-id="4772711150-11">)</span><span class="o">.</span><span class="nc">Helpers</span><span class="w">
    </span><span class="n">patch_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">.</span><span class="n">make</span><span class="p" data-group-id="4772711150-12">(</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="ss">to_size</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4772711150-13">(</span><span class="n">pattern_size</span><span class="p" data-group-id="4772711150-13">)</span><span class="p" data-group-id="4772711150-12">)</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="4772711150-14">(</span><span class="n">pattern</span><span class="p" data-group-id="4772711150-14">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">patch_right</span><span class="w">
    </span><span class="k">unquote_splicing</span><span class="p" data-group-id="4772711150-15">(</span><span class="n">nest_destruct_ast</span><span class="p" data-group-id="4772711150-15">)</span><span class="w">
  </span><span class="k" data-group-id="4772711150-9">end</span><span class="w">
</span><span class="k" data-group-id="4772711150-2">end</span></code></pre><p>这里的区别就是, 我们是使用匹配操作符 <code class="inline">=</code>
完成元组的匹配工作的. 要保证元组匹配时不抛出错误,
需要保证匹配操作符 <code class="inline">=</code> 两边的元组大小一样.
这个工作由 <code class="inline">Helpers.make(tuple,to_size: size)</code> 完成.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">make</span><span class="p" data-group-id="2098194945-1">(</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="ss">to_size</span><span class="p">:</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="2098194945-1">)</span><span class="w"> </span><span class="k" data-group-id="2098194945-2">do</span><span class="w">
  </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_size</span><span class="p" data-group-id="2098194945-3">(</span><span class="n">tuple</span><span class="p" data-group-id="2098194945-3">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">size</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="k" data-group-id="2098194945-4">do</span><span class="w">
    </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="w">
    </span><span class="n">n</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">.</span><span class="n">drop</span><span class="p" data-group-id="2098194945-5">(</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="ss">:tail</span><span class="p" data-group-id="2098194945-5">)</span><span class="w">
    </span><span class="n">n</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">.</span><span class="n">padding</span><span class="p" data-group-id="2098194945-6">(</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="ss">:tail</span><span class="p" data-group-id="2098194945-6">)</span><span class="w">
  </span><span class="k" data-group-id="2098194945-4">end</span><span class="w">
</span><span class="k" data-group-id="2098194945-2">end</span></code></pre><p>上面代码中的 <a href="https://hexdocs.pm/elixir/Tuple.html"><code class="inline">Tuple</code></a> 是 <code class="inline">Corner.Tuple</code> 的别名, 是辅助模块.</p><p>对 map 的解构处理由 <code class="inline">destructure_map(pattern, value)</code> 完成.
这里代码框架与列表以及元组的处理相同. 为了避免匹配操作符 <code class="inline">=</code> 抛出匹配错误,
要根据 <code class="inline">pattern</code> 构建一个所有的值都为 <code class="inline">nil</code> 的对象.
然后把 <code class="inline">value</code> 与新创建的 map 合并. 这样相等于为 <code class="inline">pattern</code> 中存在,
而 <code class="inline">value</code> 中不存在的字段创建了默认值.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">destructure_map</span><span class="p" data-group-id="6980618213-1">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="6980618213-1">)</span><span class="w"> </span><span class="k" data-group-id="6980618213-2">do</span><span class="w">
  </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">map_keys</span><span class="p" data-group-id="6980618213-3">(</span><span class="n">pattern</span><span class="p" data-group-id="6980618213-3">)</span><span class="w">

  </span><span class="p" data-group-id="6980618213-4">{</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">nest_destruct_ast</span><span class="p" data-group-id="6980618213-4">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="nc">Ast</span><span class="o">.</span><span class="n">map_values</span><span class="p" data-group-id="6980618213-5">(</span><span class="n">pattern</span><span class="p" data-group-id="6980618213-5">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Helpers</span><span class="o">.</span><span class="n">split_nest_pattern</span><span class="p" data-group-id="6980618213-6">(</span><span class="o">&amp;</span><span class="n">my_destructure</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="6980618213-6">)</span><span class="w">

  </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ast</span><span class="o">.</span><span class="n">make_map</span><span class="p" data-group-id="6980618213-7">(</span><span class="n">keys</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p" data-group-id="6980618213-7">)</span><span class="w">
  </span><span class="n">default_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_default</span><span class="p" data-group-id="6980618213-8">(</span><span class="n">pattern</span><span class="p" data-group-id="6980618213-8">)</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6980618213-9">do</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="6980618213-10">(</span><span class="n">map</span><span class="p" data-group-id="6980618213-10">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">merge</span><span class="p" data-group-id="6980618213-11">(</span><span class="k">unquote</span><span class="p" data-group-id="6980618213-12">(</span><span class="n">default_value</span><span class="p" data-group-id="6980618213-12">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6980618213-13">(</span><span class="n">value</span><span class="p" data-group-id="6980618213-13">)</span><span class="p" data-group-id="6980618213-11">)</span><span class="w">
    </span><span class="k">unquote_splicing</span><span class="p" data-group-id="6980618213-14">(</span><span class="n">nest_destruct_ast</span><span class="p" data-group-id="6980618213-14">)</span><span class="w">
  </span><span class="k" data-group-id="6980618213-9">end</span><span class="w">
</span><span class="k" data-group-id="6980618213-2">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_default</span><span class="p" data-group-id="6980618213-15">(</span><span class="n">ast</span><span class="p" data-group-id="6980618213-15">)</span><span class="w"> </span><span class="k" data-group-id="6980618213-16">do</span><span class="w">
  </span><span class="nc">Macro</span><span class="o">.</span><span class="n">postwalk</span><span class="p" data-group-id="6980618213-17">(</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable_to_nil</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="6980618213-17">)</span><span class="w">
</span><span class="k" data-group-id="6980618213-16">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">variable_to_nil</span><span class="p" data-group-id="6980618213-18">(</span><span class="p" data-group-id="6980618213-19">{</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="6980618213-19">}</span><span class="p" data-group-id="6980618213-18">)</span><span class="w">
     </span><span class="ow">when</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="6980618213-20">(</span><span class="n">atom</span><span class="p" data-group-id="6980618213-20">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="6980618213-21">[</span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="6980618213-21">]</span><span class="p">,</span><span class="w">
     </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">variable_to_nil</span><span class="p" data-group-id="6980618213-22">(</span><span class="n">v</span><span class="p" data-group-id="6980618213-22">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">v</span></code></pre><p>模式提取操作符 <code class="inline">&lt;~</code> 兼容并增强了 <code class="inline">Kerner.destructure/2</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">Corner.PatternExtracter</span><span class="w">
</span><span class="p" data-group-id="1753810803-1">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="1753810803-1">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="1753810803-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1753810803-2">]</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1753810803-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1753810803-3">]</span><span class="w">
</span><span class="p" data-group-id="1753810803-4">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="1753810803-4">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="n">array</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="p" data-group-id="1753810803-5">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="1753810803-5">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="1753810803-6">[</span><span class="mi">1</span><span class="p" data-group-id="1753810803-6">]</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1">#true</span><span class="w">

</span><span class="p" data-group-id="1753810803-7">[</span><span class="n">a</span><span class="p">,</span><span class="p" data-group-id="1753810803-8">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p" data-group-id="1753810803-8">]</span><span class="p" data-group-id="1753810803-7">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="1753810803-9">[</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="1753810803-10">[</span><span class="mi">2</span><span class="p" data-group-id="1753810803-10">]</span><span class="p" data-group-id="1753810803-9">]</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">destructure</span><span class="p" data-group-id="1753810803-11">(</span><span class="p" data-group-id="1753810803-12">[</span><span class="n">a</span><span class="p">,</span><span class="p" data-group-id="1753810803-13">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p" data-group-id="1753810803-13">]</span><span class="p" data-group-id="1753810803-12">]</span><span class="p">,</span><span class="p" data-group-id="1753810803-14">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1753810803-14">]</span><span class="p" data-group-id="1753810803-11">)</span><span class="w"> </span><span class="c1">#raise badmatch error</span></code></pre><p>对于元组, 我们可以这样使用:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="5897532405-1">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="5897532405-1">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="5897532405-2">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="5897532405-2">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="p" data-group-id="5897532405-3">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="5897532405-3">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="5897532405-4">{</span><span class="mi">1</span><span class="p" data-group-id="5897532405-4">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1">#true</span><span class="w">
</span><span class="p" data-group-id="5897532405-5">{</span><span class="n">a</span><span class="p" data-group-id="5897532405-5">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="5897532405-6">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="5897532405-6">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#true</span><span class="w">

</span><span class="p" data-group-id="5897532405-7">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5897532405-8">{</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="5897532405-8">}</span><span class="p" data-group-id="5897532405-7">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="5897532405-9">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5897532405-10">{</span><span class="mi">2</span><span class="p" data-group-id="5897532405-10">}</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5897532405-9">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="p" data-group-id="5897532405-11">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5897532405-12">{</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="5897532405-12">}</span><span class="p" data-group-id="5897532405-11">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="5897532405-13">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5897532405-14">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="5897532405-14">}</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="5897532405-13">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">#true</span></code></pre><p>当模式为 map 时, 可以像下面的代码那样, 来使用模式提取操作符 <code class="inline">&lt;~</code>:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="9717508410-1">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="9717508410-1">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="9717508410-2">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9717508410-2">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9717508410-3">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="9717508410-3">}</span><span class="p">;</span><span class="w"> 
</span><span class="p" data-group-id="9717508410-4">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="9717508410-4">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="n">map</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1"># true</span><span class="w">
</span><span class="p" data-group-id="9717508410-5">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="9717508410-5">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="n">map</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#true</span><span class="w">

</span><span class="p" data-group-id="9717508410-6">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9717508410-7">%{</span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="9717508410-7">}</span><span class="p" data-group-id="9717508410-6">}</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="9717508410-8">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9717508410-9">%{</span><span class="p" data-group-id="9717508410-9">}</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9717508410-8">}</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="c1">#true</span></code></pre><p>当模式中列表, 元组与 map 混合在一起的时候, 模式提取操作符也可以使用:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="0889446922-1">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0889446922-2">{</span><span class="n">b</span><span class="p" data-group-id="0889446922-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0889446922-3">%{</span><span class="ss">e</span><span class="p">:</span><span class="w"> </span><span class="n">e</span><span class="p" data-group-id="0889446922-3">}</span><span class="p" data-group-id="0889446922-1">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="0889446922-4">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0889446922-5">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">:ok</span><span class="p" data-group-id="0889446922-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0889446922-6">%{</span><span class="ss">e</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">g</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="0889446922-6">}</span><span class="p" data-group-id="0889446922-4">]</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">#true</span></code></pre><p>但是当 <code class="inline">pattern</code> 的数据类型与 <code class="inline">value</code> 的数据类型不匹配的时候, 会发生错误.</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="6382169843-1">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="6382169843-1">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="6382169843-2">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="6382169843-2">}</span><span class="w"> </span><span class="c1"># raise error</span><span class="w">
</span><span class="p" data-group-id="6382169843-3">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6382169843-4">{</span><span class="n">b</span><span class="p" data-group-id="6382169843-4">}</span><span class="p" data-group-id="6382169843-3">]</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="p" data-group-id="6382169843-5">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="6382169843-5">]</span><span class="w"> </span><span class="c1"># raise error</span></code></pre><h2 id="模式匹配操作符" class="section-heading">
  <a href="#模式匹配操作符" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">模式匹配操作符</p>
  </a>
  模式匹配操作符 <code class="inline">=</code>
</h2>
<p>Elixir 中使用最频繁的操作符是匹配操作符 <code class="inline">=</code>. 它的工作逻辑如下:</p><p>最常见的情形下, 按照 <code class="inline">=</code> 左侧的模式, 从右边的数据中提取信息.
但是当左边变量前中出现  pin 操作符 <code class="inline">^</code> 的时候, <code class="inline">=</code> 只完成模式确认的工作:
模式匹配成功了, 返回模式匹配操作符 <code class="inline">=</code> 右侧表达式的值; 而如果模式匹配失败了抛出异常.</p><p>在 Erlang OTP 25 中引入了一个新特性 maybe, 其中可以使用新的短路操作符 <code class="inline">?=</code><a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a>,
叫做条件匹配操作符. 也许不久 Elixir 也会引入.
这个操作符实际上就是 <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a> 和模式匹配操作符 <code class="inline">=</code> 的混合体; 当模式匹配成功的时候,
完成变量的值绑定, 模式匹配失败, 返回 <code class="inline">?=</code> 左边的值.</p><p>可见操作符 <code class="inline">=</code> 和 <code class="inline">?=</code> 都是混合了模式匹配的两种用法.
他们之间的差异在于, 当模式匹配确认失败后如何处理控制流和操作符的返回值.</p><h2 id="逻辑短路与控制结构的分类" class="section-heading">
  <a href="#逻辑短路与控制结构的分类" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">逻辑短路与控制结构的分类</p>
  </a>
  逻辑短路与控制结构的分类
</h2>
<p>在执行逻辑操作的时候，有是否支持短路操作的问题,
比如逻辑操作 <code class="inline">and</code> 和 <code class="inline">or</code> 在 Eixir 和绝大多数的编程语言中,
都是短路操作: 逻辑操作符号 <code class="inline">and</code> 只有当左侧表达式的结果为 <code class="inline">ture</code> 的时候,
右边的表达式才会求值; 而操作符 <code class="inline">or</code> 只有当左边的表达式结果为 <code class="inline">false</code> 时,
才会对右边的表达式求值.</p><p>但不是并不是所有的编程语言都是这样的, Erlang 中就提供了全路的逻辑操作,
当然也有对应的短路操作符号.
Erlang 中的 <code class="inline">and</code> 和 <code class="inline">or</code> 对逻辑操作符执行全路操作, 也就是说,
在 Erlang 中 <code class="inline">and</code> 和 <code class="inline">or</code> 的两个操作数的值, 都会被计算一次;
而执行逻辑短路操作的是关键字 <code class="inline">and_also</code> <code class="inline">or_else</code>.
也就是说 Elixir 中的 <code class="inline">and</code> 和 <code class="inline">or</code> 对应的是 Erlang 的 <code class="inline">and_also</code> 和 <code class="inline">or_else</code>.
Elixir 中缺少全路的逻辑操作.</p><p>短路和全路操作, 对于逻辑结果来说是没有影响的, 有影响的只是副作用.</p><p>副作用的存在, 使得逻辑操作符可以用来充当控制结构. 这正是讨论逻辑操作短路与否的原因。
为了进一步的利用逻辑的短路操作做控制结构, Elixir 还提供了接受 <code class="inline">boolean_as</code> 类型的
操作符 <code class="inline">&amp;&amp;</code> 和 <code class="inline">||</code>.
C 语言的三目条件表达式 <code class="inline">cond ? true_part : false_part</code>,
在 Elixir 中既可以使用 <code class="inline">if cond,do: true_part, else: false_part</code>
又可以使用 <code class="inline">cond &amp;&amp; true_part || false_part</code> 来模拟.</p><p>如果存在多个匹配模式, 以什么样的逻辑来处理这些模式的确认结果呢?</p><p>Elixir 的控制结构中, 使用的都是 <code class="inline">or</code> 的逻辑,
也就是说按照顺序对每个模式一一做确认, 直到发现了确认的模式.
但是当所有的模式全部失败后, 如何处理, 又可以有不同. 就像 <code class="inline">=</code> 和 <code class="inline">?=</code> 的差别那样.
我把 <code class="inline">=</code> 的选择叫做悲观主义, 而 <code class="inline">?=</code> 的选择叫做乐观主义.
那么控制结构, 可以分成三类:</p><ol><li>悲观的</li><li>乐观</li><li>特殊</li></ol><h2 id="悲观控制结构" class="section-heading">
  <a href="#悲观控制结构" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">悲观控制结构</p>
  </a>
  悲观控制结构
</h2>
<p>Elixir 的大部分的控制结构都是悲观的: 即所有的模式匹配确认都失败后,
产生错误, 中断控制流. 悲观控制结构包括:</p><ul><li>函数分句</li><li><code class="inline">case</code></li><li><code class="inline">cond</code></li></ul><p>这些控制结构的大体的工作逻辑是这样的: 首先对模式做匹配, 如果不匹配, 接着匹配下一个模式,
如果所有的模式都不匹配, 类似于模式匹配操作符 <code class="inline">=</code> 匹配失败那样, 抛出一个错误;
而一旦匹配成功了, 还要完成数据提取的工作, 并执行对应的代码段.</p><h3 id="函数分句" class="section-heading">
  <a href="#函数分句" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数分句</p>
  </a>
  函数分句
</h3>
<p>函数的分句这种概念, 从编程的效果上看, 非常类似于 C++ 和 Java 中的函数和方法的重载.
重载和函数分局都完成了对代码的动态调度. 但是这里不只是术语的名称的不同,
函数重载和和函数分句之间的差别更多是世界观的差别.</p><p>函数的重载可以发生在很多地方, 不只是限制在同一个命名空间中,
而且每个函数实际上也被认为是独立, 可区分的单元,
是编译器为程序员做了根据输入参数的不同区分和正确加载调度对应函数的工作.</p><p>Elixir 中函数分句只能发生在同一模块中, 而且这些函数应该集中放在一起, 
不应该被其他代码分隔开来. 例如下面的代码, 我们故意在 <code class="inline">fib/2</code> 的两个分句之间,
定义了一个新的函数 <code class="inline">b</code>, 这样的代码编译器会给出警告.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">CauseDemod</span><span class="w"> </span><span class="k" data-group-id="5446853333-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fib</span><span class="p" data-group-id="5446853333-2">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">\\</span><span class="w"> </span><span class="p" data-group-id="5446853333-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5446853333-3">]</span><span class="p" data-group-id="5446853333-2">)</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fib</span><span class="p" data-group-id="5446853333-4">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5446853333-5">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="5446853333-5">]</span><span class="p" data-group-id="5446853333-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="5446853333-6">(</span><span class="p" data-group-id="5446853333-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fib</span><span class="p" data-group-id="5446853333-7">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5446853333-8">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="5446853333-8">]</span><span class="p" data-group-id="5446853333-7">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">fib</span><span class="p" data-group-id="5446853333-9">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5446853333-10">[</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="5446853333-10">]</span><span class="p" data-group-id="5446853333-9">)</span><span class="w">
</span><span class="k" data-group-id="5446853333-1">end</span></code></pre><p>从语法基因来说, Erlang 中函数分句, 语法上是不能分开写的.
上面的代码, 对应的 Erlang 版本是这样的:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">module</span><span class="p" data-group-id="2200477536-1">(</span><span class="ss">&#39;Elixir.CauseDemode&#39;</span><span class="p" data-group-id="2200477536-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="2200477536-2">(</span><span class="p" data-group-id="2200477536-3">[</span><span class="nc">fib</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nc">fib</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nc">b</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="2200477536-3">]</span><span class="p" data-group-id="2200477536-2">)</span><span class="p">.</span><span class="w">

</span><span class="nf">fib</span><span class="p" data-group-id="2200477536-4">(</span><span class="mi">0</span><span class="p">,</span><span class="p" data-group-id="2200477536-5">[</span><span class="ss">a</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="2200477536-5">]</span><span class="p" data-group-id="2200477536-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p">;</span><span class="w">
</span><span class="nf">fib</span><span class="p" data-group-id="2200477536-6">(</span><span class="ss">n</span><span class="p">,</span><span class="p" data-group-id="2200477536-7">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2200477536-7">]</span><span class="p" data-group-id="2200477536-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">fin</span><span class="p" data-group-id="2200477536-8">(</span><span class="ss">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2200477536-9">[</span><span class="ss">a</span><span class="o">+</span><span class="ss">b</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="2200477536-9">]</span><span class="p" data-group-id="2200477536-8">)</span><span class="p">.</span><span class="w">

</span><span class="nf">fib</span><span class="p" data-group-id="2200477536-10">(</span><span class="ss">n</span><span class="p" data-group-id="2200477536-10">)</span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">fib</span><span class="p" data-group-id="2200477536-11">(</span><span class="ss">n</span><span class="p">,</span><span class="p" data-group-id="2200477536-12">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2200477536-12">]</span><span class="p" data-group-id="2200477536-11">)</span><span class="p">.</span><span class="w">

</span><span class="nf">b</span><span class="p" data-group-id="2200477536-13">(</span><span class="p" data-group-id="2200477536-13">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">nil</span><span class="p">.</span></code></pre><p>Erlang 中, <code class="inline">.</code> 是语句结束的标志, 所以 Erlang 中是没有办法把函数分句拆散的.
但是 Erlang 中不允许, 不代表 Elixir 中不可以,
Elixir 对 Erlang 的语法改进是相当大的,
所以这里所以要给出警告, 绝对不只是为了与 Erlang 语法对应的问题.
而且编译器给出的是警告不是错误, 这本上就说明, 这不是技术实现上的问题.
那么警告的原因是什么呢?</p><p>这个要求首先是对函数分句概念呼应. 其次把相关代码紧凑的放在一起, 也使得代码更容易维护.</p><p>编程的过程中, 当需要重构代码的时候, 我往往就是在需要重构的代码的前面和后面,
开始自己的函数提取. 这样, 不自觉地又减低了代码的可维护性.</p><p>对外的接口代码, 其上下文是抽象层级较高的概念; 而重构抽取的代码, 往往是底层细节的内容.
如果代码的布局上高层和低层的概念交叉在一起, 对于代码的阅读者来说,
其理解的负担无疑是加重的.</p><p>所以把函数分句放在一起, 这样的代码布局, 的确是应该提倡的.</p><p>如果函数的一个分句处理的任务还是非常的复杂, 需要把其中的代码提取为单独的函数,
怎么处理呢?</p><p>如果把函数分句调用的帮助函数, 统统放在整个函数定义的后面或前面,
当有多个这样的帮助函数的时候, 函数之间的依赖关系就不是那么清晰了.</p><p>社区给出的推荐做法是这样的:
保持函数的对外接口不变, 在处理特殊情形的分句中调用一个为这个特殊情况而写一个独立的函数.
这个独立函数, 放在所有的对外接口函数的后面. 然后重构这个独立函数,
并把重构提取的代码放在独立函数的后面. 这样, 从概念在代码中的布局上来看,
总是高层次的概念先于底层概念, 而相关的概念又都保持在相邻的区域内.</p><p>例如 Phoenix LiveView 中, 事件的处理的代码, 就可以这样来写:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">handler_event</span><span class="p" data-group-id="1255799743-1">(</span><span class="sc">&#39;button1_click&#39;</span><span class="p">,</span><span class="c">_value</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span><span class="p" data-group-id="1255799743-1">)</span><span class="p">,</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handler_event</span><span class="p" data-group-id="1255799743-2">(</span><span class="sc">&#39;update_file&#39;</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">stack</span><span class="p" data-group-id="1255799743-2">)</span><span class="p">,</span><span class="w"> 
      </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">handle_update_file</span><span class="p" data-group-id="1255799743-3">(</span><span class="n">value</span><span class="p">,</span><span class="n">stack</span><span class="p" data-group-id="1255799743-3">)</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handler_event</span><span class="p" data-group-id="1255799743-4">(</span><span class="sc">&#39;enven_name&#39;</span><span class="p">,</span><span class="w"> </span><span class="c">_value</span><span class="p">,</span><span class="n">stack</span><span class="p" data-group-id="1255799743-4">)</span><span class="p">,</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="w">


</span><span class="kd">defp</span><span class="w"> </span><span class="nf">handle_update_file</span><span class="p" data-group-id="1255799743-5">(</span><span class="n">value</span><span class="p">,</span><span class="n">stack</span><span class="p" data-group-id="1255799743-5">)</span><span class="w"> </span><span class="k" data-group-id="1255799743-6">do</span><span class="w">
  </span><span class="p" data-group-id="1255799743-7">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p" data-group-id="1255799743-7">]</span><span class="o">=</span><span class="n">extract</span><span class="p" data-group-id="1255799743-8">(</span><span class="n">value</span><span class="p" data-group-id="1255799743-8">)</span><span class="w">
  </span><span class="n">work_with_v1_and_v2</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="1255799743-6">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">extrac</span><span class="p" data-group-id="1255799743-9">(</span><span class="n">value</span><span class="p" data-group-id="1255799743-9">)</span><span class="w"> </span><span class="k" data-group-id="1255799743-10">do</span><span class="w">
   </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="1255799743-10">end</span></code></pre><h3 id="case-与-cond" class="section-heading">
  <a href="#case-与-cond" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">case-与-cond</p>
  </a>
  Case 与 Cond
</h3>
<p>在刚开始学习的时候, 遇到需要使用 <code class="inline">case</code> 或 <code class="inline">cond</code> 的时候,
我往往犹豫应该使用那一个, 因为我觉得这两个都对应 C 语言的
<code class="inline">swith</code> 语句.</p><p>现在我认为, <code class="inline">case</code> 语句才对应 C 家族的 <code class="inline">switch</code>.
<code class="inline">cond</code> 更加像 C 家族的 <code class="inline">if-else-if</code> 链.</p><p>例如, 下面的 Javascript 代码:</p><pre><code class="makeup js" translate="no"><span class="kd">function</span><span class="w"> </span><span class="nf">score_range</span><span class="p" data-group-id="3735507010-1">(</span><span class="n">leave</span><span class="p" data-group-id="3735507010-1">)</span><span class="p" data-group-id="3735507010-2">{</span><span class="w">
  </span><span class="kr">switch</span><span class="p" data-group-id="3735507010-3">(</span><span class="n">leave</span><span class="p" data-group-id="3735507010-3">)</span><span class="p" data-group-id="3735507010-4">{</span><span class="w">
    </span><span class="kr">case</span><span class="w"> </span><span class="ss">&quot;F&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-5">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">59</span><span class="p" data-group-id="3735507010-5">]</span><span class="p">;</span><span class="w">
     </span><span class="kr">case</span><span class="w"> </span><span class="ss">&quot;E&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-6">[</span><span class="mi">60</span><span class="p">,</span><span class="mi">65</span><span class="p" data-group-id="3735507010-6">]</span><span class="p">;</span><span class="w">
     </span><span class="kr">case</span><span class="w"> </span><span class="ss">&quot;D&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-7">[</span><span class="mi">66</span><span class="p">,</span><span class="mi">74</span><span class="p" data-group-id="3735507010-7">]</span><span class="p">;</span><span class="w">
     </span><span class="n">Case</span><span class="w"> </span><span class="ss">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-8">[</span><span class="mi">75</span><span class="p">,</span><span class="mi">79</span><span class="p" data-group-id="3735507010-8">]</span><span class="p">;</span><span class="w">
     </span><span class="kr">case</span><span class="w"> </span><span class="ss">&quot;B&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-9">[</span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p" data-group-id="3735507010-9">]</span><span class="p">;</span><span class="w">
     </span><span class="kr">case</span><span class="w"> </span><span class="ss">&quot;A&quot;</span><span class="p">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-10">[</span><span class="mi">86</span><span class="p">,</span><span class="w"> </span><span class="mi">89</span><span class="p" data-group-id="3735507010-10">]</span><span class="p">;</span><span class="w">
     </span><span class="kr">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="p" data-group-id="3735507010-11">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">100</span><span class="p" data-group-id="3735507010-11">]</span><span class="w">
   </span><span class="p" data-group-id="3735507010-4">}</span><span class="w">
</span><span class="p" data-group-id="3735507010-2">}</span></code></pre><p>对应的 Elixir 代码应该为:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">score_range</span><span class="p" data-group-id="3596470288-1">(</span><span class="n">leave</span><span class="p" data-group-id="3596470288-1">)</span><span class="w"> </span><span class="k" data-group-id="3596470288-2">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="n">leave</span><span class="w"> </span><span class="k" data-group-id="3596470288-3">do</span><span class="w">
    </span><span class="s">&quot;F&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-4">[</span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">59</span><span class="p" data-group-id="3596470288-4">]</span><span class="p">;</span><span class="w">
    </span><span class="s">&quot;E&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-5">[</span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p" data-group-id="3596470288-5">]</span><span class="p">;</span><span class="w">
    </span><span class="s">&quot;D&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-6">[</span><span class="mi">66</span><span class="p">,</span><span class="w"> </span><span class="mi">74</span><span class="p" data-group-id="3596470288-6">]</span><span class="p">;</span><span class="w">
    </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-7">[</span><span class="mi">75</span><span class="p">,</span><span class="w"> </span><span class="mi">79</span><span class="p" data-group-id="3596470288-7">]</span><span class="p">;</span><span class="w">
    </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-8">[</span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p" data-group-id="3596470288-8">]</span><span class="p">;</span><span class="w">
    </span><span class="s">&quot;A&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-9">[</span><span class="mi">86</span><span class="p">,</span><span class="w"> </span><span class="mi">89</span><span class="p" data-group-id="3596470288-9">]</span><span class="p">;</span><span class="w">
    </span><span class="c1">#&quot;A+&quot;</span><span class="w">
    </span><span class="c">_v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3596470288-10">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">100</span><span class="p" data-group-id="3596470288-10">]</span><span class="w">
  </span><span class="k" data-group-id="3596470288-3">end</span><span class="w">
</span><span class="k" data-group-id="3596470288-2">end</span></code></pre><p>C 语言家族中的 <code class="inline">switch</code> 和 Elixir 中的 <code class="inline">case</code> 几乎是逐句对应的.
下面看看 if-else-if 链的代码:</p><pre><code class="makeup js" translate="no"><span class="kd">function</span><span class="w"> </span><span class="nf">leave</span><span class="p" data-group-id="4464543182-1">(</span><span class="n">score</span><span class="p" data-group-id="4464543182-1">)</span><span class="p" data-group-id="4464543182-2">{</span><span class="w">
  </span><span class="kr">if</span><span class="p" data-group-id="4464543182-3">(</span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">60</span><span class="p" data-group-id="4464543182-3">)</span><span class="w">  </span><span class="n">reurn</span><span class="w"> </span><span class="s">&quot;F&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="p" data-group-id="4464543182-4">(</span><span class="mi">60</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">65</span><span class="p" data-group-id="4464543182-4">)</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;E&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="p" data-group-id="4464543182-5">(</span><span class="mi">66</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">74</span><span class="p" data-group-id="4464543182-5">)</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="p" data-group-id="4464543182-6">(</span><span class="mi">75</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">80</span><span class="p" data-group-id="4464543182-6">)</span><span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="p" data-group-id="4464543182-7">(</span><span class="mi">80</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">85</span><span class="p" data-group-id="4464543182-7">)</span><span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="p" data-group-id="4464543182-8">(</span><span class="mi">86</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">90</span><span class="p" data-group-id="4464543182-8">)</span><span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="w">
   </span><span class="kr">else</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="s">&quot;A+&quot;</span><span class="w">
</span><span class="p" data-group-id="4464543182-2">}</span></code></pre><p>对应的 Elixir 应该是:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">leave</span><span class="p" data-group-id="8959113466-1">(</span><span class="n">score</span><span class="p" data-group-id="8959113466-1">)</span><span class="w"> </span><span class="k" data-group-id="8959113466-2">do</span><span class="w">
  </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="8959113466-3">do</span><span class="w">
    </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;F&quot;</span><span class="w">
    </span><span class="mi">60</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">65</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;E&quot;</span><span class="w">
    </span><span class="mi">66</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">74</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="w">
    </span><span class="mi">75</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w">
    </span><span class="mi">80</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">85</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w">
    </span><span class="mi">86</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="w">
    </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;A+&quot;</span><span class="w">
   </span><span class="k" data-group-id="8959113466-3">end</span><span class="w">
</span><span class="k" data-group-id="8959113466-2">end</span></code></pre><p>在 Elixir 中, <code class="inline">case</code> 和 <code class="inline">cond</code> 的互换,
要比 C 家族的 <code class="inline">switch</code> 和 <code class="inline">if-else-if</code> 语句的互换方便和容易的多.
这也是在 Elixir 中写多分支语句的时候, 我犹豫的原因之一.</p><p>心理分析学派发现, 找到心理创伤的根源, 往往就可以缓解创伤的症状, 甚至治愈.
实际上一切困惑和神秘的都源于我们还没有很好的理解它们,
如果能够亲手, 以已经了解和掌握的知识和材料, 重新创建不熟悉或神秘的事物,
那么就可以扫清这个思维和心理障碍. 这是我的一点经验体会.
所以, 让我来重新发明轮子, 看看如何用自己熟悉和习惯的概念来实现令我困惑的
<code class="inline">case</code> 和 <code class="inline">cond</code>.</p><p>观察 <code class="inline">case</code> 语句的语法, 我发现, 可以把 <code class="inline">case</code> 语句看作是
Elixir 的立即调用表达式 (IIFE) 的语法糖:
首先把 <code class="inline">case</code> 语句的 <code class="inline">do-block</code> 块, 使用 <code class="inline">fn</code> ... <code class="inline">end</code> 包裹起来,
就是一个合法的一元匿名函数的定义,
然后立即使用 <code class="inline">case</code> 的第一个参数来调用这个新创建的匿名函数.
这样就完成了 <code class="inline">case</code> 语句的工作.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Explore.Case</span><span class="w"> </span><span class="k" data-group-id="7808877328-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_case</span><span class="p" data-group-id="7808877328-2">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="7808877328-2">)</span><span class="w"> </span><span class="k" data-group-id="7808877328-3">do</span><span class="w">
    </span><span class="n">iife</span><span class="p" data-group-id="7808877328-4">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="7808877328-4">)</span><span class="w">
  </span><span class="k" data-group-id="7808877328-3">end</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">iife</span><span class="p" data-group-id="7808877328-5">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="7808877328-5">)</span><span class="w"> </span><span class="k" data-group-id="7808877328-6">do</span><span class="w">
    </span><span class="p" data-group-id="7808877328-7">{</span><span class="w">
      </span><span class="p" data-group-id="7808877328-8">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7808877328-9">[</span><span class="p" data-group-id="7808877328-9">]</span><span class="p">,</span><span class="w"> </span><span class="c1">#This is the `.` in `(fn...end).(v)`</span><span class="w">
       </span><span class="p" data-group-id="7808877328-10">[</span><span class="w">
         </span><span class="p" data-group-id="7808877328-11">{</span><span class="ss">:fn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7808877328-12">[</span><span class="p" data-group-id="7808877328-12">]</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="7808877328-11">}</span><span class="c1">#This is: `(fn...end)`</span><span class="w">
       </span><span class="p" data-group-id="7808877328-10">]</span><span class="p" data-group-id="7808877328-8">}</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="7808877328-13">[</span><span class="p" data-group-id="7808877328-13">]</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="7808877328-14">[</span><span class="n">v</span><span class="p" data-group-id="7808877328-14">]</span><span class="w"> </span><span class="c1">#This is `(v)` in `(fn...end).(v)`.</span><span class="w">
    </span><span class="p" data-group-id="7808877328-7">}</span><span class="w">
  </span><span class="k" data-group-id="7808877328-6">end</span><span class="w">
</span><span class="k" data-group-id="7808877328-1">end</span></code></pre><p>上面的代码中, 第 9 行创建了一元匿名函数, 整个 iife 函数, 在完成匿名函数的创建后,
立即以 <code class="inline">v</code> 为参数调用了这个匿名函数.
测试一下我们.</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">Explore.Case</span><span class="w">
</span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="0350495191-1">fn</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="n">my_case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k" data-group-id="0350495191-2">do</span><span class="w">
    </span><span class="s">&quot;A+&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-3">[</span><span class="mi">90</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p" data-group-id="0350495191-3">]</span><span class="w">
    </span><span class="s">&quot;A&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-4">[</span><span class="mi">86</span><span class="p">,</span><span class="w"> </span><span class="mi">89</span><span class="p" data-group-id="0350495191-4">]</span><span class="w">
    </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-5">[</span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p" data-group-id="0350495191-5">]</span><span class="w">
    </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-6">[</span><span class="mi">70</span><span class="p">,</span><span class="w"> </span><span class="mi">79</span><span class="p" data-group-id="0350495191-6">]</span><span class="w">
    </span><span class="s">&quot;E&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-7">[</span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="mi">79</span><span class="p" data-group-id="0350495191-7">]</span><span class="w">
    </span><span class="s">&quot;F&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0350495191-8">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">60</span><span class="p" data-group-id="0350495191-8">]</span><span class="w">
  </span><span class="k" data-group-id="0350495191-2">end</span><span class="w">
</span><span class="k" data-group-id="0350495191-1">end</span><span class="w">
</span><span class="p" data-group-id="0350495191-9">[</span><span class="mi">90</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p" data-group-id="0350495191-9">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="0350495191-10">(</span><span class="s">&quot;A+&quot;</span><span class="p" data-group-id="0350495191-10">)</span><span class="w">
</span><span class="p" data-group-id="0350495191-11">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">60</span><span class="p" data-group-id="0350495191-11">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="0350495191-12">(</span><span class="s">&quot;F&quot;</span><span class="p" data-group-id="0350495191-12">)</span><span class="w">
</span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="0350495191-13">(</span><span class="s">&quot;FFF&quot;</span><span class="p" data-group-id="0350495191-13">)</span><span class="w"> </span><span class="c1"># (FunctionClauseError) no function clause matches</span></code></pre><p>像上面我们分析的那样, <code class="inline">cond</code> 的语句可以转化为 <code class="inline">if-else-if</code> 语句链.
<code class="inline">cond</code> 的 <code class="inline">do-end</code> 块中, 应该是一个或多个 <code class="inline">a -&gt; ...</code> 分句.
所以, 我们首先检查我们的 <code class="inline">my_cond</code> 输入中是否不和这样的解构, 如果不是这样的解构,
那么就不是合法的 <code class="inline">cond</code> 语句, 这时给出错误提示就好了.
在上面的对 <code class="inline">case</code> 语句的模拟中, 为什么不做检查呢?
因为当传递给 <code class="inline">my_case</code> 的 <code class="inline">do-end</code> 块不是合法的 <code class="inline">case</code> 的 <code class="inline">do-end</code> 块时,
<code class="inline">fn</code> 特殊表达会给出合适的错误提示. 但是, 这里, 我们要把 <code class="inline">do-end</code> 块自己完成转化,
所以必须提前检查是否语法正确.</p><p>要把多个的 <code class="inline">left -&gt; right</code> 语句, 转化:</p><pre><code class="makeup elixir" translate="no"><span class="k">if</span><span class="w"> </span><span class="n">left1</span><span class="w"> </span><span class="k" data-group-id="4247371875-1">do</span><span class="w"> 
  </span><span class="n">right1</span><span class="w">
</span><span class="k" data-group-id="4247371875-1">else</span><span class="w"> 
  </span><span class="k">if</span><span class="w"> </span><span class="n">left2</span><span class="w"> </span><span class="k" data-group-id="4247371875-2">do</span><span class="w"> 
    </span><span class="n">right2</span><span class="w">
  </span><span class="k" data-group-id="4247371875-2">else</span><span class="w"> 
    </span><span class="c1">#...</span><span class="w">
  </span><span class="k" data-group-id="4247371875-2">end</span><span class="w">
</span><span class="k" data-group-id="4247371875-1">end</span></code></pre><p>我们从最内层开始构造, 当所有的 <code class="inline">case</code> 分支都失败后, 会抛出错误, 所以最后一个 <code class="inline">if</code> 的
<code class="inline">else</code> 分句应该抛出一个错误. 这由 <code class="inline">make_last_else_part/0</code> 函数完成.
然后我们需要把所有的 <code class="inline">condtione -&gt; right</code> 都转化成 <code class="inline">if condtione do: right, else: ...</code>.
这个工作由 <code class="inline">make_if_else/2</code> 完成.
我们从最后一个 <code class="inline">condtione -&gt; right</code> 开始转化, 它的结果作为上一个
<code class="inline">condtione -&gt; right</code> 的 <code class="inline">else</code> 部分. 所以在 <code class="inline">my_cond</code> 中我们首先对
<code class="inline">condtione -&gt; right</code> 列表做了反序排序.
然后使用 <a href="https://hexdocs.pm/elixir/Enum.html#reduce/2"><code class="inline">Enum.reduce/2</code></a> 完成最后的构造.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Explore.Cond</span><span class="w"> </span><span class="k" data-group-id="0594715768-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_cond</span><span class="p" data-group-id="0594715768-2">(</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="0594715768-2">)</span><span class="w"> </span><span class="k" data-group-id="0594715768-3">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">all?</span><span class="p" data-group-id="0594715768-4">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">check_syntax</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="0594715768-4">)</span><span class="w"> </span><span class="k" data-group-id="0594715768-5">do</span><span class="w">
      </span><span class="n">block</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0594715768-6">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p" data-group-id="0594715768-7">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="0594715768-7">)</span><span class="p" data-group-id="0594715768-6">)</span><span class="w"> </span><span class="c1"># get `[left,right] from `left -&gt; right`. </span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reverse</span><span class="p" data-group-id="0594715768-8">(</span><span class="p" data-group-id="0594715768-8">)</span><span class="w"> </span><span class="c1">#make if-else-if chain more easy</span><span class="w">
      </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="0594715768-9">(</span><span class="n">make_last_else_part</span><span class="p" data-group-id="0594715768-10">(</span><span class="p" data-group-id="0594715768-10">)</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">make_if_else</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="0594715768-9">)</span><span class="w">
    </span><span class="k" data-group-id="0594715768-5">else</span><span class="w">
      </span><span class="p" data-group-id="0594715768-11">{</span><span class="ss">:cond</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0594715768-12">[</span><span class="p" data-group-id="0594715768-12">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0594715768-13">[</span><span class="p" data-group-id="0594715768-14">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">block</span><span class="p" data-group-id="0594715768-14">]</span><span class="p" data-group-id="0594715768-13">]</span><span class="p" data-group-id="0594715768-11">}</span><span class="w">
    </span><span class="k" data-group-id="0594715768-5">end</span><span class="w">
  </span><span class="k" data-group-id="0594715768-3">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">check_syntax</span><span class="p" data-group-id="0594715768-15">(</span><span class="p" data-group-id="0594715768-16">{</span><span class="ss">:-&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p" data-group-id="0594715768-16">}</span><span class="p" data-group-id="0594715768-15">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_list</span><span class="p" data-group-id="0594715768-17">(</span><span class="n">v</span><span class="p" data-group-id="0594715768-17">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">check_syntax</span><span class="p" data-group-id="0594715768-18">(</span><span class="bp">_</span><span class="p" data-group-id="0594715768-18">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_if_else</span><span class="p" data-group-id="0594715768-19">(</span><span class="p" data-group-id="0594715768-20">[</span><span class="p" data-group-id="0594715768-21">[</span><span class="n">condtion</span><span class="p" data-group-id="0594715768-21">]</span><span class="p">,</span><span class="w"> </span><span class="n">then</span><span class="p" data-group-id="0594715768-20">]</span><span class="p">,</span><span class="w"> </span><span class="n">else_part</span><span class="p" data-group-id="0594715768-19">)</span><span class="w"> </span><span class="k" data-group-id="0594715768-22">do</span><span class="w">
    </span><span class="p" data-group-id="0594715768-23">{</span><span class="w">
      </span><span class="ss">:if</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="0594715768-24">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="0594715768-24">]</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="0594715768-25">[</span><span class="n">condtion</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0594715768-26">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">then</span><span class="p">,</span><span class="w"> </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="n">else_part</span><span class="p" data-group-id="0594715768-26">]</span><span class="p" data-group-id="0594715768-25">]</span><span class="w">
    </span><span class="p" data-group-id="0594715768-23">}</span><span class="w">
  </span><span class="k" data-group-id="0594715768-22">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">make_last_else_part</span><span class="p" data-group-id="0594715768-27">(</span><span class="p" data-group-id="0594715768-27">)</span><span class="w"> </span><span class="k" data-group-id="0594715768-28">do</span><span class="w">
    </span><span class="p" data-group-id="0594715768-29">{</span><span class="w">
      </span><span class="ss">:raise</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="0594715768-30">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="0594715768-30">]</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="0594715768-31">[</span><span class="s">&quot;Can not find the true pattern&quot;</span><span class="p" data-group-id="0594715768-31">]</span><span class="w">
    </span><span class="p" data-group-id="0594715768-29">}</span><span class="w">
  </span><span class="k" data-group-id="0594715768-28">end</span><span class="w">
</span><span class="k" data-group-id="0594715768-1">end</span></code></pre><p>测试一下:</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">Explore.Cond</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w">

</span><span class="n">my_cond</span><span class="w"> </span><span class="k" data-group-id="2612502403-1">do</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;less than 6&quot;</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;eq 7&quot;</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;greate than 7&quot;</span><span class="w">
</span><span class="k" data-group-id="2612502403-1">end</span><span class="w">
</span><span class="c1"># eq 7</span></code></pre><h2 id="乐观控制结构" class="section-heading">
  <a href="#乐观控制结构" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">乐观控制结构</p>
  </a>
  乐观控制结构
</h2>
<ul><li>Elixir 的 <code class="inline">with</code></li><li>Erlang 中的 <code class="inline">maybe</code></li></ul><p>他们特殊的地方在于, 当模式匹配出错的时候, 这些结构中, 有对应的控制结构,
来处理最后匹配失败的数据.</p><p>关于 <code class="inline">with</code> 和 <code class="inline">maybe</code> 的更详细的讨论,
见本书的第5章 ≪<a href="ch05-new_constructor.html">定制新结构</a>≫.</p><h2 id="异常处理中的模式匹配" class="section-heading">
  <a href="#异常处理中的模式匹配" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">异常处理中的模式匹配</p>
  </a>
  异常处理中的模式匹配
</h2>
<p>异常处理中的模式匹配的处理是特殊的.</p><ol><li><code class="inline">catch</code> 处理的是函数调用参数列表; 即使如此, 对 <code class="inline">:throw</code> 类型的错误, 还有语法糖加持.
参数列表这种语法形式, 只有在函数定义和 <code class="inline">catch</code> 的时候才是合法的,
其他地方都是不合法的语句, 所以这种模式匹配是非常独特的.</li><li><code class="inline">rescue</code> 子句中, 模式匹配时只匹配异常名字. 而且对于运行时错误,
还可以使用 <a href="https://hexdocs.pm/elixir/ErlangError.html"><code class="inline">ErlangError</code></a> 来统配的. 而如果要绑定错误对象就必须使用 guard 匹配;
当然了, 还是阉割过的 guard 匹配, 如果和 <code class="inline">case</code> 或函数定义是的 guard 子句比较的化.</li></ol><p>像下面的代码展示的那样, 他们都不是常规的模式匹配.</p><pre><code class="makeup elixir" translate="no"><span class="nc">EralngError</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">ArithmeticError</span><span class="w"> </span><span class="c1">#false</span><span class="w">
</span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7495750728-1">do</span><span class="w">
 </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="w">
</span><span class="k" data-group-id="7495750728-1">rescue</span><span class="w">
 </span><span class="nc">ErlangError</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;ErlangError can match ArithmeticError&quot;</span><span class="w">
</span><span class="k" data-group-id="7495750728-1">end</span><span class="w">
</span><span class="c1">#ErlangError can match ArithmeticError</span><span class="w">

</span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7495750728-2">do</span><span class="w">
  </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="w">
</span><span class="k" data-group-id="7495750728-2">rescue</span><span class="w">
 </span><span class="nc">ArithmeticError</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;ArithmeticError&quot;</span><span class="w">
</span><span class="k" data-group-id="7495750728-2">end</span><span class="w">
</span><span class="c1"># ArithmeticError</span><span class="w">

</span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7495750728-3">do</span><span class="w">
  </span><span class="k">throw</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="k" data-group-id="7495750728-3">catch</span><span class="w">
  </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w">
</span><span class="k" data-group-id="7495750728-3">end</span><span class="w">
</span><span class="c1"># 1</span><span class="w">
</span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7495750728-4">do</span><span class="w">
  </span><span class="k">throw</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="k" data-group-id="7495750728-4">catch</span><span class="w">
  </span><span class="ss">:thorw</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w">
</span><span class="k" data-group-id="7495750728-4">end</span><span class="w">
</span><span class="c1"># 1</span></code></pre><p>更多的内容见后面的<a href="ch08-error_handle.html">错误处理章节</a>.</p><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>见 <a href="https://www.erlang.org/doc/reference_manual/expressions.html#maybe">≪Erlang 参考手册•maybe≫ 章节</a></p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch02-plus_and_minus.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第二章 加和减
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch04-parenthese.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第四章 括号
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
