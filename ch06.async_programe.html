<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>异步编程 - 角落里的长生不老药</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 目录</a></li><li class="chapter-item expanded "><a href="ch01.intruction.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="ch02.plus_and_minus.html"><strong aria-hidden="true">3.</strong> 加和减</a></li><li class="chapter-item expanded "><a href="ch03.pattern_match.html"><strong aria-hidden="true">4.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="ch04.parenthese.html"><strong aria-hidden="true">5.</strong> 括号</a></li><li class="chapter-item expanded "><a href="ch05.new_constructor.html"><strong aria-hidden="true">6.</strong> 定制新结构</a></li><li class="chapter-item expanded "><a href="ch06.async_programe.html" class="active"><strong aria-hidden="true">7.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="ch07.pipe.html"><strong aria-hidden="true">8.</strong> 管道操作符</a></li><li class="chapter-item expanded "><a href="ch08.error_handle.html"><strong aria-hidden="true">9.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="ch09.module.html"><strong aria-hidden="true">10.</strong> 模块</a></li><li class="chapter-item expanded "><a href="ch10.protocol_and_behaviour.html"><strong aria-hidden="true">11.</strong> 协议与行为</a></li><li class="chapter-item expanded "><a href="ch11.macro.html"><strong aria-hidden="true">12.</strong> 如何理解宏</a></li><li class="chapter-item expanded "><a href="ch12.process.html"><strong aria-hidden="true">13.</strong> 进程</a></li><li class="chapter-item expanded "><a href="chx.cold_knowledge.html"><strong aria-hidden="true">14.</strong> 附录 冷知识</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">角落里的长生不老药</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="第六章-异步编程"><a class="header" href="#第六章-异步编程">第六章 异步编程</a></h1>
<p>OTP 平台的卖点之一是对并发的友好支持. 所以 Elixir 对异步的支持是天然的.
OTP 平台的并发模型就是很好的异步的例子. 其实在 Javascript 这样的单进程的语言中,
异步代码的执行背后同样是多线程/进程来完成的.
Javascript 中异步编程, 虽然引入了多线程/进程,
但是并不破坏 Javascript 的单进程编程模式.
Javascript 语言的成功, 我认为和单进程编程模式是非常有关系的.
这个模式极大的减轻了程序员的心智负担.</p>
<p>把 Javascript 中的异步编程的概念, 移植到 Elixir 中, 使得进程之间的交互变得透明,
在使用 Elixir 的时候, 也可以把注意力集中到业务逻辑, 而不是异步交互的细节,
这样不但可以提供生产效率, 也能增强代码的可维护和可理解性.</p>
<h2 id="承诺promise"><a class="header" href="#承诺promise">承诺(Promise)</a></h2>
<p>Elixir 对异步编程的支持由 <code>Task</code> 模块提供. 但是我很少使用它,
<code>Task</code> 不是一个代数结构类型 (Algebraic Structure Type)<sup class="footnote-reference"><a href="#ast">1</a></sup>, 因此无法完成链式操作.
Javascipt 中的 Promise 不一样, 它是一个代数结构类型, 可以完成链式操作.
使用 Promise, Javascript 社区成功的解决了回调地狱问题.
因此我希望首先能把这个类型引入到 Elixir 语言中.</p>
<div class="footnote-definition" id="ast"><sup class="footnote-definition-label">1</sup>
<p>代数结构类型是一个相对抽象的概念.
要理解这个概念, 首先必须理解代数结构这个数学概念.
按照我的理解, 代数结构是说, 当操作符 $f$ 作用到数据集 $S$ 上后,
得到的结果还在 $S$ 中, 这样如果把数据集合 $S$ 看作一个空间,
输出和输出在这个空间中就形成了一定的结构.
代数结构最重要的概念是闭合性, 运算的闭合性, 使得编程可以使用链式操作.
操作符在数据集上具有闭合性, 数学上讲, 操作符在数据集上形成了闭包.
编程中也有闭包的概念, 这两个概念使用的是同一个英文单词, 但是意义不一样.
举个例子, $+$ 与整数集合 $N$, 整数加上整数得到的结果还是整数,
操作的输入和输出具有封闭性. 而 $\div$ 与整数集合 $N$ 不具有封闭性,
因为整数除以整数不能保证得到的还是整数. 甚至 $\div$ 与实数集合 $R$ 也不能构成闭包,
因为 0 是不能作为被除数的. 具有运算封闭性, 在数学上就构成了类群.</p>
</div>
<p>我们将要定义的 Promise 模块, 对外提供的接口有 8 个函数, 其中 6 个来源于
Javascript 的 Promise API. 但是这里没有定义 <code>catch</code> 函数.
<code>catch</code> 在 Elixir 中是保留字, 不允许用作函数名, 因此这里用 <code>on_error</code> 来代替.</p>
<p>最后的 2 个函数: <code>of/1</code> 和 <code>map(promise,fun/1)</code> 是函子的通用函数.</p>
<ol>
<li><code>Promise</code> 构造函数 <code>Promise.new((resolve,reject)-&gt;any)</code></li>
<li><code>Promise</code> 特化的构造函数 <code>Promise.resolve(v)</code> 把 <code>v</code>
转化为已完成的<code>Promise</code> 结构.</li>
<li><code>Promise</code> 特化的构造函数 <code>Promise.reject(v)</code> 把 <code>v</code>
转化为已拒绝的 <code>Promise</code> 结构.</li>
<li><code>Promise</code> 的转化换函数 <code>Promise.then(promise,fun, error_hanlder\\nil)</code></li>
<li><code>Promise</code> 错误处理函数<code>Promise.on_error(promise,fun)</code></li>
<li><code>Promise</code> 解构函数 <code>await(promise)</code> 返回 <code>Promise</code> 中包含的类型</li>
<li>函子构造函数 <code>Promise.of({:resolved|:rejected,v})</code> 把任意类型的值 <code>v</code>
转化为一个 <code>Promise</code> 结构.</li>
<li>函子通用转化换函数 <code>Promise.map(promise,fun)</code></li>
</ol>
<p>我们首先来看看 <code>Promise</code> 的 API.</p>
<p><code>Promise</code> 对象有 5 个状态: 待执行(<code>:pending</code>), 已完成(<code>:resolved</code>),
已拒绝(<code>:rejected</code>) 和出错 (<code>:error</code>).</p>
<p>这一点和 Javascript 的 API 不一样. 所以要把 <code>:rejected</code> 拆分成两个状态,
是为了处理错误的方便. Javascript 的异步函数中, 是使用 <code>try...catch</code> 来处理错误的.
在 Elixir 社区, 很少使用 <code>try...catch</code>, 更常规的做法是用标签来标记返回结果.
所以, 这里我们细分了拒绝的状态. 在这里的分类中,
<code>:rejected</code> 通过 <code>Promise.rejecte/1</code>, <code>Promise.of(v, :rejected)</code>
或者动态创建 <code>Promise</code> 时调用 <code>rejecter/1</code> 创建的 <code>Promise</code>.
而错误指的是客户端代码运行过程中抛出错误.</p>
<p>当需要提取 Promise 的值的时候, 调用 <code>Promise.await</code> 函数.</p>
<p><code>Promise.await/1</code> 会等待 Promise 对象从待执行变为已执行的状态.
<code>Promise.await/1</code> 返回 <code>{tag, result}</code>.
<code>tag</code> 的可能值为 <code>:resolved</code>, <code>:rejected</code>, <code>:error</code>, <code>:stop</code>.
我们的 Promise 是用 <code>GenServer</code> 实现的, <code>:stop</code> 表示 <code>Promise</code> 服务已经终止.</p>
<h3 id="动态构造函数-newfun"><a class="header" href="#动态构造函数-newfun">动态构造函数 <code>new(fun)</code></a></h3>
<p><code>Promsie.new/1</code> 接受一个二元函数 <code>fun</code>, 返回一个待执行状态的 <code>Promise</code> 结构.</p>
<p><code>fun</code> 函数规范为: <code>(resolver,rejecter -&gt; any)</code>.
其中 <code>resolver</code>, <code>rejecter</code> 都是一元函数, 其调用后, 会改变 <code>Promise</code> 的状态.</p>
<p><code>fun</code> 的返回值会被丢弃, 但是如果 <code>fun</code> 抛出了异常, 那么 <code>Promise</code> 的状态将转化为
<strong>拒绝状态</strong>. 在 <code>fun</code> 中, 如果调用 <code>resolver/1</code> 或 <code>rejecter/1</code>, 之前, 没有出错,
那么 <code>Promise</code> 状态将转化为: <strong>完成</strong> 或 <strong>拒绝</strong>. <code>resolver/1</code> 或 <code>rejecter/1</code>
应该是 <code>fun</code> 执行的最后一个语句, 当其中一个执行后, <code>fun</code> 的后续代码都不会再被执行.</p>
<p><code>Promise.new/1</code> 调用 <code>GenServer.start/2</code> 启动 <code>Promise</code> 服务进程.
<code>GenServer.start/2</code> 会使用他的第二个参数来调用回调函数 <code>init/1</code>.</p>
<pre><code class="language-elixir">defmodule Corner.Promise do
  use GenServer
  @receive_time 60 * 1000
  def new(fun, receive_time \\ @receive_time) when is_function(fun, 2) do
    {:ok, pid} = GenServer.start(__MODULE__, [fun, self(), receive_time])
    %__MODULE__{pid: pid}
  end

  def init([fun, pid,receive_time]) do
    state = %{
      receive_time: receive_time,
      sender_ref: make_ref(),
      state: :pending,
      sender: pid,
      timer_ref: nil,
      result: nil
    }

    {:ok, state, {:continue, fun}}
  end
  #...
end
</code></pre>
<p>在初始化函数 <code>init/1</code> 中, 我们只初始化了状态, 但是还没有完成对函数 <code>fun</code> 的执行.
所以, 这里, 我们返回的时一个三元的元组.</p>
<p><code>GenSerrver</code> 接收到 <code>init/1</code> 返回的三元元组后, 会理解执行 <code>handle_continue</code> 回调.</p>
<pre><code class="language-elixir">def handle_continue(fun, %{state: :pending} = state) do
  %{sender_ref: sender_ref} = state
  
  run_and_handle_error(
    fn _ -&gt;
      fun.(&amp;resolver(sender_ref, &amp;1), &amp;rejecter(sender_ref, &amp;1))
      throw({sender_ref, :stop})
    end,
    state
  )
end
</code></pre>
<p><code>run_and_handle_error/2</code> 执行函数, 捕获错误, 并改变服务进程的状态, 此外,
这个函数还对潜在的内厝泄露问题做了防护.</p>
<p>当客户端疏忽, 创建一个 <code>Promise</code> 后从来左右在通过 <code>await/1</code> 取回结果,
<code>Promise</code> 对应的服务进程就会永远运行在系统中. 为了避免这种情况,
当 <code>Promise</code> 处于完成状态之后, 一定时间内, 客户端不发送继续处理的请求,
也不取回结果, 系统将会自动终结, 以完成垃圾回收的工作. 这里默认的时间
由 <code>@receive_time</code> 提供, 当前为 1 分钟.
可以为 <code>Promise.new/2</code> 提供第二个参数来调整这个值.</p>
<p>当接受到 <code>:run</code> 消息后, 取消接受记时. 执行函数 <code>fun</code>. 执行结束后, 重新开始计时.</p>
<pre><code class="language-elixir">defp run_and_handle_error(fun, %{state: tag, result: result} = state) do
  if state.timer_ref, do: :timer.cancel(state.timer_ref)
  try do
    if tag == :error, do: fun.({tag, result}), else: fun.(result)
  catch
    kind, error -&gt; catch_error(kind, error, __STACKTRACE__, state)
  else
    v -&gt;
      message = {:timeout, state.sender_ref}
      timer_ref = Process.send_after(self(), message, state.receive_time)
      %{state | timer_ref: timer_ref, state: :resolved, result: v}
      |&gt; noreply()
  end
end
</code></pre>
<p><code>catch_error/4</code> 用来处理所有的异常情况.</p>
<pre><code class="language-elixir">defp catch_error(:throw, {ref, :stop}, _, %{sender_ref: ref} = state) do
  send(state.sender, {:result, {:stop, :done}})
  Process.exit(self(), :kill)
end
defp catch_error(:throw, {ref, tag, result}, _, %{sender_ref: ref} = state) do
  message = {:timeout, ref}
  timer_ref = Process.send_after(self(), message, state.receive_time)
  %{state | timer_ref: timer_ref, state: tag, result: result}
  |&gt; noreply()
end
defp catch_error(tab, error, stacktrace, %{sender_ref: ref} = state)
     when tab in [:error, :throw] do
  message = {:timeout, ref}
  timer_ref = Process.send_after(self(), message, state.receive_time)
  result = {error, stacktrace}
  %{state | timer_ref: timer_ref, state: :error, result: result}
  |&gt; noreply()
end
</code></pre>
<p>前两个分句捕获的是 <code>Promise</code> 服务进程内部抛出的消息.
第三个分句捕获客户端提供的函数 <code>fun</code> 运行过程中产生的错误.
如果 <code>fun</code> 函数中既没有调用 <code>resolver/1</code> 也没有调用 <code>rejecter/1</code>, 而且没有产生错误,
那么 <code>Promise</code> 服务进程就是抛出 <code>{ref, :stop}</code>, 这样第一个分句就会执行.
结果就是像客户端发送 <code>{:result, {:stop, :done}}</code> 信息后, 立刻终止运行了.</p>
<p>而当 <code>fun</code> 函数中有调用 <code>reserver/1</code> 或 <code>rejecter/1</code> 的时候, 第二个分句会执行.
重新开始了客户端接受计时, 并更新了 <code>Promise</code> 服务器进程的其他状态信息.</p>
<h3 id="数据构造函数"><a class="header" href="#数据构造函数">数据构造函数</a></h3>
<p><code>Promise.of(v,tag\\:resolved)</code>, <code>Promise.resolve(v)</code> 和 <code>Promise.reject(v)</code>
是三个数据构造函数. 用来把 <code>v</code> 置于 <code>Promise</code> 结构内.
<code>Promise.resolve(v)</code> 是 <code>Promise.of(v)</code> 的代理;
<code>Promise.rejcet(v)</code> 与 <code>Promise.of(v, :rejected)</code> 效果一样.</p>
<p>这些构造函数和 <code>new/1</code> 的最大差别在于, 这些函数构造的 <code>Promise</code> 服务绝对不会出现死锁,
使用 <code>Promise.new(fun)</code> 构造 <code>Promise</code> 服务的时候, 如果在 <code>fun</code> 既没有调用
<code>resolver/1</code>, 也没有 <code>rejectoer/1</code>, 且没有引发异常的化, <code>Promise</code> 进程就会死锁.</p>
<pre><code class="language-elixir">def of(v, tag \\ :resolved) do
  new(fn resolver, rejecter -&gt;
    if tag == :resolved do
      resolver.(v)
    else
      rejecter.(v)
    end
  end)
end

def resolve(v) do
  of(v)
end

def reject(v) do
  of(v, :rejected)
end
</code></pre>
<h3 id="数据转化函数"><a class="header" href="#数据转化函数">数据转化函数</a></h3>
<p><code>map/1</code>, <code>then/1-2</code> 和 <code>on_error/1</code> 是三个函数转化函数.</p>
<p>其中 <code>then/1-2</code> 和 <code>on_error/1</code> 与 Javascript 的 Promise API
向对应的.<sup class="footnote-reference"><a href="#js_promise">2</a></sup>. <code>then/1</code> 只处理 <strong>:resolved</strong> 状态的 Promise,
<code>then/2</code> 接受两个转化函数, 第一个处理 <strong>:resolved</strong> 状态的,
第二个处理 <strong>:rejected, :error</strong> 状态的.
<code>on_error/1</code> 只处理 <strong>:rejected</strong> 和 <strong>:promise</strong> 状态的的 Promise.</p>
<div class="footnote-definition" id="js_promise"><sup class="footnote-definition-label">2</sup>
<p>见 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise 参考页面</a></p>
</div>
<p><code>map</code> 是为了配合 Elixir 的函数子句而提供的 API. 也就是说,
无论 <code>Promise</code> 的状态是什么, 都统一有一个函数来处理.</p>
<p>对于 <code>:resolved</code> 和 <code>:rejected</code> 状态的 <code>Promise</code>, <code>map</code> 的处理函数 <code>fun</code>,
接受到的数据就是 Promise 中的数据. 当 <code>Promise</code> 的状态是 <code>:error</code> 的时候,
<code>map</code> 的处理函数接受到的是 <code>{:error, {v,[stack]}}</code>.</p>
<p><code>map/1</code>, <code>then/1-2</code> 和 <code>on_error/1</code> 做的工作是类似的, 分成三个函数,
只是为了客户端调用的方便. 它们只是向 <code>Promise</code> 服务进程发送异步的 
<code>{:run,fun1,fun2}</code> 消息.</p>
<p>在本章的开头, 我抱怨 <code>Task</code> 模块不是一个代数结构, 并许诺为 Elixir 种引入 <code>Promise</code>.
<code>Promise</code> 是代数结构. 代数结构的关键就是, 数据转化后已经形成对应的结构.
对 <code>Promise</code> 来说, 就是要求所有的转化函数, 必须也返回 <code>Promise</code> 结构.
如此, 才能完成链式调用. 这就是什么, 在 <code>async_send_run/3</code> 的最后返回 <code>Promise</code>
结构的原因.</p>
<pre><code class="language-elixir">def then(promise, fun1, fun2 \\ nil)
def then(%__MODULE__{} = this, fun1, fun2)
    when is_function(fun1, 1) and
           (fun2 == nil or is_function(fun2, 1)) do
  async_send_run(this, fun1, fun2)
end

def map(%__MODULE__{} = this, fun) when is_function(fun, 1) do
  async_send_run(this, fun, fun)
end

def on_error(%__MODULE__{} = this, fun) when is_function(fun, 1) do
  async_send_run(this, nil, fun)
end

defp async_send_run(%__MODULE__{pid: pid} = m, fun1, fun2) do
  if is_pid(pid) and Process.alive?(pid) do
    GenServer.cast(pid, {:run, fun1, fun2})
    m
  else
    %{m | state: :stop}
  end
end
</code></pre>
<p>异步消息 <code>{:run, fun1,fun2}</code> 的处理函数如下:</p>
<pre><code class="language-elixir">def handle_cast({:run, fun, _}, %{state: :resolved} = state)
    when is_function(fun, 1) do
  run_and_handle_error(fun, state)
end

# reject happend but no error_hanlder
def handle_cast({:run, _fun, nil}, %{state: tag} = state)
    # _fun is not nil
    when tag != :resolved do
  noreply(state)
end

# resolved happend but just error_hanler
def handle_cast({:run, nil, _fun}, %{state: :resolved} = state) do
  noreply(state)
end

def handle_cast({:run, _fun, fun}, %{state: tag} = state)
    when tag != :resolved do
  run_and_handle_error(fun, state)
end
</code></pre>
<p>第一个分句是 <code>:resolved</code> 状态时, <code>fun</code> 转化数据的情形.
第二个分句是 <code>:rejected</code> 状态, 但是并没有提供错误处理函数的情形.
第三个分句是 <code>:res;pved</code> 状态, 但是没有提供数据转化函数的情形.
第四个分句是错误状态的, 使用 <code>fun</code> 处理错误处理状态的情形.</p>
<h3 id="await"><a class="header" href="#await">await</a></h3>
<p><code>Promise.await/1</code> 函数用来提取 <code>Promise</code> 中记录的值.
本质来说, <code>await/1</code> 是客户端向 <code>Promise</code> 服务进程发送同步请求: <code>{:await, pid}</code>.
但是当 <code>Promise</code> 服务进程已经死掉了, 那么这个函数会返回会返回 <code>{:stop, :done}</code>.</p>
<pre><code class="language-elixir">def await(%{} = this) do
  if Process.alive?(this.pid) do
    send(this.pid, {:await, self()})
    receive do
      {:result, message} -&gt; message
    after
      :infinity -&gt; {:stop, :bad}
    end
  else
    {:stop, :done}
  end
end
</code></pre>
<h3 id="最后的提示"><a class="header" href="#最后的提示">最后的提示</a></h3>
<p>最后要注意的是, 这里全部都是函数, 没有宏, 所以<strong>不要使用 <code>import</code> 语句</strong>,
如果使用 import 导入全部函数, 那么会引发 <code>Promise.then/1</code> 与 <code>Kernel.then/2</code>
的命名冲突.</p>
<h2 id="流stream"><a class="header" href="#流stream">流(Stream)</a></h2>
<p>Generater 是 ES6 中引入的新的语法, 让我们可以通过 <code>function*</code> 来创建产生子.
有了这个语法, 在 Javascript 中, 我们就可以产生无限数量的序列了.</p>
<p>Elixir 标准库中, 提供了 <code>Stream</code> 模块.
任意的在枚举过程中, 一个接一个产生的可枚举数据类型, 都可以叫做 <code>Stream</code><sup class="footnote-reference"><a href="#stream">3</a></sup>.
虽说 Stream 模块提供<strong>组合</strong>和<strong>创建</strong> <code>Stream</code> 的函数.
但是从函数的数量上来说, 这个库中提供的, 创建 <code>Stream</code> 的函数只有 3 个,
堪堪占据全部函数的十分之一左右.</p>
<div class="footnote-definition" id="stream"><sup class="footnote-definition-label">3</sup>
<p>见 <a href="elixir/1.13.0/Stream.html">Stream 模块文档</a></p>
</div>
<p>对于无限序列, <code>Stream</code> 模块提供的 API 非常方便.
比如让我们产生一个斐波那契数列的 <code>Stream</code>:</p>
<pre><code class="language-elixir">Stream.unfold({1, 1}, fn {a, b} -&gt; {a, {b, a + b}} end)
|&gt; Stream.take(10)
|&gt; Enum.to_list()
</code></pre>
<p>但是, 当要求产生特定的序列时, 就开始变得怪异了. 比如, 产生斐波那契数列中,
和小于 10000 的序列.</p>
<pre><code class="language-elixir">Stream.unfold(
  {1, 1, 0},
  fn {a, b, sum} -&gt; if sum &lt; 1000, do: {a, {a + b, b, sum + a}}, else: nil end
)
|&gt; Enum.to_list()
</code></pre>
<p>这样的 API, 虽然能完成工作, 但是代码的可读性非常差, 阅读这样的代码, 往往一头雾水.</p>
<p>这是因为控制流由 <code>Stream.unfold/2</code> 控制的.
<code>Stream.unfold(acc,fun)</code> 通过判断 <code>fun</code> 返回结果,
来决定为流中产生什么元素或者是否结束序列.
具体的说, 当 <code>fun</code> 返回的是 <code>nil</code> 的时候, 序列结束.
当 <code>fun</code> 返回一个二元元组的时候, 元组的第一个元素作为序列的元素,
第二个元素作为继续调用 <code>fun</code> 的参数.
这就是为什么, <code>Stream.unfold/2</code> 第二个参数的类型为
<code>(acc() -&gt; {element(), acc()} | nil)</code> 的原因.</p>
<p>如果要完成更加复杂的工作, 例如写一个从文件中读取内容的 <code>Stream</code>,
那么就必须使用 <code>Stream.resource/3</code>. 和 <code>Stream.unfold/2</code> 类似,
<code>Stream.resource/3</code> 根据回调函数的返回结果来决定如何产生流的元素和什么时候结束流.
但是 <code>Stream.resource(start_fun,next_fun,end_fun)</code>
因为要调用 <code>end_fun</code> 完成最后的资源清理工作,
所以不能仅要求 <code>next_fun</code> 返回 <code>nil</code> 来表示流结束.
<code>next_fun</code> 的类型规范是: <code>(acc() -&gt; {[element()], acc()} | {:halt, acc()})</code>.
当返回的结果为<code>{:halt,acc()}</code> 的时候, <code>Stream.resource</code> 调用 <code>end_fun(acc)</code>,
并结束流序列. 但为什么表示需要参数元素的时候, 不能直接返回 <code>{elememt(), acc()}</code>
而必须把要产生的序列放在列表中呢? 这是因为如果返回 <code>{element(),acc()}</code> 那么,
<code>Stream.unfold/2</code> 就无法产生一个包含 <code>:halt</code> 的 Stream 序列了.</p>
<p>Stream 让我想起了 Javascript 的产生子. 如果 Elixir 提供了产生子,
那么产生子函数结合上面定义的 Promise 就可以写出更加容易读的 Stream.</p>
<h2 id="产生子generater"><a class="header" href="#产生子generater">产生子(Generater)</a></h2>
<p>定义产生子的宏, 就叫做 <code>defgen</code> 吧.</p>
<p>我们使用 Javascript 产生子函数类似的语法. 在 <code>defgen</code> 上下文中, 可以使用 <code>yield</code>.
表达式 <code>yield a</code> 会等待 迭代子的 <code>next/2</code> 的执行. 待 <code>next/2</code> 执行后, <code>next/2</code>
会得到返回值 <code>{:ok, a}</code>; 而在产生子内部, <code>yield a</code> 的返回值是 <code>next/2</code> 的第二个参数.
产生子函数中最后一个 <code>yield</code> 语句执行完成后, 再调用 <code>next/2</code> 会返回 <code>:done</code>.</p>
<p>在 Javascript 中, 产生子函数返回的迭代器(记为 <code>g</code>), 第一次调用 <code>g.next(v)</code> 时,
传给 <code>next</code> 方法的值 <code>v</code> 被丢弃了. 我一直认为这时一个实现的 bug.
现在有机会来自己实现产生子, 我希望, 第一次调用 <code>next(g,v)</code> 传入的值 <code>v</code> 不会被丢弃.
在第一次调用 <code>next/2</code> 的时候, 就可以为 <code>next/2</code> 的第二参数提供任意的值.</p>
<p>那么该如何来实现呢? Elixir 现有的语法中, 如何组合出这样的功能呢?
首先 <code>receive</code> 会暂停一个进程的执行, 直到收到需要的数据, 才接着执行.
所以, 产生子函数, 应该运行在另外的一个进程中, 当<code>defgen</code> 返回的匿名函数被调用的时候,
产生子函数开始执行, 直到遇到第一个 <code>yield</code> 语句, 停止执行. 等待 <code>next/2</code> 函数发送信号.
当产生子进程, 收到 <code>next/2</code> 的发送的信号后, 表达式 <code>yield a</code> 完成如下工作:</p>
<ol>
<li>参数 <code>a</code> 发送给 <code>next</code></li>
<li>把 <code>next</code> 发送过来的数据作为 <code>yeild a</code> 的返回值传递后其他语句</li>
<li>继续执行其他语句, 直到遇到新的 <code>yeild</code> 语句</li>
</ol>
<pre class="mermaid">sequenceDiagram
    participant  主进程
    participant  产生子进程
    主进程-&gt;&gt; 产生子进程: 启动产生子进程 g = generater.(...)
    产生子进程--&gt;&gt;产生子进程: 运行, 遇到 yield 后,&lt;br&gt;等待主进程发送信号
    主进程-&gt;&gt; 产生子进程: v --- next(g,v)
    产生子进程-&gt;&gt;主进程:  {:ok,b} --- yield b
    主进程--&gt;&gt; 产生子进程: ...
    产生子进程--&gt;&gt;主进程:  ...
    主进程 --&gt;&gt; 主进程: 子进程还活着吗?
    主进程 -&gt;&gt; 主进程: 没有
</pre>
<p><code>defgen name do...end</code> 产生一个匿名函数, 这个匿名函数绑定给了变量 <code>name</code>.
调用匿名函数 <code>name</code> 会启动产生子进程, 并返回一个透明结构.
这个透明结构, 对应于 Javascript 的产生子迭代器,
但是, 在我们这里, 用它来作为客户端与产生子进程通信的信道.
如果我们愿意, 还可以为这个信道/迭代器实现枚举协议,
这样就可以使用 <code>Enum</code> 模块和 <code>for</code> 来处理产生的序列了.</p>
<p><code>defgen fun(a,b) do...end</code> 和 第 5章
<a href="ch05.new_constructor.html">≪定制新结构≫</a>
的递归匿名函数小节中, 定义的 <code>fn!/2</code> 宏有大量的功能是相同的:</p>
<ol>
<li>它们都定义匿名函数,</li>
<li>在宏的上下文中, 都可以完成对定义的匿名函数的递归调用.</li>
<li>还帮助我们把这个匿名函数绑定给了变量.</li>
</ol>
<p>这些共同的功能, 都是如何构造递归调用的匿名函数的, 所以, 可以把通用的代码,
提出到 Ast 辅助模块中.</p>
<p>其中功能完全一样的是对子句参数个数的检查. 我们把这个函数命名为
<code>clauses_arity_check(ast)</code>.
然后就是构建递归匿名函数的工作, 这两个匿名函数几乎是一样的,
所不同的是向递归匿名函数中添加的参数个数不一样, 稍微把定义 <code>fn!</code> 宏时用到的
<code>make_fn/3</code> 做一点修改, 就变成了 <code>make_recursive_fn/4</code>. </p>
<pre><code class="language-elixir">def make_recursive_fn(name, body, correct_args_fun) do
  new_body = Enum.map(body, &amp;clause_handler(correct_args_fun, name, &amp;1))
  {:fn, [], new_body}
end
defp clause_handler(
       correct_args_fun,
       name_ast = {atom, _, _},
       {:-&gt;, meta, [args | body]}
     ) do
  new_body = Macro.postwalk(body, &amp;correct_recursive_call(atom, &amp;1))
  new_args =
    if new_body != body do
      correct_args_fun.(args, name_ast)
    else
      name_atom = &quot;_#{atom}&quot; |&gt; String.to_atom()
      correct_args_fun.(args, {name_atom, [], nil})
    end
  {:-&gt;, meta, [new_args | new_body]}
end
# ast of `atom.(...args)` -&gt; ast of `atom.(atom, ...args)`.
defp correct_recursive_call(atom, {{:., m1, [{atom, _, _} = fun]}, m2, args}) do
  {{:., m1, [fun]}, m2, [fun | args]}
end
defp correct_recursive_call(_, ast), do: ast
</code></pre>
<p>这里, 我们添加的新参数 <code>correct_args_fun</code>. <code>fn!/2</code> 的相关代码, 只要用 <code>Ast</code>
模块中的代码替换原来的相关代码, 就可以完成更新.</p>
<p>在 <code>Ast</code> 模块的帮助下, 我们就可以专心写与 <code>defgen</code> 相关的核心功能了.</p>
<pre><code class="language-elixir">defmodule Corner.Generater do
  defstruct ref: nil, pid: nil, async: false
  alias Corner.Ast

  defmacro defgen(name, async \\ false, do: block) do
    case Ast.clauses_arity_check(block) do
      {:ok, arity} -&gt;
        tem_fun = {:TEM_fun, [], nil}
        tem_fun_ast = Ast.make_recursive_fn(name, block, &amp;make_args/2)
        params = Macro.generate_arguments(arity, nil)

        quote do
          unquote(name) = fn unquote_splicing(params) -&gt;
            unquote(tem_fun) = unquote(tem_fun_ast)
            async = unquote(async)
            ref = make_ref()
            me = self()

            fun = fn -&gt;
              try do
                unquote(tem_fun).(unquote(tem_fun), me, ref, unquote_splicing(params))
              rescue
                error -&gt; send(me, {ref, {:error, error, __STACKTRACE__}})
              end
            end

            pid = spawn(fun)
            struct(unquote(__MODULE__), pid: pid, ref: ref, async: unquote(async))
          end
        end
        |&gt; Macro.postwalk(&amp;yield_to_send(async, &amp;1))
      # |&gt; tap(&amp;(Macro.to_string(&amp;1) |&gt; IO.puts()))

      :error -&gt;
        {:=, [name, {:fn, [], block}]}
    end
  end
  # other ...
end
</code></pre>
<p><code>defgen</code> 的定义和 <code>fn!</code> 的定义非常的像, 差别只有两处,
第一处是为递归匿名函数修改参数的函数 <code>make_args/2</code> 定义不同.
产生子函数, 需要两个额外的参数表示产生子进程的 <code>pid</code> 和用来做通信参考的 <code>ref</code>.
这个改动也是非常的简单, 只需要把这两个参数加载函数名之后就可以了.</p>
<pre><code class="language-elixir">@pid {:pid, [], nil}
@ref {:ref, [], nil}
defp make_args([{:when, meta, args}], fun) do
  [{:when, meta, [fun, @pid, @ref | args]}]
end

defp make_args(args, fun) do
  [fun, @pid, @ref | args]
end
</code></pre>
<p>第二个改动是 <code>defgen</code> 定义最后的对产生的抽象语法树的遍历.
在本节的开始, 讲到在 <code>defgen</code> 上下文中, 是可以使用关键字 <code>yield</code> 的.
最后的对抽线语法树的遍历, 就是处理关键字 <code>yield</code>.</p>
<p>简单来说, <code>c = yield expression</code> 要被转化为:</p>
<pre><code class="language-elixir">c = receive do
  v -&gt; send(pid,{ref,[expresssion]})
end
</code></pre>
<p>对于的代码如下:</p>
<pre><code class="language-elixir">@doc &quot;&quot;&quot;
     Transform `c = yield a`
     &quot;&quot;&quot; &amp;&amp; false
defp yield_to_send(async, {:=, m1, [left, {:yield, _, _} = yield_exp]}) do
  receive_and_send = yield_to_send(async, yield_exp)
  {:=, m1, [left, receive_and_send]}
end
@doc &quot;&quot;&quot;
     Transform `yield a` to
     `
     receive do
       v -&gt; send(pid,{ref,[a]})
       v
     end
     `
     &quot;&quot;&quot; &amp;&amp; false
defp yield_to_send(async, {:yield, _meta, exp}) do
  pid = @pid
  ref = @ref
  return_value =
    if async do
      quote do
        [Promise.resolve(unquote(exp))]
      end
    else
      quote do
        unquote(exp)
      end
    end
  quote do
    receive do
      v -&gt;
        send(unquote(pid), {unquote(ref), unquote(return_value)})
        v
    end
  end
end
defp yield_to_send(_, a), do: a
</code></pre>
<p>为了更好的理解 <code>defgen</code> 到底如何工作, 打开 <code>defgen</code> 定义中注释掉的调试语句,
看看, <code>defgen</code> 到底是把代码转化成了什么样子:</p>
<pre><code class="language-elixir">import Corner.Generater

defgen my_generater do
  a, b when a &gt; b -&gt;
    c = yield(a)
    d = yield(c + b)
    yield(d)

  a, b -&gt;
    yield(a)
    yield(b)
end
</code></pre>
<p>转后后的代码为:</p>
<pre><code class="language-elixir">my_generater = fn arg1, arg2 -&gt;
  TEM_fun = fn
    _my_generater, pid, ref, a, b when a &gt; b -&gt;
      c =
        receive do
          v -&gt;
            send(pid, {ref, [a]})
            v
        end

      d =
        receive do
          v -&gt;
            send(pid, {ref, [c + b]})
            v
        end

      receive do
        v -&gt;
          send(pid, {ref, [d]})
          v
      end

    _my_generater, pid, ref, a, b -&gt;
      receive do
        v -&gt;
          send(pid, {ref, [a]})
          v
      end

      receive do
        v -&gt;
          send(pid, {ref, [b]})
          v
      end
  end

  me = self()
  ref = make_ref()

  fun = fn -&gt;
    try do
      TEM_fun.(TEM_fun, me, ref, arg1, arg2)
    rescue
      error -&gt; send(me, {ref, {:error, error, __STACKTRACE__}})
    end
  end

  pid = spawn(fun)
  struct(Corner.Generater, pid: pid, ref: ref, async: false)
end
</code></pre>
<p>代码张开后, 一切非常清楚, 新产生的匿名函数, 调用后会启动一个新进程,
并返回一个产生子结构 <code>Corner.Generater</code>, 它对应于 Javascript 产生子函数返回的迭代子. 
所以剩下的代码, 就是为为 <code>Cornder.Generater</code> 定义 <code>next/2</code> 方法了.</p>
<pre><code class="language-elixir">def next(%__MODULE__{} = m, v \\ nil) do
  if running?(m) do
    %{pid: pid, ref: ref} = m
    send(pid, v)
    receive do
      {^ref, [v]} -&gt; {:ok, v}
      {^ref, v} -&gt; v
    end
  else
    :done
  end
end
</code></pre>
<p><code>running?/1</code> 是一个简单的方法, 用来判定产生子的工作进程是否还或者.
此外, 我们还定义了一个 <code>running?/1</code> 的否定式 <code>done?/1</code>:</p>
<pre><code class="language-elixir">def running?(%__MODULE__{pid: pid}) do
  pid &amp;&amp; Process.alive?(pid)
end

def done?(%__MODULE__{} = m), do: !running?(m)
</code></pre>
<p>如何使用定义好的产生子函数呢?</p>
<pre><code class="language-elixir">g = my_generater.(3, 2)
{:ok, 3} = g |&gt; next(1) # c is 1
{:ok, 3} = g |&gt; next(4) # d is 4
{:ok, 4} = g |&gt; next(:any)
true = g |&gt; done?()
</code></pre>
<p><code>defgen</code> 对标的 Javascript 产生子函数返回的也是迭代子, 可以使用 <code>for-of</code>
语法完成迭代操作. Elixir 中, 只要实现可枚举协议 (Enumerable), 就可以使用
<code>for</code> 特殊表单了. 那么为产生子结构提供枚举实现吧.
<code>Enumerable</code> 定义了 4 个回调函数, 其中最核心的是 <code>reduce(t,acc,fun)</code>.</p>
<pre><code class="language-elixir">defimpl Enumerable, for: Corner.Generater do
  alias Corner.Promise
  alias Corner.Generater, as: G
  require Corner.Assign, as: Assign

  def reduce(%G{}, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  def reduce(%G{} = g, {:suspend, acc}, _fun) do
    {:suspended, acc, fn _acc -&gt; Process.exit(g.pid, :kill) end}
  end

  def reduce(%G{} = g, {:cont, acc}, fun) do
    if G.done?(g) do
      {:done, acc}
    else
      get_next(g, acc, fun)
    end
  end
  #....
end
</code></pre>
<p>当 <code>reduce/3</code> 的第一个分句被调用的时候, 表示迭代正常完成了, 所以把最后的结果
<code>acc</code> 返回就好了.
第二个分句被调用, 说明客户端已经得到了结果, 不需要后续的数据了,
因为产生子背后是运行的进程, 当用户不在需要产生子后, 背后的进程就应该终止,
第二个分句返回的元组的第三个元素是一个匿名函数, 它就是完成最后资源清理工作的.
第三个分句是正常的递归过程, 当产生子已经完成了, 返回结果就好了; 如果还没有完成,
那么调用 <code>get_next/3</code> 继续迭代.</p>
<pre><code class="language-elixir">defp get_next(%G{} = g, acc, fun) do
  case G.next(g) do
    {:ok, v} -&gt;
      if g.async or is_struct(v, Promise) do
        {_tag, v} = Promise.await(v)
        if is_struct(v, Promise), do: Promise.await(v), else: v
      else
        v
      end
      |&gt; Assign.to(new_v)
      reduce(g, fun.(new_v, acc), fun) #Loop
    {:error, error, stack} -&gt;
      {:done, {:error, error: error, stack: stack}}
    :done -&gt;
      {:done, acc}
  end
end
</code></pre>
<p><code>get_next/3</code> 实际上不过对 <code>Generater.next/1</code> 返回结果分情况处理而已.
如果迭代得结果是一个 <code>Promise</code> 结构, 那么首先从 Promise 中提取结果,
如果不是 Promise 那么直接继续下一轮得迭代.
迭代的工作最后转化为对第 11 行对 <code>reduce/3</code> 的递归调用.</p>
<p><code>Enumerable</code> 除了 <code>reduce/3</code> 外还有 <code>count/1</code>, <code>member?/2</code> 和 <code>slince/1</code>.
对产生子来说, 无法不遍历产生子就获得答案; 而遍历生产子, 遍历完成后, 产生子进程就结束了.
无法通过这些函数返回的信息, 进一步来处理产生子的内容了.
所以, 这些函数只是简单的返回 <code>{:error, __MODULE__}</code>.</p>
<pre><code class="language-elixir">@_ {:_, [if_undefined: :apply], Elixir}
for {fun, args} &lt;- [count: [@_], slice: [@_], member?: [@_, @_]] do
  def unquote(fun)(unquote_splicing(args)) do
    {:error, __MODULE__}
  end
end
</code></pre>
<p>因为实现了 <code>Enumerable</code> 协议, 所以, 可以是使用 <code>Enum</code> 模块和 <code>for</code>
特殊表单来处理我们的产生子.</p>
<pre><code class="language-elixir">defgen gen2 do
  () -&gt;
    yield(1)
    yield(2)
    yield(3)
end

g = gen2.()

[1, 2, 3] =
  for v &lt;- g do
    v
  end

true = done?(g)
</code></pre>
<h2 id="异步函数async"><a class="header" href="#异步函数async">异步函数(async)</a></h2>
<p>Javascript 中还有异步函数的概念.
为了和 Javascript 的异步编程 API 保持一致, 定义异步函数的宏, 命名为 <code>async</code>.
在前面, 我们已经定义 <code>Corner.Promise</code> 模块.
<code>async</code> 要做的最主要的工作就是修改抽象语法树, 把抽象语法树的返回值,
封装成 <code>Corner.Promise</code> 结构.
<code>async</code> 在其上下文中, 还为 <code>Corner.Promise</code> 命名了别名,
并导入了 <code>Corner.Promise.await/1-2</code>.
这样, 在其内部就可以方便的处理 <code>Promise</code> 结构了.</p>
<p>当前为函数, 私有函数, 匿名函数以及上一节的产生子提供了异步支持.</p>
<p>首先, 让我们看看函数和私有函数如果完成异步定义的. <code>def/2</code> 和 <code>defp/2</code> 的返回结果
转化为 Promise 结构就好了. <code>return_promsie/1</code> 函数就是完成这工作的.
<code>async</code> 中的其他代码, 不过调用 <code>def/2</code> 或 <code>defp/2</code> 宏来创建函数或私有函数而已.</p>
<pre><code class="language-elixir">defmodule Corner.Async do
  defmacro async({atom, _meta, args}, do: body) when atom in [:def, :defp] do
    new_body = return_promise(body)

    case atom do
      :def -&gt;
        quote do
          def(unquote_splicing(args), do: unquote(new_body))
        end

      :defp -&gt;
        quote do
          defp(unquote_splicing(args), do: unquote(new_body))
        end
    end
  end
  #...
end
</code></pre>
<p>那么改如何把一个函数体的返回值转化为 Promise 呢? 或者是,
怎么才能在抽象语法树中识别出返回值呢?
其他函数中, 比如 C 语言家族中, 都是用 <code>return expression</code> 来表示函数的返回值,
因此可以从抽象语法树中识别出来, 但是 Elixir 中不是这样的, 在抽象语法树中,
是无法识别出返回值的. 不过在 Elixir 中,  可以使用 <code>try</code>
特殊表单来获得一个代码块的返回值. <code>return_promise/1</code> 就是这样做的.</p>
<pre><code class="language-elixir">defp return_promise(ast) do
  quote do
    alias Corner.Promise
    import Corner.Promise, only: [await: 2, await: 1]
    try do
      unquote(ast)
    rescue
      err -&gt;
        Promise.reject({err, __STACKTRACE__})
    else
      v -&gt;
        if is_struct(v, Promise) do
          v
        else
          Promise.reject(v)
        end
    end
  end
end
</code></pre>
<p>现在让我们看看如何为匿名函数提供异步支持.</p>
<pre><code class="language-elixir">defmacro async({:fn, meta, ast}) do
  new_ast = arrow_return_promise(ast)
  {:fn, meta, new_ast}
end
defp arrow_return_promise(abs) do
  walker = fn
    {:-&gt;, meta, [args, body]} -&gt;
      new_body = return_promise(body)
      {:-&gt;, meta, [args, new_body]}
    ast -&gt;
      ast
  end
  Macro.postwalk(abs, walker)
end
</code></pre>
<p>匿名函数使用 <code>fn</code> 特殊表达来定义, 它和 <code>def/2</code> 不一样,
需要自己提取分句的每个分句的函数体.
在 <code>arrow_return_promise</code> 中定义的匿名函数 <code>walker</code> 就是完成这个工作的.</p>
<p>最后是对 <code>defgen</code> 宏的支持.</p>
<pre><code class="language-elixir">defmacro async({:defgen, _, [fun_name]}, do: block) do
  new_block = arrow_return_promise(block)
  quote do
    import Corner.Generater
    alias Corner.Promise
    import Corner.Promise, only: [await: 1]
    defgen(unquote(fun_name), true, do: unquote(new_block))
  end
end
</code></pre>
<p><code>defgen</code> 的异步支持, 非常像 <code>fn</code> 的异步支持. 但是因为 <code>defgen</code> 是我们自己定义的宏,
所以, 我们需要首先向用户的环境中导入 <code>Corner.Generater.defgen/2-3</code> 和
<code>Corner.Promise.await/1</code>. 我们还为 <code>Corner.Promise</code> 引入了别名, 这样,
在 <code>defgen</code> 的上下文中, 我就可以使用较为紧凑的 <code>Promise</code> 来写代码了.</p>
<p>最后, 检验时刻到, 我们可以像下面的代码那样来使用 <code>async</code> 来写代码了:</p>
<pre><code class="language-elixir">import Corner.Async

async defgen(fun) do
  a, b -&gt;
    yield(Promise.resolve(3))
    yield(a)
    yield(b)
end
is_function(fun, 2)#true

for v &lt;- fun.(2,1) do
  v
end #[3,2,1]
</code></pre>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="ch05.new_constructor.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07.pipe.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="ch05.new_constructor.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="ch07.pipe.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    <script type="text/javascript" src="theme/mermaid.min.js"></script>
    <script type="text/javascript" src="theme/mermaid-init.js"></script>


</body>

</html>