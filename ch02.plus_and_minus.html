<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>加和减 - 角落里的长生不老药</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="ch01.intruction.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="ch02.plus_and_minus.html" class="active"><strong aria-hidden="true">2.</strong> 加和减</a></li><li class="chapter-item expanded "><a href="ch03.pattern_match.html"><strong aria-hidden="true">3.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="ch04.parenthese.html"><strong aria-hidden="true">4.</strong> 括号</a></li><li class="chapter-item expanded "><a href="ch05.new_constructor.html"><strong aria-hidden="true">5.</strong> 定制新结构</a></li><li class="chapter-item expanded "><a href="ch06.async_programe.html"><strong aria-hidden="true">6.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="ch07.pipe.html"><strong aria-hidden="true">7.</strong> 管道操作符</a></li><li class="chapter-item expanded "><a href="ch08.error_handle.html"><strong aria-hidden="true">8.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="ch09.module.html"><strong aria-hidden="true">9.</strong> 模块</a></li><li class="chapter-item expanded "><a href="ch10.protocol_and_behaviour.html"><strong aria-hidden="true">10.</strong> 协议与行为</a></li><li class="chapter-item expanded "><a href="ch11.macro.html"><strong aria-hidden="true">11.</strong> 如何理解宏</a></li><li class="chapter-item expanded "><a href="ch12.process.html"><strong aria-hidden="true">12.</strong> 进程</a></li><li class="chapter-item expanded "><a href="chx.cold_knowledge.html"><strong aria-hidden="true">13.</strong> 附录 冷知识</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">角落里的长生不老药</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="第二章-加和减"><a class="header" href="#第二章-加和减">第二章 加和减</a></h1>
<h2 id="问题的描述"><a class="header" href="#问题的描述">问题的描述</a></h2>
<p>使用 Elixir 编程的时候, 第一个让我困惑的地方就是加减运算符了.
<code>-</code> <code>+</code> 运算符号如此简单, 大部分情况下, 我们都不到会意识有什么问题存在.
但是在 Elixir 中, 我不止一次在这个地方被编译器无情的打脸.
而且刚开始, 挨打了还莫名其妙.</p>
<pre><code class="language-elixir">(1 - 1) |&gt; IO.inspect(label: &quot;1 -1&quot;)
a = 1
(1 -a) |&gt; IO.inspect(label: &quot;1 -a&quot;)
a -1
</code></pre>
<p>在上面的代码示例, 是我学习 Elixir 中, 按照书籍示例的代码, 在 IEx 中输入的.
当我按照书中的代码, 输入 <code>a - 1</code> 时, 不小心写成了 <code>a -1</code>, 就像上面的片段中最后一行那样.
Iex 居然抛出了错误. 这出乎我的意料. 我完全想象不出, 为什么这里会有错误.</p>
<p>首先, 我知道变量 <code>a</code> 的值为 1, 难道 Elixir 中 <code>1 - 1</code> 不等于 0, 而是抛出错误?
我快速的在 iex 中输入 <code>1 - 1</code>, 当然没有问题了.</p>
<p>那会不会什么时候, 变量 <code>a</code> 的值类型改变了呢?
<code>a</code> 的值不是数值 1, 而是字符串 &quot;1&quot; ?
于是我又加入调试语句, <code>IO.inspect(a,label: &quot;a&quot;)</code>.
<code>a</code> 的值的确是数值 1, 那么我就更困惑了, 那怎么会出错呢?
困惑中, 我再试了一下, 这次输成了  <code>1 - a</code>, 居然得到了正确答案 0.
仔细比较后发现, 出错的代码, 变量在减号的后面, 那么改回去,
<code>a - 1</code>, 怎么又正确了? 灵异事件?</p>
<p>当时, 我刚开始学习 Elixir, 还有很多的内容等待我去学习,
既然正确了, 我就没有仔细追究背后的原因.</p>
<p>等我开始用 Elixir 写更长代码后, 当这个问题再次出现的时候,
错误提示更加莫名奇妙了. 但是总是和 <code>-</code> 或 <code>+</code> 相关,
而且最后问题的解决往往也就只是在 <code>-</code> 或 <code>+</code> 之前加一个空格.</p>
<p>但是为什么呢? 为什么会出现这样的问题呢? 因为不知道错误的原因,
所以即使了解了该如何解决, 还是让我非常的疑惑.
直到有一天我认真的阅读了编译器的错误提示.</p>
<pre><code>&quot;a -1&quot; looks like a function call but there is a variable named &quot;a&quot;.
If you want to perform a function call, use parentheses:
a(-1)
If you want to perform an operation on the variable a, use
spaces around the unary operator
</code></pre>
<p>如果不是因为理解了  <code>&quot;a - 1&quot; 看起来像函数调用, 但是存在一个变量命名为 &quot;a&quot;</code>,
那么这段提示就算我很早就注意到, 也依然是不知所云的.</p>
<h3 id="为什么"><a class="header" href="#为什么">为什么?</a></h3>
<p>但是为什么会是这个样子呢? 其他编程语言, 写 <code>a -1</code> 不都没问题的吗?</p>
<p>这是几个知识点组合起来引发的迷惑.</p>
<h4 id="1-elixir-中函数调用时可以省略小括号"><a class="header" href="#1-elixir-中函数调用时可以省略小括号">1. Elixir 中函数调用时可以省略小括号</a></h4>
<p>这就是为什么, 在 iex 中, 我们可以像使用 shell 命令那样使用 <code>cd</code>, <code>r</code> <code>h</code>
等等函数的原因.</p>
<p>函数定义在模块中, 当被导入到其他环境后, 可以不带模块名, 而直接使用函数名来调用.
对于整数除法来说, 可以使用 <code>div(1, 2)</code> 来代替 <code>Kernel.div(1,2)</code>,
进一步地, 函数调用的小括号也是可以省略的, 省略小括号后, 就成了 <code>div 1, 2</code>.</p>
<p>函数调用可以省略括号, 为什么要这样做呢? 我认为有以下两个原因.</p>
<ol>
<li>零元无副作用的函数来实际上和常量一样. Elixir 和 Erlang 中,
也正是如此来使用零元无副作用的函数的. 比如 <code>:math.pi</code>. 如果必须加上小括号,
像<code>:math.pi()</code> 的话, 就太不像常量了.</li>
<li>Elixir 中使用宏来做元编程, 调用宏的时候不写括号, 代码的可读性更强.
不带括号, 使得宏调用, 看起来像是其他语言中的关键字. 对比一下:</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">不带括号的宏调用看起来更像关键字</th><th>加上括号的宏调用更像函数调用</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>import Module, only: [fun1: 1]</code></td><td><code>import(Module, only: [fun1: 1])</code>.</td></tr>
</tbody></table>
</div>
<h4 id="2-操作符---身兼二职"><a class="header" href="#2-操作符---身兼二职">2. 操作符 <code>-</code> 身兼二职</a></h4>
<ol>
<li><code>-/2</code> 是减法操作符.</li>
<li><code>-/1</code> 是取反操作符.</li>
</ol>
<h4 id="3-变量和函数名使用的标识符规则一样"><a class="header" href="#3-变量和函数名使用的标识符规则一样">3. 变量和函数名使用的标识符规则一样</a></h4>
<p>让我们再来看一下, <code>a -1</code> 引发的编译错误:</p>
<pre><code>(CompileError) : &quot;a -1&quot; looks like a function call but there is a variable named &quot;a&quot;.
If you want to perform a function call, use parentheses:
`a(+1)`
If you want to perform an operation on the variable a,
use spaces around the unary operator
</code></pre>
<p>看起来是因为编译器优先把标识符 <code>a</code> 解释为函数, 而实际上它是一个变量, 所以才引发错误的.
可是为什么编译器不首先把标识符解释为变量呢? 这样, 就可以把 <code>a -1</code> 解释为对 <code>a</code> 减去 1,
而不是以 <code>-1</code> 为参数来调用函数 <code>a</code>.</p>
<p>答案是编译器实际上就是优先把标识符解释为变量的, 但是有些时候, 编译器不能区分变量和函数.</p>
<p>首先, 让我来证明, 编译器的确是优先把小写字母开头的标识符解释为变量的.</p>
<h2 id="标识符优先被解释为变量"><a class="header" href="#标识符优先被解释为变量">标识符优先被解释为变量</a></h2>
<p>首先, 我们导入一个零元函数 <code>:math.pi/0</code>, 然后再定义一个同名的变量 <code>pi</code>,
让我们看看, 使用标识符 <code>pi</code> 的时候, 得到的 <code>:math.pi</code> 的返回值,
还是我们自定义的变量的值.</p>
<pre><code class="language-elixir">import :math, only: [pi: 0]
pi |&gt; IO.inspect(label: &quot;before define variable pi&quot;)
pi = &quot;This is variabel pi!&quot;
pi |&gt; IO.inspect(label: &quot;after  define variable pi&quot;)
</code></pre>
<p>在定义变量 <code>pi</code> 之前, 我们使用标识符 <code>pi</code>, 用到的是当然是导入的零元函数.
但当我们定义变量 <code>pi</code> 之后, 再使用标识符 <code>pi</code>, 得到的是变量 <code>pi</code> 的值.
那么有没有可能是变量 <code>pi</code> 遮盖了函数 <code>:math.pi/0</code>? 或者说,
如果先定义变量, 后导入零元函数, 编译器会不会,
把标识符 <code>pi</code> 解释为对函数 <code>:math.pi/0</code> 的调用呢?</p>
<p>当前的 IEx 环境中, 已经导入了 <code>pi/0</code> 函数, 如果读者跟随我的思路, 在你的 iex 中实验的话,
那么你的环境中, 也已经导入了 <code>pi/0</code>. 为了清晰起见, 让我们定义一个新的变量 <code>e</code> 和零元函数 <code>e/0</code>,
来实验我们最新的假设.</p>
<pre><code class="language-elixir">e = &quot;var e&quot;

defmodule TempModule do
  def e, do: :math.exp(1)
end
import TemModule
e |&gt; IO.inspect()
</code></pre>
<p>输出为: <code>&quot;var e&quot;</code>.</p>
<p>因此, 我们可以得出结论, 同名的零元函数和变量, 出现在同一个上下文的时候,
无论变量和函数出现的顺序如何, 编译器都优先把标识符解释为变量.</p>
<h2 id="函数其实没有被覆盖"><a class="header" href="#函数其实没有被覆盖">函数其实没有被覆盖</a></h2>
<p>前面的章节, 我们说, 零元函数被同名的变量覆盖的了. 实际上不是的.
零元函数, 依旧是可访问的, 只是当有同名的变量存在的时候,
对零元函数的调用就不能省略小括号了.
例如下面的代码:</p>
<pre><code class="language-elixir">pi |&gt; IO.inspect(label: &quot;pi&quot;)
pi() |&gt; IO.inspect(label: &quot;pi() still is&quot;)
</code></pre>
<p>其输出为:</p>
<pre><code>pi: &quot;This is variabel pi!&quot;
pi() still is: 3.141592653589793
</code></pre>
<p>对于有元函数来说, 函数没有不覆盖, 就更加清楚了.
我们以 <code>Kernel.abs/1</code> 为例, 核心模块 <code>Kernel</code> 中的函数都是默认导入的,
当我们定义了 <code>abs</code> 的变量后, 上下文中, 就同时出现了同名的变量和函数 --- --- <code>abs</code>.
但是像下面的代码所展示的那样:
当我们需要一个变量的时候, 获得就是一个变量;
当我们需要一个函数的时候, 获得就是一个函数.</p>
<pre><code class="language-elixir">abs = -2

abs
|&gt; abs
|&gt; IO.inspect(label: &quot;abs |&gt; abs&quot;)

IO.inspect(abs / 3, label: &quot;abs/3&quot;)
IO.inspect(1 / abs, label: &quot;1/abs&quot;)
IO.inspect(&amp;abs/1, label: &quot;&amp;abs/1&quot;)
IO.inspect(abs -9, label: &quot;abs -9&quot;)
</code></pre>
<p>上面的片段中, 第1, 3, 7 和 8 行中的 <code>abs</code> 都是变量, 而 4, 9 和 10 行的 <code>abs</code> 都是函数名.</p>
<p>看起来编译器是可以区分变量和函数的. 但是, 不总是这样的.</p>
<p>有时候, 代码是有歧义的, 这时编译器不能确定标识符到底是函数还是变量.</p>
<h2 id="歧义代码"><a class="header" href="#歧义代码">歧义代码</a></h2>
<p>如果遇到这样的代码: <code>abs - abs</code>, 那么这两个 <code>abs</code> 怎么区分呢?
显然是有两种解释的:</p>
<ol>
<li>两个 <code>abs</code> 都是变量, 那么结果自然是 0;</li>
<li>第一个 <code>abs</code> 是函数, 第二个 <code>abs</code> 是变量, 那么返回的结果应该是变量  <code>abs</code> 的绝对值, 也就是 2.</li>
</ol>
<p>答案是 0. 也就是说操作符 <code>-</code> 把两边操作数都当作是变量.</p>
<p>但是这样的代码 <code>abs -abs</code> 呢? 也依然有两种解释,
实际上这一次因为 <code>-</code> 和第二个 <code>abs</code> 之间没有空格,
更应该优先把 <code>-</code> 解释为对变量 <code>abs</code> 的取反.
如果这样解释的话, 那么第一个 <code>abs</code> 解释成什么呢?
似乎只能解释为函数, 那么结果应该是 2.</p>
<p>但是实际上, 编译器抛出了一个错误.</p>
<pre><code>(CompileError) :&quot;abs -abs&quot; looks like a function call but there is a variable named &quot;abs&quot;.
If you want to perform a function call, use parentheses:
`abs(-abs)`
If you want to perform an operation on the variable abs,
use spaces around the unary operator
</code></pre>
<p>为什么, 编译器不优先把 <code>-abs</code> 作为一个整体, 来解释为对 <code>abs</code> 的取反操作呢?
因为在别的语法环境中, <code>-abs</code> 作为整体解释, 会出现问题.</p>
<ol>
<li>
<p><code>abs-abs</code> 怎么解释呢?</p>
<ol>
<li>优先把 <code>-abs</code> 作为一组来解析, 得到的是一个数值.
那么把第一个 <code>abs</code> 解释为函数, 合乎语法;</li>
<li>把两个 <code>abs</code> 都解释为变量,语法也是正确的.</li>
<li>可是两个语义完全不同.</li>
</ol>
<p>实际上编译器在这种情况下, 把两个 <code>abs</code> 都解释为变量.</p>
</li>
<li>
<p><code>abs -abs -abs</code> 呢?</p>
<p>如果两个 <code>-abs</code> 都解释为对变量取反, 而把第一个 <code>abs</code> 解释为函数,
那么整个表达式等价于 <code>abs(2 2)</code> 还是 <code>abs(2) 2</code>?
但是无论<code>abs(2 2)</code> 还是 <code>abs(2) 2</code> 都不是 Elixir 的正确语法.</p>
</li>
<li>
<p>要想 <code>abs -abs -abs</code> 有意义, 只能把两个 <code>-abs</code> 做不同的解释才行.</p>
<ol>
<li>把 <code>abs -abs -abs</code> 解释为 <code>(abs) - abs(-abs)</code>, 是可行的,
但是对编译器的实现来说来说, 完成这样的结束, 需要的实现太复杂了.</li>
<li>把 <code>abs -abs -abs</code> 解释为 <code>(abs -  abs) - abs</code> 就彻底放弃了对 <code>-abs</code> 优先解释.</li>
</ol>
</li>
</ol>
<p>综合起来看, 只好放弃对 <code>-abs</code> 的优先解释, 而把 <code>-abs</code> 解析为两个符号: <code>-</code> 与 <code>abs</code>.</p>
<h3 id="为什么报错"><a class="header" href="#为什么报错">为什么报错</a></h3>
<p>上面的分析, 我们看到, 只能把 <code>-abs</code> 解释为 <code>-</code> 和 <code>abs</code> 两个符号.
但是这样处理后, 为什么当编译器遇到 <code>abs -abs</code> 的时候会报错呢?
这是因为, 有时候, 我们写 <code>-abs</code> 的时候, 我们的真实的意图就是要对 <code>abs</code> 取反.
如果编译器一律把 <code>x -abs</code> 解释为 <code>x</code> 减去 <code>abs</code>,
那么代码有可能实际上违背了我们的真实意图.</p>
<p>抛出错误, 强迫程序员明确 <code>-</code> 的意义, 可以使得 Elixir 代码更强壮,
这符合 Erlang 的 &quot;Let it crash&quot; 哲学. 在编译时奔溃好过在运行时奔溃.</p>
<p>最后一点, 我们的分析中, 表达式 <code>token -token1</code> 中,
<code>token</code> 和 <code>token1</code> 都是标识符;
但是实际上, 只要 <code>token</code> 是标识符,<code>token1</code>  无论是数值字面量还是标识符,
这个表达式都会引发这里讨论的问题.</p>
<p>我们可以用以下表格来总结表达式的各种情形:</p>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>语法正误</th><th>解释</th></tr></thead><tbody>
<tr><td><code>x-x</code></td><td>正确</td><td>当 <code>-</code> 两边的符号与 <code>-</code> 之间都没有空白时, 解释器把 <code>-</code> 解释为减法</td></tr>
<tr><td><code>1 -1</code></td><td>正确</td><td>数字是不能作为函数名的, 所以 <code>-</code> 只能解释为减法.</td></tr>
<tr><td><code>1 -a</code></td><td>正确</td><td>无论 <code>a</code> 是表达式, 还是变量, 都必须把 <code>-</code> 解释为在减号, 整个表达式才正确</td></tr>
<tr><td><code>a -1</code></td><td>错误</td><td>表达式存在歧义, 既可以用作解释为函数调用 <code>a(-1)</code>; 又可以解释为变量 <code>a</code> 减去 1.</td></tr>
<tr><td><code>a -b</code></td><td>错误</td><td>同上.</td></tr>
</tbody></table>
</div>
<h2 id="加"><a class="header" href="#加">加</a></h2>
<p>这章的题目是  <strong>≪加和减≫</strong>, 但是, 到目前为止, 我们的分析只涉及到了 <code>-</code>.
我不是跑题了, 而是因为 <code>+</code> 存在的问题, 和 <code>-</code> 本质是一样的.</p>
<p><code>-/1</code> 在编程中承担了有意义的工作; <code>+/1</code> 不一样.
<code>+/1</code> 在 Elixir 中真正的意义, 在编程实践中, 几乎用不到.</p>
<p>你能想象到 <code>+/1</code> 的实际意义吗?</p>
<p>首先, 如果 <code>b</code> 是一个数字, <code>+b</code> 并不返回 <code>b</code> 的绝对值.
从 C 到 Javascirpt, ..., 到 Erlang 再到 Elixir, 都是如此.
这还真是一个有趣的现象, 这样一个赘疣一样的语法弥因 (Meme),
怎么就在编程语言设计的领域中扩散开的?
Elixir 继承自 Erlang, <code>+/1</code> 在 Elixir 中就是调用的 Erlang <code>+/1</code><sup class="footnote-reference"><a href="#plus_one">1</a></sup>.
Erlang 又从哪里继承的, 我就不得而知了.</p>
<p>但是这个赘疣源远流长. 在最早的高级编程语言 Fortran 和 Lisp 中就有它的身影.
在 Lisp 中, <code>+</code> 是一个不定参数的函数, 在定义 <code>+</code> 的时候,
以 0 为初始值, 对所有参数作累加操作, 根本就不需要对单参数的情形作特殊处理.
在 Fortran 中, 为什么也有它的身影, 我就不得而知. 也许是出于与 <code>-/1</code> 的对称考虑?</p>
<p>对于非操作符前缀的语言, 我认为 <code>+/1</code> 就是一个赘疣, 乍看无关痛痒, 后期的发展,
有可能危害生命. 我建议编程语言的设计者: 在自己设计的编程语言中, 消灭 <code>+/1</code>;
如果非要为 <code>+/1</code> 保留一席之地, 那么就给它分配一个有意义的工作; 比如拿来作<strong>取绝对值</strong>的操作符.</p>
<div class="footnote-definition" id="plus_one"><sup class="footnote-definition-label">1</sup>
<p>见 Elixir 核心模块<a href="https://github.com/elixir-lang/elixir/blob/33f9d04851a2664aeae5f5f78eeef9e5b4c38030/lib/elixir/lib/kernel.ex#L1347">源码 1347~1349 行</a>.</p>
</div>
<p>在 Javascirpt 中 <code>+/1</code> 找到了自己的一席之地: 可以用来完成字符串到数值的转化.</p>
<pre><code class="language-js">a=&quot;123&quot;
console.log(+a + 1) //124
</code></pre>
<p>Elixir 是强类型语言, <code>+/1</code> 不提供这个功能.
那么 Elixir 中 <code>+/1</code> 的用途是什么呢?
我能想到的唯一用途就是: 检查一个值是否为数值类型,
如果是, 返回其值; 如果不是, 则抛出错误. 也就是说, <code>+/1</code> 可以这样定义:</p>
<pre><code class="language-elixir">def +(m) do
  if is_number(m) do
    m
  else
    message = &quot;bad argument in arithmetic expression: +(#{inspect m})&quot;
    raise ArithmeticError, message
  end
end
</code></pre>
<p>但是在 Elixir 和 Erlang 中, 抛出错误不是一个常规的编程操作, 所以, 我从来没见过有人用过这个语法.</p>
<p>如果 Elixir 中取消了 <code>+/1</code> 的定义, 只把 <code>+</code> 解释为加法, 那么 <code>a +1</code>, <code>a +b</code>,
这些表达式中的语法歧义就消除了.</p>
<p><code>-</code> 引发错误是不得已; <code>+</code> 引发的错误, 是赘疣恶化的结果. 你同意吗?</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="ch01.intruction.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch03.pattern_match.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="ch01.intruction.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="ch03.pattern_match.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    <script type="text/javascript" src="theme/mermaid.min.js"></script>
    <script type="text/javascript" src="theme/mermaid-init.js"></script>
</body>

</html>