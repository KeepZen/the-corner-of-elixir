# 如何理解宏

## 宏 与 语言分类

宏是什么? 这似乎是一个非常容易掌握的概念. 我的理解是这样的:
宏是写给编译器的指令. 这个定义非常宽泛, 从 C 这样的最简单的文本替换宏,
到 Lisp 这样的对抽象语法树做处理的宏, 都可以包括.

这样的理解不能说错误, 但是取没有抓住宏的本质.
我发现, 这就是为什么, 我现在学习 Elixir 的时候,
时常遇到困惑的一个根本原因.

所以如此, 和我的知识储备有关系.
我学习和熟练掌握的编程语言中, 宏在其中要么基本上没有地位(Python, Js),
要么只有非常非常小的作用(C, C++). 所以对宏的理解,
才会一直停留在概念的阶段.

按照我们的定义, 宏只能是编译型语言中才会出现的概念.
因为解释性的语言, 没有编译器的存在.
当然了, 我知道也理解, 现在大部分的解释器,
实际上也是要做编译器要做的工作的. 所以理论上, 也应该有宏的.
但是对于解释性的语言来说, 要区分宏和普通的代码是困难的.
因为代码的执行和宏的执行, 概念上有先后的两个动作,
对于解释性的语言, 从外部观察时, 这两个动作是难以区分的.
但是对于编译型的语言, 因为编译代码和运行程序可以做到时间上间断,
所以可以清楚区分它们. 例如, 同样的关于外部代码的导入的语法,
C/C++ 中以 `#include` 的形式出现, 通过预处理,
我们可以清楚的体会到宏的存在; 而 Js 中以 `import` 语句,
Js 解释器与 C 编译器做了大量的相同的工作,
却难以从外部观察到, 如果不考虑程序的执行的话.

不那么严格的解释, 可以认为解释性语言, 解释器对源码是解释执行的.
而编译型的语言, 编译器是要编译源码的. 通常情况下, 
**编译** 我理解就是做翻译, 把源码中的文本翻译成中央处理器(CPU)
或者虚拟机(VM) 可以理解的内容.
这样的理解对于普通的代码是没有问题的, 但是当考虑宏的时候,
编译器对宏做的事情就不能这样理解了.
普通的代码, 对编译器来说, 是要处理的数据; 但宏不是编译器要处理的数据,
而是待执行的指令. 编译器对宏, 正像解释器对源码做的一样: 解释执行它们.

拿一个社会生活的场景来对比一下, 也许就更清楚了.

一个对翻译品质有担当的翻译者, 在翻译的时候往往会和作者沟通;
如果两人关系更密切的话, 译者甚至拿到的翻译底本, 直接就有原作者的批注.
这些批注是写给译者的, 来提醒译者原文的正确意图是什么.
这些内容(批注或者作者的答复), 虽然不是原书的内容,
但是它们对译文来说, 是必要的, 因为它们确确实实的要影响最后译文,
进而影响读者对原文的理解. 在这里, 译者就是编译器; 原始的书稿内容是常规的代码;
作者的批注和答复, 就是宏; 译文就是编译后的目标码; 读者就是 CPU 或 VM.

在 C/C++ 以及 Erlang 这些语言中, 宏能完成的工作是非常少的,
就像作者给译者的注释那样, 大部分的工作还是要编译器/译者自己完成.
但是这样的意象在处理 Elixir 这样的宏的时候, 就又不适用了.

例如, 对于 BEAM 虚拟机的最基本的编译单元**模块**来说.
但是在 Elixir 中, 我们必须使用宏 `defmodule`.
它和 Erlang 中的 `-module(MODULE_NAME).` 做的工作完全不是一个数量级的.
`-module(MODULE_NAME).` 只是标记了模块的名字, 并没有涉及到模块的正文.
`defmodule` 不一样, 它不但包含了模块的名字, 而且包含了模块正文.
所以脚注的意象在这里就不合适了. Elixir 宏的合适意象应该汉语屋的故事[^chinese-room].
译者对原文的翻译是智慧型的劳动; 汉语屋中的人做的却是机械的工作.

从语言学的角度来看, C/C++, Erlang 的宏不能构成一个图灵完备的语言,
或者至少设计的初衷不是把它们当作一个图灵完备的语言来设计的[^c-macro].
但是 Elixir 中的宏是图灵完备的, 从这个角度来看
Elixir 的编译器实际上就是宏的解释器.
写常规的 Elixir 代码就是对内建宏的调用, 这就像是我们在其他语言中调用标志库一样;
定义自己的宏, 元编程, 那就像我们用其他语言来完成我们的编程任务一样,
只是元编程的任务是对编译器的功能进行扩增和修改.

[^c-macro]: 有关 C 语言宏的图灵完备性的讨论见 https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete

## 编译器与宏

Elixir 的编译器是 `elixirc`. 我们现在来探索一下编译器.

<!-- livebook:{"force_markdown":true} -->

```elixir
IO.puts("Hello World!")
```

把上面的代码保存到名为 hello-word.ex 文件中, 然后我们在命令行中输入`elixirc hello-world.ex`,
然后我们就看到了 "Hello, World!", 但是在当前的目录下面,
并没有产生 `hello_world.beam` 文件.

上面的代码片段, 以及它的运行的结果, 告诉我们, 在模块外的作用域中,
代码直接在编译时运行(输出 "Hello World"),
而不是把编译的结果保存到字节码文件中(所以没有 `.beam` 文件).

模块的外的代码, 编译器直接解释执行; 模块内的代码, 编译器是如何处理的呢?

```elixir
IO.puts("Say hello outside Module!")

defmodule MyModule do
  IO.puts("Say Hello in MyModule But not in function")

  def hello do
    IO.puts("Say Hello in MyModule.hello()")
  end
end
```

把上面的代码保存到 `my_module.ex` 文件中, 然后使用 `elixirc my_module.ex`
命令来编译我们的文件. 在编译的过程中, 我们可以看到第 1 行和第 3 行的输出.
在当前目录下, 还能看到编译器产生的 `Elixir.MyMoule.beam` 文件.

这说明, `defmodule/2` 的第二个参数, 我们上面代码中的 `[do: (...)]`
表示的关键字列表组成的 `do-block` (或者 `do`...`end` 块),
在 `defmodule/2` 被调用的时候, 得到了执行.
其中的输出语句(第 3 行) 在编译时执行了,
所以我们在编译器的输出中, 看到了它的输出.
最后产生的 `Elixir.MyModule.beam` 文件,
这说明编译器还把其他的编译内容保存到了字节码文件中.

现在我们启动 `iex`. 输入 `MyModule.hello()`,
按下回车后, 第 5 行的输出语句就显示出来了.
这说明, 我们的 `hello/0` 函数的确被编译到了字节码文件中.

在模块中, 不但可以调用 `def*` 这些宏, 还可以执行其他语句, 这还是让我十分的惊讶的.
因为 C++ 和 Java 的背景知识, 不由自主的总是把 Elixir 的模块和类的概念联系到一起.
但是在类的定义的作用域中, 基本上只可以使用赋值语句, 而且 `=` 的右值还必须是编译时常量,
其他控制结构, 或者函数调用都是不允许的. C 语言的全局作用域中, 基本上也是这样的要求.
即使在亲缘关系最近的 Erlang 中, 基本上也是一样.
控制结构, 函数调用, 都只能在函数的定义中使用.

如果一定要在其他语言中寻找对应物的话, 那么可能就是 Java 的静态块了.
但是 Elixir 中模块中 `def*` 外的其他代码, 和 Java 中的静态块又有不同,
Java 中的静态块是编译到字节码中的, 是每次字节码被加载的时候, 被执行的代码块.
而*Elixir 模块中, `def*` 意外的代码并**没有**都没有被保存到字节码中*.

这一点我们可以通过启动 `iex` 的时候, 并没有看到代码片段中第 3 行的输出而得到确认.
或者, 我们可以可以使用 Elang 提供的库函数 `:beam.chunks/2`, 
来查看编译后的代码的抽象码(字节码对应的汇编语言), 以此来更直观的证实我们的结论.

在 iex 中输入 `:beam_lib.chunks('Elixir.MyModule',[:abstract_code])`,
我们就看到了 `Elixir.MyModule.beam` 中保存的字节码对应的抽象码.

观察输出的抽象码, 不难发现, 其中的确有我们这里定义的 `hello/0` 函数;
而且真的找不到第 1 行和第 3 行相关的代码.
这全面的证实了我们上面对编译器的分析.

## 模块属性

Erlang 中, 模块和 `.beam` 文件之间的关系是非常的明确的,
Erlang 的一个源代码 (.erl) 就是被编译器转化为一个 `.beam` 文件了.
所以模块的属性的作用在 Erlang 中非常的明确, 就是告诉编译器, 
如何来填充 `.beam` 文件的相关段落(chunk)的.

在 Erlang 中, 大部分属性和 `.beam` 段落名之间是有直接对应关系的,
还有一部分, 属性有多个值, 比如 `-callback`, 这些值集合到一起,
放在一个段落中的. 总之在 Erlang 中理解模块属性, 是相当直观的.

例如下面的 Erlang 代码

```erlang
-module(hello).
-export([say_hi/1,say_bye/1]).
...
```

不难推测出, `.beam` 文件中, 记录模块名的位置上记录的内容一定就是 `hello`.
而记录模块导出函数的段落中, 一定有 `say_hi` `say_bye` 这样的内容.

对应的 Elixir 代码应该是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule(:hello, [do: (
  def say_hi(a), do: ...
  def say_bye(a), do: ...
)])
```

Elixir 中, 源文件和字节码文件直接不在是一一对应, 而且模块属性的内容,
分散到这个文件中, 而不是想 Erlang 那样集中到代码的头部了.
所以从 Elixir 代码来理解模块属性, 就不那么直观了.

### 内建属性

| Erlang 预定义的属性示例                | 意义                                                                                                              | Elixir对应结构                             |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| `-module(MODULE_NAME)`                         | 设置模块的名字                                                                                               | `defmodule`                                    |
| `-export(Functions)`                           | 模块中导出函数                                                                                               | `def`                                          |
| `-import(Module,Functions)`                    | 导入其他模块中的函数                                                                                      | `import Module, only: [Functions]`             |
| `-compile(Options)`                            | 模块中指定编译选项                                                                                         | `@compile([options])`                          |
| `-vsn(Vsn)`                                    | 模块版本                                                                                                        | `@vsn("VSN")`                                  |
| `-on_load(Function)`                           | 指定模块加载时调用的函数名                                                                             | `@on_load ...`                                 |
| `-nifs(Functions)`                             | 指定了模块中定义的那些函数, 可能会被作为外部语言接口(NIF)使用 `erlang:load_nif/2` 加载 | TODO                                           |
| `-behaviour(Behaviour)`                        | 指定模块实现了行为(Behaviour).                                                                             | `@behaviour` `@impl`                           |
| `-callback Name(Argument) -> Result.`          | 定义Behaveiour 的回调函数                                                                                    | `@callback function_spec`                      |
| `-record(Record, Fields).`                     | 定义记录                                                                                                        | Record 模块中的 `defrecord`                |
| `-include("SomeFile.hrl").`                    | 包含预处理                                                                                                     | `require`                                      |
| `-define(Macro, Replacement).`                 | 定义宏                                                                                                           | `defmacro`, `defmacrop`                        |
| `-file(File,Line)`                             | 修改了预定义的宏 `?File` 和 `?Line` 的值.                                                                | `@file`                                        |
| `-type my_type() :: other_have_defined_type()` | 类型定义                                                                                                        | `@type my_type() :: other_have_define_type()`  |
| `-spec function(type()) -> return_type()`      | 为 `function` 指定规范                                                                                         | `@spec spec function(type()) -> return_type()` |

<!-- livebook:{"break_markdown":true} -->

Elixir 的与 Erlang 对应的内建模块属性, 除了 **模块, 函数, 宏,
结构以及记录** 的定义是使用特定的宏外, 其他的模块属性都使用 `@` 的语法.

编程语言中, 以 `@` 作为语法结构的, 除了 Elixir 的模块属性外, 还有别的几种用法,
而且这几种用法在 Elixir 中某种程度上, 也都可以由模块属性来实现.

### Java 注解(Anotation)

Java 中使用注解语法, 为代码添加元数据.
Elixir 中, 以下的模块属性用来完成类似的工作.
`@deprecated`, `@moduledoc`,`@doc`, `@impl`,`@typedoc`.
但是这里的语法稍微不同, Elixir 中, 模块属性后面, 必须给定合适的数据类型(term),
Java 的注解后面基本不用, 注解的作用对象就是其后的代码或字段.
例如下面两个片段都是表面 API 不在不支持:

```java
@Deprecated
int parser(String str){
  ....
}
```

对应的 Eixir 中的代码是:

<!-- livebook:{"force_markdown":true} -->

```elixir
@deprecated "Use `String.parser/1` replace."
def parser(str) do
  ...
end
```

除了字母大小写的不同外, 需要注意的是, Elixir 的模块属性是必须有对应的属性值的.
Java 的注解只是表明了, 后面的 API 被遗弃了, 之于应该用那个新的 API 来代替,
只能靠代码外的文档来补充了. Elixir 中情况不一样, 运行时发出 API 过期的警告后,
立刻就能给出具体的建议. Java 中注释如果要做的这一点,
就必须使用带有参数的注释类型才可以.

### Python 修饰器

Python 中的修饰器语法, 也就通过高阶函数提供的语法糖, 
来简化函数或方法定义中的重复性的模板内容. 例如下面的代码:

```python
def trace(fun):
  def warper(arg):
    print("call %s(\"%s\")" %(fun.__name__, arg) )
    ret = fun(arg)
    print("get: %s\n"%ret)
    return ret
  return warper

@trace
def hello(a):
  return "Hello, %s" %(a)

@trace
def hi(a):
  return "Hi, %s" %(a)

hw = hello("world")
hi_white = hi("Mr. White")
print(hw)
print(hi_white)
```

其输出为:

> call hello("world")
> get: Hello, world
> 
> call hi("Mr. White")
> get: Hi, Mr. White
> 
> Hello, world
> Hi, Mr. White

Elixir 不支持修饰器. 但是修饰器, 本质上不过是高阶函数生产新函数来代理被修饰的函数.
Elixir 强大的元编程能力, 在借助编译相关的模块属性钩子(Hook): `@before_compile`, `@on_defination`, 是可以实现 Python 的修饰器. 实际上, 早就有人做到了这一点[^decorator].

[^decorator]: https://github.com/arjan/decorator

<!-- livebook:{"break_markdown":true} -->

首先安装我们需要的库: `decorator`

```elixir
Mix.install(decorator: "~> 1.2")
```

然后定义我们的修饰器:

```elixir
defmodule PrintDecorator do
  use Decorator.Define, print: 0

  def print(body, context) do
    quote do
      IO.puts("Function called: " <> Atom.to_string(unquote(context.name)))
      unquote(body)
    end
  end
end
```

上面定义的修饰符函数 `print`,
当其他函数被修饰后, 再调用被修饰后的函数, 
函数的返回结果和修饰前没什么不一样,
但是在函数返回结果之前, 会首先打印出 "Function called: <fun_name>" 这样的文本.

现在让我们看看如何使用修饰符函数 `print` 来修饰其他的函数.

```elixir
defmodule DecoratorUseModule do
  use PrintDecorator

  @decorate print()
  def square(a) do
    a * a
  end
end

alias DecoratorUseModule, as: DUM
4 = DUM.square(2)
```

执行上面的代码, 我们看到控制台中输出了 `Function called: square`,
而且调用被修饰后的 `square` 并没有改变修饰前函数的值.

<!-- livebook:{"break_markdown":true} -->

### Ruby 的对象的属性

Elixir 的模块属性, 还和 Ruby 中的定义实例属性的语法类似.
Ruby 中, 用 `@age` 这样的语法来定义实例的属性的.
Elixir 大量的语法形式是借鉴自 Ruby 的,
所以一度我也为这两个概念联系和区别而困惑.

我认为这个语言设计可能是故意的. 
和 Erlang 中自定义属性不一样, Elixir 中的自定义模块属性,
除了可以作为模块的元数据来使用外, 还有更加实用的功能.

1. 在编译时, 可以作为在元编程的临时结果的存储所;
2. 作为模块内的常量.

例如, 在上面我们用的 `decorator` 库中,
当编译回调钩子执行 `on_defination/6` 后,
在被修饰的函数所在的模块中添加了 `:decorated` 属性[^on_defination].
在函数被编译器之前, `before_compile/2` 宏被调用,
在这个宏执行的过程, 获取了获取了 `on_defination` 运行后,
添加到模块中的 `:decorated` 属性值,
然后就把这个属性从模块中删除了[^before_compile].
所以要这样处理, 是因为 `:decorated` 记录的内容需要被处理,
而不是作为模块的元信息记录到字节码中.

[^on_defination]: 见源码[第 20 行](https://github.com/arjan/decorator/blob/a32053ae884014320940d2a8cefe55181203db93/lib/decorator/decorate.ex#L20)
[^before_compile]: 见源码[第37, 38行](https://github.com/arjan/decorator/blob/a32053ae884014320940d2a8cefe55181203db93/lib/decorator/decorate.ex#L37)

最后的一个问题就是, 为什么不可以使用模块作用域的变量来做中转呢?
这是因为 Elixir 的值不变性, 使得函数或宏运行后改变的变量值,
不能作为副作用, 反应到整个模块可见的变量中.
换句话说, Elixir 的变量在嵌套作用域是只读而不可写的.

模块的属性在编译时是整个模块中可读可写的, 所以刚好可以用来保存编译 Hook 的副作用.

Elixir 的模块属性和 Ruby 的对象属性, 相联系之处在于它们都是属性,
都是可以用来表示相应的概念的状态; 而区别在于, 它们的生命周期不一样.
Elixir 的模块属性, 活跃于编译时, 随后就蛰伏起来了; 而 Ruby 的实例属性,
存活于运行时, 伴随着对象的生命周期.

Ruby 中用类属性来表示整个类都共享的值, 其使用的语法为 `@@classAttr`.
Elixir 模块内是不支持常量定义的, 模块属性可以用来比对 Ruby 的类属性,
来充当模块内的常量.

假如我们要定义一个数学相关的模块, 其中涉及到角度于弧度的转化,
那么我们可以这样来写:

```elixir
defmodule Angle do
  @pi 3.14
  def convert({:degrate, v}) do
    @pi / 180 * v
  end

  def convert({:radian, v}) do
    180 / @pi * v
  end
end
```

这样做的好处是显然的, 当我们决定提高计算的进度,
需要使用更多位数的常量 $\pi$ 的时候,
在把模块属性作为模块内常量的情况下, 
我们只需要修改一个地方就能完成代码的升级了.

## 模块中的内容

上面几个小结中我们知道, 模块中除了 `def*` 系列宏之外, 还可以使用其他语法结构.
函数必须定义在模块中, 这是来自 Erlang 的规定, 所以 `def` `defp` 只能在模块中使用,
非常容易理解. 但是为什么结构, 记录, 异常这些定义也必须在模块中呢?
`defstruct`, `defexpect` 以及 `defrecord` 这些宏到底做了什么呢?

这探索模块的属性的时候,为了理解 `.beam` 文件, 我借助了 `:beam_lib` 库提供的反汇编功能.
但是对 `defstruct`, `defexpect` 以及 `defrecord` 的探索,
我们不需要那么底层的工具. Elixir 的 `Module` 和 iex 提供的工具所展示的信息,
足够我们回答以上的问题了.
实际上, 如果我们阅读的足够仔细的话, 这个问题, 实际上都不用探索.

他们对应的文档中都给出了探案. 比如在 `defstruct` 文档中[^defstruct], 就将了
`defstruct` 还在模块中定义了 `__struct__/0` 函数.
正是因为 `defstruct` 被调用的时候, 会向被调用者的上下文中注入函数,
而函数有必须定义在模块中, 所以 `defstruct` 被调用的上下文就只能被限制为在模块内了.

[^defstruct]: 见[Kernel 模块文档 destruct/1 相关内容](https://hexdocs.pm/elixir/1.13.4/Kernel.html#defstruct/1)

和 `defstruct` 类似, 但是 `defrecord` 在 Elixir 中很少使用, 
但是它做的工作实际上和 `defstruct` 一样, 只是他们选用的表示数据的容器类型不同.
`defstruct` 选 map 作为组合数据的基础; 而 `defrecord` 以元组为基础.
这是他们之间的不同, 其相同点在于这两个宏被调用的时候,
都要向调用它的上下文中注入函数. 所以 `defrecord` 也必然的就被限制在了模块中了.
而这些在 `defrecord` 的文档中也是清楚标明了的.

`defexpect` 所以被限制在模块内, 原因更容易理解. 因为它是基于 `defstruct` 工作的,
或者是它是特化的 `defstruct`; `defstruct` 都不现在在模块呢,
`defexpect` 都被限制于模块内, 当然也就顺利成章了.

## 协议和行为

上一节, 我们讨论了为什么有些宏, 被限制只能在模块中使用.
在上面的讨论中, 有意无意的, 我们把 `defmodule` 这个宏,
和 OTP 平台的一个 `.beam` 文件看作了是同样的东西,
或者说, 我的思维中, 似乎认定了 Elixir 中,
只有 `defmodule` 这个宏可以被编译器编译为字节码文件.

但是这种认识是错误的. `defprotocol` 和 `defimple` 宏的调用结果,
也一样是产生 `.beam` 文件的.

Elixir 在这里的处理和 Java 中的处理非常的类似.
我们可以用下表来做个比较.

| 对应项                 | Java                                   | Elixir                              |
| ------------------------- | -------------------------------------- | ----------------------------------- |
| 字节码后缀           | `.class`                               | `.beam`                             |
| 最常用的编译单元  | 类定义                              | 模块定义                        |
| 嵌套处理              | 类定义可以嵌套, 字节码平铺 | 模块可以嵌套, 字节码平铺 |
| API                       | 接口(Interface)                      | 协议(Protocol)                    |
| API 复用代码的机制 | 抽象类                              | 行为                              |

在 Java 语言中, 类和接口的定义都内会能编译为 `.class`文件.
在 Elixir 中模块定义和协议定义也都要产生对应的字节码文件.

在上表中, 我把 Elixir 中的行为和 Java 中的抽象类做对比,
因为它们都是为了在定义 API 的时候最大化的复用代码,
这是从语言外部对比来看.

如果从 Elixir 语言内部来看, 行为(Behavior) 本质上是
`defmodule` 与 `defprotocl` 的混合.

有关协议和行为的更多讨论, 见后面章节[协议和行为](./chy.protocol_and_behaviuor.livemd)

## 代码是如何被编译为字节码的

Erlang 代码, 函数对应的代码被编译到可 `.beam` 字节码中的 `Code` 段中.
函数 `:beam_lib.chunks(Module,[:abstract_code])` 可以用来查看编译后字节的抽象码.

在 Erlang 中也没有私有函数和非私有函数的说法, 只有导出函数, 函数和私有函数,
在 `Code` 段中的表示是没有差别的. `def` 和 `defp` 的差别, 反映在模块属性 `export` 中.

但是 Elixir 的宏呢? 要知道 Elixir 的宏可是运行在编译时的,
通过分析 Elixir 反汇编后的抽象码, 可以知道:
Elixir 的宏也是以函数的形式编译到字节码中的, 在字节码中,
宏的名字被统一加了 `MACRO-` 的前缀; 而且多了一个表示调用者上下文的参数.
