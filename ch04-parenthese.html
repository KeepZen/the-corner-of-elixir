<!DOCTYPE html>
<html lang="cn-zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.4">
    <meta name="project" content="the_corner_of_elixir v4.0.0">

      <meta name="author" content="Keep Zen">

    <title>第四章 括号 — the_corner_of_elixir v4.0.0</title>
    <link rel="stylesheet" href="dist/elixir-b6f1ed5df9b1d42a7309.css" />

    <script src="dist/sidebar_items-a0514d8df2.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-bd1cb213813bf4825aa2.js"></script>

<style>
  a.footnote {
    vertical-align: super;
  }
  a.reversefootnote {
    display: inline-block;
    text-indent: -9999px;
    line-height: 0;
  }
  a.reversefootnote:after {
    content: '↩'; /* or any other text you want */
    text-indent: 0;
    display: block;
    line-height: initial;
  }
</style>

<script>
MathJax = {
tex: {
inlineMath: [['$', '$']]
}
};
</script>
<script id="MathJax-script" async
src="./assets/tex-chtml.js">
</script>

<script src="assets/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({ startOnLoad: false });
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition, function (svgSource, bindListeners) {
    graphEl.innerHTML = svgSource;
    bindListeners && bindListeners(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>

  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="keepzen.github.io/the-corner-of-elixir" class="sidebar-projectName" translate="no">
the_corner_of_elixir
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v4.0.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/keepzen/the-corner-of-elixir/blob/main/cn/ch04.parenthese.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>第四章 括号</span>
</h1>

<h2 id="本章的目的" class="section-heading">
  <a href="#本章的目的" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">本章的目的</p>
  </a>
  本章的目的
</h2>
<p>在这一章我们讨论的是 <strong>语法上可以如何做</strong>, 而 <strong>不是实际编码上应该怎么做</strong>.
可以做是一个硬规则, 是面向编译器的; 应该怎么做是一个规范, 是面向程序员的.
所以很多地方, 在讨论完可以如何做后, 我又用黑体给出了社区推荐的做法,
也就是应该如何作.</p><p>本章讨论可以做的方法绝大部分, 不符合社区的推荐做法. 一边展示不推荐的做法,
一边规劝大家不要这样做, 这看起来似乎是在左右互博,自相矛盾.
所以这样做, 是为了搞清楚所以然 --- --- 社区给出这些规范的所以然, 也就是规范背后的原因.</p><p>当真正的理解了什么是可以做的, 以及什么必须做的时候, 才能理解规范所以如此的原因.</p><h2 id="使用括号改变优先级" class="section-heading">
  <a href="#使用括号改变优先级" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">使用括号改变优先级</p>
  </a>
  使用括号改变优先级
</h2>
<p>使用括号改变优先级, 这是最普通的括号的用法. 这和我们在数学课堂上使用括号的情形一样.
例如数学公式 $a\times{}(b+c)$, 对应的程序表达式就是 <code class="inline">a*(b+c)</code>.
如果要消除括号, 那么需要调整代码, 并需要引入中间变量. 例如上面的等价的表达式,
可以写作 <code class="inline">tem=b+c</code> 和 <code class="inline">a*tem</code> 两个表达式.
但是这里有一个前提: 最初的表达式, 在一个块环境中. 因为多个表达式, 必须在块环境中.</p><h2 id="括号与匿名函数定义" class="section-heading">
  <a href="#括号与匿名函数定义" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">括号与匿名函数定义</p>
  </a>
  括号与匿名函数定义
</h2>
<h3 id="使用-fn-end-定义匿名函数" class="section-heading">
  <a href="#使用-fn-end-定义匿名函数" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">使用-fn-end-定义匿名函数</p>
  </a>
  使用 <code class="inline">fn ... -&gt; end</code> 定义匿名函数
</h3>
<p>当我们使用 <code class="inline">fn ... -&gt; end</code> 来定义匿名函数的时候, 括号是可选的.</p><pre><code class="makeup elixir" translate="no"><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-1">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">pi</span><span class="p" data-group-id="3218243237-2">(</span><span class="p" data-group-id="3218243237-2">)</span><span class="w"> </span><span class="k" data-group-id="3218243237-1">end</span><span class="w">
</span><span class="n">e</span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-3">fn</span><span class="w"> </span><span class="p" data-group-id="3218243237-4">(</span><span class="p" data-group-id="3218243237-4">)</span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">exp</span><span class="p" data-group-id="3218243237-5">(</span><span class="mi">1</span><span class="p" data-group-id="3218243237-5">)</span><span class="w"> </span><span class="k" data-group-id="3218243237-3">end</span><span class="w">
</span><span class="n">pi</span><span class="o">.</span><span class="p" data-group-id="3218243237-6">(</span><span class="p" data-group-id="3218243237-6">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-7">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;pi.()&quot;</span><span class="p" data-group-id="3218243237-7">)</span><span class="w">
</span><span class="n">e</span><span class="o">.</span><span class="p" data-group-id="3218243237-8">(</span><span class="p" data-group-id="3218243237-8">)</span><span class="w">  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-9">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot; e.()&quot;</span><span class="p" data-group-id="3218243237-9">)</span><span class="w">

</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-10">fn</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k" data-group-id="3218243237-10">end</span><span class="w">
</span><span class="n">add_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-11">fn</span><span class="w"> </span><span class="p" data-group-id="3218243237-12">(</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p" data-group-id="3218243237-12">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k" data-group-id="3218243237-11">end</span><span class="w">
</span><span class="n">id</span><span class="o">.</span><span class="p" data-group-id="3218243237-13">(</span><span class="mi">1</span><span class="p" data-group-id="3218243237-13">)</span><span class="w">    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-14">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;   id.(1)&quot;</span><span class="p" data-group-id="3218243237-14">)</span><span class="w">
</span><span class="n">add_1</span><span class="o">.</span><span class="p" data-group-id="3218243237-15">(</span><span class="mi">1</span><span class="p" data-group-id="3218243237-15">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-16">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;add_1.(1)&quot;</span><span class="p" data-group-id="3218243237-16">)</span><span class="w">

</span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-17">fn</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="3218243237-17">end</span><span class="w">
</span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3218243237-18">fn</span><span class="w"> </span><span class="p" data-group-id="3218243237-19">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="3218243237-19">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="3218243237-18">end</span><span class="w">
</span><span class="n">add</span><span class="o">.</span><span class="p" data-group-id="3218243237-20">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="3218243237-20">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-21">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;add.(1,2)&quot;</span><span class="p" data-group-id="3218243237-21">)</span><span class="w">
</span><span class="n">sub</span><span class="o">.</span><span class="p" data-group-id="3218243237-22">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="3218243237-22">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="3218243237-23">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;sub.(1,2)&quot;</span><span class="p" data-group-id="3218243237-23">)</span></code></pre><p>上面的代码中, 对于零元, 一元和二元匿名函数, 用带括号和不带括号两种样式分别做了定义.
可以看出, 在定义匿名函数的时候, 括号完全是可选的.</p><p><strong>社区的推荐</strong>: 使用 <code class="inline">fn...-&gt;end</code> 定义匿名函数的时候, 不用括号来包裹参数列表.</p><p>那么为什么 <code class="inline">fn...-&gt;end</code> 定义匿名函数的时候可以不用括号呢?</p><p>从形式来看, <code class="inline">-&gt;</code> 是参数列表结束而函数分句开始的标识.
所以不需要一个额外的括号来界定参数什么时候开始什么时候结束.</p><h3 id="使用函数捕获操作符-定义匿名函数" class="section-heading">
  <a href="#使用函数捕获操作符-定义匿名函数" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">使用函数捕获操作符-定义匿名函数</p>
  </a>
  使用函数捕获操作符 &amp; 定义匿名函数
</h3>
<p>使用函数捕获操作符 <code class="inline">&amp;</code> 定义定义函数的时候, <code class="inline">()</code> 的作用只限于调整代码的优先级.</p><p>而 Elixir 中函数捕获操作符 <code class="inline">&amp;</code> 的优先级只高于 <code class="inline">=&gt;</code>, <code class="inline">|</code>, <code class="inline">::</code> <code class="inline">&lt;-</code> 和 <code class="inline">\\</code>
这几个操作符, 而这几个操作符, 又都是在特殊的环境下才有意义的, 所以几乎可以说,
函数捕获操作符 <code class="inline">&amp;</code> 是最低的优先级的操作符.</p><p>因此, 对定义匿名函数的表达式 <code class="inline">&amp;(expression)</code> 来说,
因为函数捕获操作符 <code class="inline">&amp;</code> 的优先级最低, 而且在 <code class="inline">expression</code> 中不允许嵌套函数捕获表达式,
因此 <code class="inline">expression</code> 中的其他的操作符, 优先级都比函数捕获操作符 <code class="inline">&amp;</code> 的高. 
所以, 在表达式 <code class="inline">&amp;(expression)</code> 中有没有括号, 表达式的计算顺序都一样.
换句话说, 这里的括号就是多余的, 可以省略.</p><p>当需要把定义的函数赋值给一个变量的时候, 匹配操作符 <code class="inline">=</code> 的优先级高于函数捕获操作符 <code class="inline">&amp;</code>,
但是匹配操作符 <code class="inline">=</code> 是右结合的, 会优先完成左值的计算.
所以使用函数捕获操作符, 在匹配操作符 <code class="inline">=</code> 右侧定义匿名函数的时候,
像表达式 <code class="inline">a=(&amp; expression)</code> 这样, 其中的括号也可以省略.
下面的代码片段, 展示了这种这种情形.</p><pre><code class="makeup elixir" translate="no"><span class="n">id2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w">
</span><span class="n">add_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="w">
</span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="ni">&amp;2</span><span class="w">
</span><span class="n">id2</span><span class="o">.</span><span class="p" data-group-id="8628531995-1">(</span><span class="mi">1</span><span class="p" data-group-id="8628531995-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="8628531995-2">(</span><span class="ss">label</span><span class="p">:</span><span class="w">    </span><span class="s">&quot;  id2.(1)&quot;</span><span class="p" data-group-id="8628531995-2">)</span><span class="w">
</span><span class="n">add_1</span><span class="o">.</span><span class="p" data-group-id="8628531995-3">(</span><span class="mi">1</span><span class="p" data-group-id="8628531995-3">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="8628531995-4">(</span><span class="ss">label</span><span class="p">:</span><span class="w">  </span><span class="s">&quot;add_1.(1)&quot;</span><span class="p" data-group-id="8628531995-4">)</span><span class="w">
</span><span class="n">sum</span><span class="o">.</span><span class="p" data-group-id="8628531995-5">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8628531995-5">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="8628531995-6">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;sum.(1,2)&quot;</span><span class="p" data-group-id="8628531995-6">)</span><span class="w">
</span><span class="n">sub</span><span class="o">.</span><span class="p" data-group-id="8628531995-7">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8628531995-7">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="8628531995-8">(</span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;sub.(1,2)&quot;</span><span class="p" data-group-id="8628531995-8">)</span></code></pre><p>所以和 <code class="inline">fn -&gt; end</code> 语法定义匿名函数情形几乎一样, 使用函数捕获操作符 <code class="inline">&amp;</code>
定义匿名函数的也不需要小括号, 但是这里有一点点的不同.</p><ol><li><p><code class="inline">fn</code> 和 <code class="inline">end</code> 是作为保留字存在的, 优先级高于其他的操作符.</p></li><li><p>匿名函数可以作为参数传递给其他高阶函数</p><p> 当把匿名函数通过管道操作符 <code class="inline">|&gt;</code>, 传递给其他高阶函数的时候,
 使用函数捕获操作符 <code class="inline">&amp;</code> 定义的匿名函数就必须使用括号,
 因为管道操作符符 <code class="inline">|&gt;</code> 的优先级高于函数捕获操作符 <code class="inline">&amp;</code>.</p></li></ol><p>例如:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="4007531219-1">(</span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;3</span><span class="p" data-group-id="4007531219-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">apply</span><span class="p" data-group-id="4007531219-2">(</span><span class="p" data-group-id="4007531219-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="4007531219-3">]</span><span class="p" data-group-id="4007531219-2">)</span></code></pre><p>因为管道操作符 <code class="inline">|&gt;</code> 优先级高于函数捕获操作符 <code class="inline">&amp;</code>,
所以要表达, 把匿名函数作为管道操作符 <code class="inline">|&gt;</code> 的左操作数, 这样的意图,
就必须为函数捕获操作符 <code class="inline">&amp;</code> 定义匿名函数的表达式加上括号.</p><p>现在我们分析一下, 表达式 <code class="inline">&amp; &amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])</code> 的语义.</p><pre><code class="makeup elixir" translate="no"><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;3</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">apply</span><span class="p" data-group-id="9500939688-1">(</span><span class="p" data-group-id="9500939688-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="9500939688-2">]</span><span class="p" data-group-id="9500939688-1">)</span><span class="w">
</span><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_function</span><span class="p" data-group-id="9500939688-3">(</span><span class="n">fun</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="9500939688-3">)</span></code></pre><p>所以, 这个表达式 <code class="inline">&amp; &amp;1+&amp;2+&amp;3 |&gt; apply([1,2,3])</code> 计算后的结果为一个匿名的三元函数.
如果我们以参数 <code class="inline">1,2,3</code> 来调用这个匿名函数, 得到一个错误:</p><blockquote><p>** (BadFunctionError) expected a function, got: 6.</p></blockquote><p>为什么会这样呢?</p><ol><li>函数捕获操作符 <code class="inline">&amp;</code> 操作优先级最低, 所以整个表达式等价于
<code class="inline">&amp;(&amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3]))</code>.</li><li>加法运算符 <code class="inline">+</code> 优先级高于管道运算符 <code class="inline">|&gt;</code>, 所以
<code class="inline">&amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])</code> 等价于 <code class="inline">(&amp;1 + &amp;2 + &amp;3) |&gt; apply([1,2,3])</code>.</li><li>因此整个表达式的意思就是: 这是一个三元匿名函数(<code class="inline">&amp;1,&amp;2,&amp;3</code>),
参数求和后 (<code class="inline">&amp;1+ &amp;2 + &amp;3</code>), 把结果作为第一个参数传递给 <a href="https://hexdocs.pm/elixir/Kernel.html#apply/2"><code class="inline">apply/2</code></a>.</li></ol><p>虽然我们获得了一个三元的匿名函数, 但是这个匿名函数无论我们输入的参数是什么,
都是要报错的.</p><p>三个参数按加法计算, 所以接受的只能是数值类型, 计算后的结果也只能是 <strong>数值</strong>,
但是 <a href="https://hexdocs.pm/elixir/Kernel.html#apply/2"><code class="inline">apply/2</code></a> 要求的第一个参数是一个 <strong>函数</strong>,
所以无论我们以什么参数来调用这个匿名函数, 其结果都是抛出报错.</p><p><strong>结论</strong>: 在用函数捕获操作符 <code class="inline">&amp;</code> 定义匿名函数时, 不需要括号的参与,
但是要直接把函数捕获操作符 <code class="inline">&amp;</code> 定义的函数, 通过管道操作符 <code class="inline">|&gt;</code> 传递给其他函数的时候,
因为涉及优先级的问题, 所以必须使用括号, 把函数捕获操作符的优先级提高.</p><p>但是在使用函数捕获操作符 <code class="inline">&amp;</code> 的时候, 基于代码的可读性, 社区的推荐使用括号.</p><p><strong>社区推荐做法</strong>: 使用 <code class="inline">&amp;</code> 定义匿名函数的时候, 使用括号把<strong>表达式括起来</strong>,
即使很多时候语法上是不必要的.</p><p>也就是说, 按照社区的规范上面的代码中对匿名函数 <code class="inline">id2</code>, <code class="inline">add_2</code> 等函数的定义, 应该写作:</p><pre><code class="makeup elixir" translate="no"><span class="n">id2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w">
</span><span class="n">add_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="3427572428-1">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3427572428-1">)</span><span class="w">
</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="3427572428-2">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="p" data-group-id="3427572428-2">)</span><span class="w">
</span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="3427572428-3">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="ni">&amp;2</span><span class="p" data-group-id="3427572428-3">)</span></code></pre><h2 id="括号与命名函数定义" class="section-heading">
  <a href="#括号与命名函数定义" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">括号与命名函数定义</p>
  </a>
  括号与命名函数定义
</h2>
<p><a href="https://hexdocs.pm/elixir/Kernel.html#def/2"><code class="inline">def/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#defp/2"><code class="inline">defp/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#defmacro/2"><code class="inline">defmacro/2</code></a> 和 <a href="https://hexdocs.pm/elixir/Kernel.html#defmacrop/2"><code class="inline">defmacrop/2</code></a> 用来在模块中定义函数,
私有函数, 宏以及私有宏. 这里为了论述的方便, 用函数指代命名函数, 私有函数,
宏以及私有宏.</p><h3 id="函数的调用格式" class="section-heading">
  <a href="#函数的调用格式" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数的调用格式</p>
  </a>
  函数的调用格式
</h3>
<p>查看文档可以知道这些宏接受的第一个参数叫做 <code class="inline">call</code>,
而且我们知道这些宏都有一个同名的一元宏, 其功能就是定义函数或宏的签名,
所以 <code class="inline">call</code> 在其他语言中的对应物, 就是函数签名 (function signature) 
或者函数头 (function head).</p><p>但是为什么不叫函数签名或函数头, 而叫 call 呢? 用一个动词命名参数名,
这多少还是有悖正常的思维. 其中又什么深意吗?</p><p>还真是的, 我在 Elixir 论坛中, 得到了答案: 这些宏接受的第一个参数,
必须是函数的调用的形式. 或者说, 代码 <code class="inline">def fun(a,b) do...end</code>,
是在编译时调用 <a href="https://hexdocs.pm/elixir/Kernel.html#def/2"><code class="inline">def/2</code></a>, 这个函数接受两个参数, 第一个是 <code class="inline">fun(a,b)</code>
这个函数调用的返回值, 当然这个函数不存在.
<code class="inline">def</code> 会解析出函数名, 参数列表, 并按照我们的调用的方式, 为我们创建这个函数.</p><p>现在让我们来看看函数调用. 函数调用有两种形式:</p><ol><li><code class="inline">fun_name arg1, arg2</code></li><li><code class="inline">fun_name(arg1, arg2)</code></li></ol><p>所以 <code class="inline">call</code> 参数, 也就这些宏接受的第一个参数, 也必须符合这两种模式之一.
要特别注意第二种形式, 括号和函数名之间不能有空格的.</p><p>但是为什么要有两种形式呢? 大部分的编程语言, 实际上都只支持第 2 种形式.
Elixir 所以支持第 1 种形式有两个原因:</p><ol><li>零元函数调用, 省略括号, 看起来像常数的引用, 对于纯函数来说, 零元函数表现的也真的就像一个常数.</li><li>宏忽略小括号, 可以更像其他语言的关键字</li></ol><p>Elixir 很多功能是宏提供的, 这就使得必须支持宏调用的时候可以省略括号,
否则就需要使用大量的嵌套的括号, 这会使得代码看起来非常的繁琐.
例如这样的代码:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="p" data-group-id="2067813325-1">(</span><span class="nc">M</span><span class="p">,</span><span class="w">
  </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2067813325-2">(</span><span class="w">
    </span><span class="kd">def</span><span class="p" data-group-id="2067813325-3">(</span><span class="w">
      </span><span class="n">fun_name</span><span class="p" data-group-id="2067813325-4">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="2067813325-4">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2067813325-5">(</span><span class="w">
        </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p" data-group-id="2067813325-5">)</span><span class="p" data-group-id="2067813325-3">)</span><span class="p" data-group-id="2067813325-2">)</span><span class="p" data-group-id="2067813325-1">)</span></code></pre><p>看起来真正像 M 表达式<a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a>啊.</p><h3 id="函数体" class="section-heading">
  <a href="#函数体" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数体</p>
  </a>
  函数体
</h3>
<p><code class="inline">def*/2</code> 这几个宏的, 第一个参数 <code class="inline">call</code> 我们已经学习了,
他们的第二个参数是 <code class="inline">expression</code>, 也就是表达式. 但是实际上必须是 <code class="inline">do-block</code>,
其他的表达式, 都是语法错误, 比如我们就不能这样写代码 <code class="inline">def add(a,b), a+b</code>.</p><p>也就说, 这几个 <code class="inline">def*/2</code> 宏接受的第二个参数必须是一个 <code class="inline">[do: expression]</code>.
但是需要注意的是, <code class="inline">:do</code> 的值只能是一个表达式, 当函数体有不只一个表达式的时候,
就需要用代码块, 或者说块表达式.</p><p>而 Elixir 中定义函数体的代码块的有以下两种方式:</p><ol><li><code class="inline">do...end</code> 直接创建的是一个 <code class="inline">do-block</code>.</li><li>还可以使用 <code class="inline">()</code> 作为块的分界符, 换行或分号作为语句之间分隔符, 来创建块表达式.
也就是说, 还可以使用 <code class="inline">[do: (...;...)]</code> 来创建了一个 <code class="inline">do-block</code>.</li></ol><h3 id="函数定义" class="section-heading">
  <a href="#函数定义" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数定义</p>
  </a>
  函数定义
</h3>
<p>这几个 <code class="inline">def*/2</code> 宏, 2 个参数各有两种风格, 总共就有 4 种组合.
但是这四种组合中, <strong>不带括号的函数调用</strong> 与 <strong><code class="inline">[do: (...)]</code></strong> 的组合<strong>不完全支持</strong>.
例如下面的代码:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">FunDefine</span><span class="w"> </span><span class="k" data-group-id="0250114161-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">add</span><span class="p" data-group-id="0250114161-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="0250114161-2">)</span><span class="w"> </span><span class="k" data-group-id="0250114161-3">do</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
  </span><span class="k" data-group-id="0250114161-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sub</span><span class="p" data-group-id="0250114161-4">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="0250114161-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">div</span><span class="p" data-group-id="0250114161-5">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="0250114161-5">)</span><span class="w"> </span><span class="k" data-group-id="0250114161-6">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="0250114161-7">(</span><span class="n">a</span><span class="p" data-group-id="0250114161-7">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="0250114161-8">(</span><span class="n">b</span><span class="p" data-group-id="0250114161-8">)</span><span class="w"> </span><span class="k" data-group-id="0250114161-9">do</span><span class="w">
      </span><span class="nc">Kernel</span><span class="o">.</span><span class="n">div</span><span class="p" data-group-id="0250114161-10">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="0250114161-10">)</span><span class="w">
    </span><span class="k" data-group-id="0250114161-9">else</span><span class="w">
      </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="w">
    </span><span class="k" data-group-id="0250114161-9">end</span><span class="w">
  </span><span class="k" data-group-id="0250114161-6">end</span><span class="w">

  </span><span class="c1"># def multiply a, b, do: a * b</span><span class="w">
  </span><span class="c1"># def multiply a, b  do: a * b</span><span class="w">
  </span><span class="c1"># 注意这里没有逗号  ^, 可是依旧不能通过编译</span><span class="w">
</span><span class="k" data-group-id="0250114161-1">end</span></code></pre><p>我试图通过定义 <code class="inline">add</code>, <code class="inline">sub</code>, <code class="inline">div</code> 和 <code class="inline">multiply</code> 来演示函数定义的全部 4 种组合.
但是第 4 种样式报错, 为什么呢?
<code class="inline">def multiply a, b, do: a * b</code> 不正确的原因在于,
词法分析器无法判断<strong>函数参数列表</strong>什么时候结束. 那么对于代码:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="6455811759-1">do</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="k" data-group-id="6455811759-1">end</span></code></pre><p>词法分析器是怎么就能知道参数列表什么时候结束呢? 这就是 <code class="inline">do</code> 的作用了.
否则, 如果编译器只是通过 <code class="inline">:do</code> 前面是不是有逗号, 来判断参数定义是否结束的话,
那么 <code class="inline">def multiply a,b do: (a*b)</code> 就应该通过编译的.
现在这样的代码不能通过编译, 说明在编译的词法分析阶段, 对 <code class="inline">do</code> 是做了特殊处理.
这是正是 <code class="inline">do</code> 作为保留字的原因, <code class="inline">do</code> 在这里并没有引入控制结构,
它充当了参数列表与函数体之间的分界符, 并创建了 <code class="inline">do-block</code>.</p><p>上面我们说, 第四种组合不被完全支持, 换句话说, 这种组合方式得到了部分支持的.
那么什么时候支持这种格式呢? 那就是定义无参数函数的时候.
例如下面的代码, 语法上是正确的:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">e</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">exp</span><span class="p" data-group-id="5328391818-1">(</span><span class="mi">1</span><span class="p" data-group-id="5328391818-1">)</span></code></pre><p><strong>推荐规范</strong>: 定义函数或宏的时候, 零元函数除外, 推荐带有括号的函数头格式.</p><h2 id="函数调用" class="section-heading">
  <a href="#函数调用" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">函数调用</p>
  </a>
  函数调用
</h2>
<p>命名的函数调用可以省略括号, 而匿名函数调用的时候必须使用括号.
函数调用的时候, 如果使用括号, <strong>函数名和括号之间不能有空白</strong>.</p><h3 id="命名函数的省略括号调用" class="section-heading">
  <a href="#命名函数的省略括号调用" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">命名函数的省略括号调用</p>
  </a>
  命名函数的省略括号调用
</h3>
<p>我认为允许命名函数和私有函数调用可以省略括号<a href="#fn:2" id="fnref:2" class="footnote" title="see footnote">2</a>, 这是 Elixir
语言的一个设计缺陷. 理由如下:</p><ol><li>这样做使得命名函数, 不再是一等公民了, 一个函数式编程的语言, 命名函数不是一等公民,
总是些不协调的.</li><li>允许不带括号调用函数, 使得不能直接以函数名来引用函数, 而必须使用 <code class="inline">&amp;</code> 或者
<a href="https://hexdocs.pm/elixir/Function.html#capture/3"><code class="inline">Function.capture/3</code></a>.</li></ol><p>允许函数调用省略括号带来的好处非常的小; 但因此导致必须使用函数捕获的相关语法,
才能引用函数. 这使得函数引用的语法非常不经济.</p><p>在我编码的时候, 首先思考的是哪个函数可以满足需求, 无论是要调用它,
还是要把它作为参数传递其他高阶函数. 所以首先确定是函数的名字,
然后才是思考是 <em>调用</em> 还是 <em>引用</em>.</p><p>如果是要调用这个函数, 写括号也非常的流畅,
因为这时的思维的运行步骤与代码的书写步骤是一致的.</p><p>但是在需要引用这个函数的地方, 因为函数捕获操作符 <code class="inline">&amp;</code> 放在函数名的前面,
当意识到需要的是这个函数的引用的时候, 必须把光标重新移动到函数名的前面,
更糟心的是, 引用命名函数 (准确的说是捕获), 还需要指定函数的元数,
这意味着, 还需要再次把光标移动到函数名的后面.
也就是说, 对于代码, <code class="inline">&amp;String.length/1</code>, 我往往是先写出中间的 <code class="inline">String.length</code> 部分,
然后向左移动光标, 到这个表达式的头部补上函数捕获操作符 <code class="inline">&amp;</code>,
再向右移动光标到表达式末尾, 指定函数的元数. 这种体验实在是太糟糕了.</p><p>很多时候, 看到代码中 <code class="inline">&amp;String.length(&amp;1)</code> 这样的表达式,
我忍不住就想把其修改为 <code class="inline">&amp;String.length/1</code>. 也许 <code class="inline">&amp;String.length/1</code> 更正确和高效,
但是 <code class="inline">&amp;String.length(&amp;1)</code> 更加符合思维的顺序.</p><p>我的期望, 应该禁止命名函数的无括号调用语法, 而只允许宏调用可以省略括号.
这样函数名就是对函数的引用, 命名函数可以作为第一类公民了,
或者非常接近第一类公民了. 考虑到命名函数, 可能有多个同名而元数不同的函数,
引用命名函数的时候可以使用Eralng 函数导出一样的语法: <a href="https://hexdocs.pm/elixir/String.html#length/1"><code class="inline">String.length/1</code></a>.
函数类型是不能作为除法的运算数的, 所以这样就没必要使用函数捕获操作符了.
实际上 Erlang 中就是这样来区分函数的引用, 还是函数的调用的.</p><p>可是这是一个大工程, 必须在 Elixir 的源码级别改动, 且如此改动, 还会引发不兼容问题.</p><h3 id="匿名函数调用必须用括号" class="section-heading">
  <a href="#匿名函数调用必须用括号" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">匿名函数调用必须用括号</p>
  </a>
  匿名函数调用必须用括号
</h3>
<p>调用匿名函数的时候, 必须使用括号.</p><p>例如这样的代码:</p><pre><code class="makeup elixir" translate="no"><span class="n">fun</span><span class="o">=</span><span class="k" data-group-id="2347068293-1">fn</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="2347068293-2">(</span><span class="n">a</span><span class="o">*</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">*</span><span class="o">*</span><span class="mi">2</span><span class="p" data-group-id="2347068293-2">)</span><span class="o">*</span><span class="o">*</span><span class="mf">0.5</span><span class="w"> </span><span class="k" data-group-id="2347068293-1">end</span><span class="p">;</span><span class="w">
</span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="2347068293-3">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="2347068293-3">)</span></code></pre><p>关于 Elixir 的匿名函数调用需要一个句号 <code class="inline">.</code> , Erlang 之父 Joe Armstrong 在
<a href="https://joearms.github.io/#2013-05-31%20A%20week%20with%20Elixir">A Weak of Elixir</a> 的文章中,
认为这是 Elixir 语义设计的不好的地方. 当然了, 也有不少人认为这不是问题.</p><p>我想从另一个角度来考虑这个问题. 一个函数, 尤其是支持函数编程语言中的函数,
总是需要从语法上来区分 <strong>调用</strong>  还是 <strong>引用</strong> 的.
Elixir 的命名函数, 牺牲了对函数的引用的便捷, 换来调用命名函数时括号的可省略.
匿名函数的值, 本身就是存在一个变量中的, 所以引用非常的方便, 那么调用这个匿名函数的时候,
变量名后面的这个 <code class="inline">.</code> 实际上就是一种宣告: 这是对函数的调用, 而不是引用其值.
所以理论上, 对匿名函数的调用也没必要必须使用括号.
但是为什么 Elixir 中却要求必须使用括号呢? 这里我们先把问题搁下,
让我们先来总结一些括号在 Elixir 中的用法.</p><h2 id="括号小结" class="section-heading">
  <a href="#括号小结" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">括号小结</p>
  </a>
  括号小结
</h2>
<p>上面的几节中, 我们学习了括号在函数定义, 调用, 以及其他场景下的作用.
总结一下, 其实共有三个作用:</p><ol><li>作为参数的列表的分界符</li><li>改变代码运行的优先级</li><li>创建块表达式</li></ol><p>现在问一个问题: 以下的代码, 语法上正确吗? 如果正确的话, 返回值是什么呢?</p><p><code class="inline">[]</code>, <code class="inline">{}</code>, <code class="inline">()</code></p><p>第一个问题的答案是: 这三个都是语法正确的.
前两个非常的常见, 它们是空的列表和空的元组.</p><p><code class="inline">()</code> 的返回的是 <code class="inline">nil</code>. 不知道这个答案有没有让你感到意外, 但是我第一次知道的时候,
感觉非常的意外.</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_list</span><span class="w"> </span><span class="p" data-group-id="7472483387-1">[</span><span class="p" data-group-id="7472483387-1">]</span><span class="w">
</span><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_tuple</span><span class="w"> </span><span class="p" data-group-id="7472483387-2">{</span><span class="p" data-group-id="7472483387-2">}</span><span class="w">
</span><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p" data-group-id="7472483387-3">(</span><span class="p" data-group-id="7472483387-3">)</span></code></pre><p>这个知识点, 实际上解释了函数调用的这个规则: 命名函数的调用, 如果要使用括号,
括号必须紧跟着函数名,其间 <strong>不能有任何空白字符</strong>. 实际上函数定义的时候也是这样.</p><p>其他编程语言中, 基本上没有这样的语法规则, 大家所以这样做, 不过只是编码规范.
但是在 Elixir 中, 因为允许调用命名函数的时候, 可以不使用括号,
而一个空括号 <code class="inline">()</code> 的返回值又是 <code class="inline">nil</code>.
这样 <code class="inline">fun_name ()</code> 的语义就变成了: 以空括号 <code class="inline">()</code> 表达式的结果 <code class="inline">nil</code> 为参数,
调用函数 <code class="inline">fun_name</code>.</p><p>所以 Elixir 中就多了这样一个关于函数调用时括号的语法.
这是一个语法, 而不是编码规范.</p><p>但是为什么 <code class="inline">()</code> 的返回值是 <code class="inline">nil</code> 呢? 这里 <code class="inline">()</code> 实际上是空的块表达式.
块表达式的值是块中的最后一个表达式的值, 而空块表达式 <code class="inline">()</code> 没有表达式,
Elixir 所有代码都是表达式, 因此都需要有返回值. 对于空的块表达式,
最合理的返回值只能是用来表示空的 <code class="inline">nil</code> 了.</p><p>其他语言中, 括号的作用只有括号在 Elixir 中的前两个功能,
所以其他语言函数调用的时候, 语法上不用做这个要求.</p><p>现在重新来探索上面搁置的问题: 匿名函数的调用为什么必须使用括号呢?</p><p>思考代码: <code class="inline">fun. (3, 4)</code> 语法正确吗? 如果正确, 那么等价于 <code class="inline">fun.(3,4)</code> 还是 <code class="inline">fun.(4)</code>?</p><p>如果 <code class="inline">fun</code> 是一个二元函数, 你会发现, <code class="inline">fun. (3,4)</code> 和 <code class="inline">fun.(3,4)</code> 是一样的.
也就是说, <strong>匿名函数的调用, 虽然必须使用小括号把参数括起来, 但是小括号和 <code class="inline">.</code>
之间可以有空白</strong>.</p><p>意外不?</p><p>实际上, 我们甚至可以把函数名和 <code class="inline">.</code> 之间也添加空白, 像这样: <code class="inline">fun . (3, 4)</code>.</p><p>我所以感到意外, 是因为自己先入为主的错误偏见: 命名函数调用时,
括号和函数名之间都不能有空白, 而 Elixir 的官方对匿名函数后面的 <code class="inline">.</code> 解释是:
本来这个点后面应该是函数名的, 但是因为这是一个无名的函数, 所以就只剩下括号了.
虽然没有说, 点和括号直接不可以有空格, 但是, 如果我们接受 Elixir 官方对 <code class="inline">.</code> 的解释,
自然的推断就是不能有空格.</p><p>但是从另外一个角度来看, 其实 <code class="inline">.</code> 两边可以有空白又是那么的自然, 完全不应该惊讶:
<code class="inline">.</code> 是一个二元操作符. 所有的二元操作符, 比如 <code class="inline">+</code>, <code class="inline">-</code> 和操作数之间不都可以有空白的吗?</p><p>这种惊讶只是思维盲区带来的. 一旦我们认识到 <code class="inline">.</code> 是一个二元操作符, 就豁然开朗了.</p><p>但是如果我们意识到 <code class="inline">.</code> 是一个操作符, 那么为什么调用匿名函数的时候又必须使用括号呢?
毕竟 <code class="inline">(2)</code> 的返回值就是 2 吗? 在抽象语法上表示中, <code class="inline">(2)</code> 和 <code class="inline">2</code> 也没有任何的区别.
但是实际上是有区别的, <code class="inline">(2)</code> 所以等于 <code class="inline">2</code>, 是 <code class="inline">(2)</code> 被作为块表达式,
计算后的结果等于 2. 但是如果当作参数表来处理, <code class="inline">(2)</code> 就不等于2.
我们不可以在不需要参数列表的时候, 提供参数列表的语法的.
例如单独的 <code class="inline">(1,2)</code> 就不是一个合法的表达式. 匿名函数调用, 所以必须使用括号,
是因为 <code class="inline">.</code> 操作符要求, 当其左操作数是函数的时候, 右操作数必须是参数列表.</p><h2 id="块表达式不是作用域" class="section-heading">
  <a href="#块表达式不是作用域" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">块表达式不是作用域</p>
  </a>
  块表达式不是作用域
</h2>
<p>最后需要讨论一下块表达式和作用域的关系.</p><p>块表达式, 还是表达式, 它没有创建新的作用域.</p><p>但是 <code class="inline">do ... end</code> 的代码块, 因为是跟在作用域相关的语法结构后面, 所以,
其中的代码一般都是在新的作用域中的.
例如下面的代码:</p><pre><code class="makeup elixir" translate="no"><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="p" data-group-id="6664494582-1">(</span><span class="w">
  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="6664494582-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">label</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;in block exprssion, a&quot;</span><span class="p" data-group-id="6664494582-2">)</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p" data-group-id="6664494582-1">)</span><span class="w">
</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6664494582-3">(</span><span class="n">inspect</span><span class="p" data-group-id="6664494582-4">(</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="6664494582-4">)</span><span class="p" data-group-id="6664494582-3">)</span></code></pre><p>在块作用表达式中, 当然可以访问外部的变量 <code class="inline">a</code> 就像第 4 行代码显示的那样.
而且, 还可以对外部作用域中定义的变量 <code class="inline">a</code> 赋新值. 而第 7 行表明,
不但变量 <code class="inline">a</code> 的值改变了, 而且块表达式中定义的变量 <code class="inline">b</code>, 在块外部也可见.</p><p><strong>结论</strong>: <em>块表达式并<strong>不创建</strong>新的作用域</em>.</p><p>不但块表达式不创建新的作用域, 使用括号表示的参数列表, 其作用域也属于外部.
例如下面的代码:</p><pre><code class="makeup elixir" translate="no"><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="5915334563-1">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">:math</span><span class="o">.</span><span class="n">pi</span><span class="p" data-group-id="5915334563-2">(</span><span class="p" data-group-id="5915334563-2">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="5915334563-1">)</span><span class="w">
</span><span class="p" data-group-id="5915334563-3">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="5915334563-3">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="5915334563-4">(</span><span class="p" data-group-id="5915334563-4">)</span><span class="w"> </span><span class="c1"># {1.5707963267948966, 1.0}</span></code></pre><p>但是宏调用不一样. 宏是特殊的函数, 它接受 ast, 返回的也是 ast.
以宏的功能的不同, 可能会向运行时中注入宏参数一样的变量,
也可能不注入, 甚至还可能注入和宏参数完全无关的变量.</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="2667929997-1">(</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="2667929997-1">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p" data-group-id="2667929997-2">(</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2667929997-2">)</span><span class="w">
</span><span class="no">false</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="2667929997-3">(</span><span class="n">binding</span><span class="p" data-group-id="2667929997-4">(</span><span class="p" data-group-id="2667929997-4">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">keys</span><span class="p" data-group-id="2667929997-5">(</span><span class="p" data-group-id="2667929997-5">)</span><span class="p" data-group-id="2667929997-3">)</span><span class="w">
</span><span class="no">false</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="2667929997-6">(</span><span class="n">binding</span><span class="p" data-group-id="2667929997-7">(</span><span class="p" data-group-id="2667929997-7">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">keys</span><span class="p" data-group-id="2667929997-8">(</span><span class="p" data-group-id="2667929997-8">)</span><span class="p" data-group-id="2667929997-6">)</span></code></pre><p>上面的代码展示了, <code class="inline">&amp;&amp;</code> 宏, 并不把其接受的 ast 中的变量, 注入到运行时.</p><div class="footnotes"><hr/><ol><li id="fn:1"><a class="reversefootnote" href="#fnref:1" title="return to article">&amp;#x21A9;</a><p>Meta-expression, 这是 List 语言的设计者最初打算实现的,
给程序员使用的表达式格式, 但是最终 S 表达式流行起来, M 表达式从来没有实现.</p></li><li id="fn:2"><a class="reversefootnote" href="#fnref:2" title="return to article">&amp;#x21A9;</a><p>这一小结节中, 函数就只是函数, 不再包括宏.</p></li></ol></div>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="ch03-pattern_match.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
第三章 模式匹配
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ch05-new_constructor.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
第五章 定制新结构
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.4) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
