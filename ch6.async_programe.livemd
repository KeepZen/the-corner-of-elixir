# 异步编程

## 承诺(Promise)

Elixir 对异步编程的支持由 `Task` 模块支持. 但是我很少使用它,
`Task` 不是一个代数结构类型, 因此无法完成链式操作.
Javascipt 中的 Promise 不一样, 它成功的解决了回调地狱问题.
因此我希望能把这个类型引入到 Elixir 语言中.

我们将要定义的 Promise 模块, 对外提供的接口有 8 个函数, 其中 6 个来源于
Javascript 的 Promise API, 但是这里没有定义 `catch`.
`catch` 在 Elixiir 中是保留字, 不允许用作函数名, 因此这里用 `on_error` 来代替.

最后的 2 个函数: `of/1` 和 `map(promise,fun/1)` 是函子的通用函数.

1. `Promise` 构造函数 `Promise.new((reslove,reject)->any)`
2. `Promise` 特化的构造函数 `Promise.reslove(v)` 把 `v` 转化为已完成的 `Promise` 结构.
3. `Promise` 特化的构造函数 `Promise.reject(v)` 把 `v` 转化为已拒绝的 `Promise` 结构.
4. `Promise` 的转化换函数 `Promise.then(promise,fun, error_hanlder\\nil)`
5. `Promise` 错误处理函数`Promise.on_error(promise,fun)`
6. `Promise` 解构函数 `await(promise)` 返回 `Promise` 中包含的类型
7. 函子构造函数 `Promise.of({:resloved|:rejected,v})` 把任意类型的值 `v`
   转化为一个 `Promise` 结构.
8. 函子通用转化换函数 `Promise.map(promise,fun)`

```elixir
defmodule Promise do
  @type state :: :pending | :fulfilled | :rejected
  @opaque t :: %__MODULE__{state: state, result: any()}
  defstruct state: :pending, result: nil

  @spec of({state, any}) :: t
  def of({tag, v}) when tag in [:fulfilled, :resloved, :rejected] do
    tag = if tag != :rejected, do: :fulfilled, else: tag
    %__MODULE__{state: tag, result: v}
  end

  def reslove(v) do
    of({:resloved, v})
  end

  def reject(v) do
    of({:rejected, v})
  end

  def new(fun, timeout \\ :infinity)
      when is_function(fun, 2) or is_function(fun, 1) do
    ref = make_ref()
    me = self()
    {_, arity} = Function.info(fun, :arity)
    reslover = &reslover(result: &1, ref: ref, pid: me)

    args =
      if arity == 2 do
        rejecter = &rejecter(result: &1, ref: ref, pid: me)
        [reslover, rejecter]
      else
        reslover
      end

    spawn(
      __MODULE__,
      :_run,
      [fun, [with: args, fun_result: :discard, notify: me, with: ref]]
    )

    receive do
      {^ref, p} -> p
    after
      timeout -> %__MODULE__{state: :rejected, result: ref}
    end
  end

  for {name, state} <- [reslover: :fulfilled, rejecter: :rejected] do
    def unquote(name)(result: result, ref: ref, pid: pid) do
      send(pid, {ref, %__MODULE__{state: unquote(state), result: result}})
    end
  end

  def then(%__MODULE__{} = p, fun, on_error \\ nil) do
    case p.state do
      :pending ->
        chain(p, [fun, on_error])

      :fulfilled ->
        chain(p, [fun, nil])

      :rejected ->
        if on_error, do: chain(p, [nil, on_error]), else: p
    end
  end

  def map(%__MODULE__{} = p, fun) do
    chain(p, [fun, fun])
  end

  def on_error(%__MODULE__{state: state} = p, fun) do
    if state == :rejected, do: chain(p, [nil, fun]), else: p
  end

  defp chain(%__MODULE__{state: state} = p, funs)
       when state in [:fulfilled, :rejected] do
    ref = make_ref()
    do_chain(p, funs, ref)
  end

  defp chain(%__MODULE__{state: :pending} = p, funs) do
    {state, v} = do_await(p, :infinity)

    p =
      if state == :ok do
        %__MODULE__{state: :fulfilled, result: v}
      else
        %__MODULE__{state: :rejected, result: {state, v}}
      end

    ref = make_ref()
    do_chain(p, funs, ref)
  end

  defp do_chain(%{state: :rejected} = p, [_, nil], _ref), do: p

  defp do_chain(%{result: v, state: state}, [fun1, fun2], ref) do
    fun =
      case state do
        :fulfilled -> fun1
        :rejected -> fun2
      end

    me = self()

    spawn(
      __MODULE__,
      :_run,
      [fun, [with: v, fun_result: :send_back, notify: me, with: ref]]
    )

    %__MODULE__{state: :pending, result: ref}
  end

  def _run(fun, with: args, fun_result: how_to_do, notify: pid, with: ref) do
    {_, arity} = Function.info(fun, :arity)

    if arity == 1 do
      fun.(args)
    else
      apply(fun, args)
    end
  rescue
    error -> send(pid, {ref, {error, __STACKTRACE__}})
  else
    v ->
      case how_to_do do
        :send_back -> send(pid, {ref, {:ok, v}})
        _discard -> :ok
      end
  end

  def await(%__MODULE__{} = p, timeout \\ :infinity) do
    {_, v} = do_await(p, timeout)

    if is_struct(v, __MODULE__) do
      v.result
    else
      v
    end
  end

  defp do_await(%{state: :pending, result: ref}, timeout) do
    receive do
      {^ref, ret} -> ret
    after
      timeout -> {:timeout, ref}
    end
  end

  defp do_await(%__MODULE__{} = p, _) do
    {:ok, p}
  end
end
```

我们首先来看看 `Promise` 的 API.

### 动态构造函数 `new(fun,timeout\\:infinity)`

每个 `Promise` 对象有三个状态: 待执行(`:pending`), 已完成(`:fulfilled`),
和已拒绝(`:rejected`). 调用者不用关心, Promise 的状态,
当需要提取 Promise 中的值的时候, 调用 `await/1` 函数就好了.
`await/1` 会永久等待 Promise 对象从待执行变为已执行的状态.
`await/2` 支持等待一定时间后放弃.
超时后, `await/2` 返回的为 `ref`, 等到 Promise 执行结束后,
Promise 的创建进程, 可能依旧会收到 `{ref,value}` 消息,
通过 `await/2` 返回的 `ref` 依旧可以拿到 Promise 的结果.

`Promsie.new/1` 接受一个函数 `fun`, 返回一个 `Promise` 透明结构.
`fun` 函数规范为: `fun(reslover,rejecter)::any` 或 `fun(reslover)::any`.
其中 `reslover`, `rejecter` 都是一元函数, 返回值为 `Promise` 结构.

`fun` 的返回值会被丢弃, 但是如果 `fun` 抛出了异常, 那么 `Promise.new/1`
会返回拒绝状态的 `Promise` 对象.
在 `fun` 中调用 `reslover/1` 或 `rejecter/1`, `Promise.new` 会分别返回:
**完成** 或 **拒绝** 状态的 Promise.

**警告**:
调用 `Promise.new(fun)` 时, 如果 `fun` 函数中既没有调用 `reslover/1`,
也有没有调用 `rejecter/1`, 且没有引发异常, 那么 `new/1` 函数会陷入永久等待.
可以使用 `new/2` 来设置等待时间, 解决这个问题.
超时后, `new/2` 会返回拒绝状态的 `Promise`, 其中包含的值为一个 Reference.

<!-- livebook:{"disable_formatting":true} -->

```elixir
ExUnit.start(atom_run: false)

defmodule PromiseTest.New do
  use ExUnit.Case

  test "Promise.new(fun_is_arity_one)" do
    assert 1 ==
             Promise.new(fn reslove -> reslove.(1);2 end)
             |> Promise.await()
  end

  test "Promise.new(fun_is_arity_two)" do
    assert 1 ==
             Promise.new(fn reslove, _reject -> reslove.(1) end)
             |> Promise.on_error(fn _v ->  1 = 0 end)
             |> Promise.await()

    assert :good ==
             Promise.new(fn _reslove, reject -> reject.(1) end)
             |> Promise.then(fn _ -> :bad end)
             |> Promise.on_error(fn v -> v == 1 && :good end)
             |> Promise.await()
  end

  test "Promise.new(fun) timeout" do
    assert Promise.new(fn _, _ -> :ok end, 1000)
           |> Promise.await()
           |> is_reference()
  end
end

ExUnit.run()
```

### 数据构造函数

`Promise.of({tag,v})`, `Promise.reslove(v)` 和 `Promise.reject(v)`
是三个数据构造函数, 把 `v` 置于 `Promise` 对象之中. `Promise.reslove(v)` 是
`Promise.of({:reloved, v})` 代理; `Promise.rejcet(v)` 和
`Promise.of({:rejected, v})` 一样.

这些构造函数和 `new/1` 的最大差别在于, `new/1` 可能会阻塞调用者进程, 这 3
个函数都不会阻塞调用者进程.

### 数据转化函数

`map`, `then` 和 `on_error` 是三个函数转化函数.
其中 `then/1-2` 和 `on_error` 与 Javascript 的 Promise API 的对应函数功能相同[^js_promise].
`then/1` 只处理 **已完成** 状态的 Promise, `then/2` 接受两个转化函数,
第一个处理 **已完成** 状态的, 第二个处理 **拒绝** 状态的. `on_error/1` 只处理 **拒绝状态** 的 Promise.

[^js_promise]: 见 MDN [Promise 参考页面](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)

`map` 是为了配合 Elixir 的函数子句而提供的 API.
当运行时错误发生时, `map` 的处理函数接受到的是 `{error, stack}` 数据,
其中 `error` 是运行时异常类型, 而 `stack` 是异常的调用栈.
但是对于 `of({tag,v})` 或 `reject/1` 构造的拒绝状态, 那需要用户自己在 `v`
中添加元数据, 以表明它是哪种状态获得的值.

```elixir
Promise.reject({:r, 3})
|> Promise.map(&if elem(&1, 0) == :r, do: elem(&1, 1) + 1, else: raise("error"))
|> Promise.await()
|> IO.inspect(label: "expect 4, in fact get")

Promise.reslove({:f, 3})
|> Promise.map(&if elem(&1, 0) == :f, do: elem(&1, 1) + 1, else: raise("error"))
|> Promise.await()
|> IO.inspect(label: "expect 4, in fact get")

Promise.new(fn _, _ -> 1 / 0 end)
|> Promise.map(fn {err, _} when is_exception(err) -> :bad end)
|> Promise.await()
|> IO.inspect(label: "expect get a :bad, in fact get ")
```

无论使用那个转化函数, 都立刻返回新的 `Promise` 结构, 而不会阻塞调用者进程.
但是这个返回的 `Promise` 对象处于待执行状态, 所以不能从中拿到转化后的结果.

### await

要拿到转化后的结果, 使用 `await/1-2`. 即使构造函数返回的 `Promise`
对象可以使用模式匹配获取, 也不推荐使用模式匹配. 因为 `Promise` 结构应该是不透明,
其内部实现, 后续版本可能会修改的.

**警告**:
使用 `await/1` 的时候,
调用者进程也有被卡住的风险, 就像 `new/1` 那样.

例如当某个转化函数陷入循环, 没有返回结果的时候, 那么这个 Promise 将永远处于待完成状态,
这时调用 `await/1`, 将会阻塞调用者进程.

最后要注意的是, 这里全部都是函数, 没有宏, 所以**不要使用 `import` 语句**,
如果使用 import 导入全部函数, 那么会引发 `Promise.then/1` 与 `Kernel.then/1`
的命名冲突.

## 流(Stream)

Generater 是 ES6 中引入的新的语法, 让我们可以通过 `function*` 来创建产生子.
有了这个语法, 在 Javascript 中, 我们就可以产生无限数量的序列了.

Elixir 标准库中, 提供了 `Stream` 模块.
任意的在枚举过程中, 一个接一个产生数据的可枚举数据类型, 都可以叫做 `Stream`[^stream].
虽说 Stream 模块提供**组合**和**创建** `Stream` 的函数.
但是从函数的数量上来说, 这个库中提供的, 创建 `Stream` 的函数只有 3 个,
堪堪占据全部函数的十分之一左右.

[^stream]: 见 [Stream 模块文档](elixir/1.13.0/Stream.html)

对于无限序列, `Stream` 模块提供的 API 非常方便.
比如让我们产生一个斐波那契数列的 `Stream`:

```elixir
Stream.unfold({1, 1}, fn {a, b} -> {a, {b, a + b}} end)
|> Stream.take(10)
|> Enum.to_list()
```

但是, 当要求产生特定的序列时, 就开始变得怪异了. 比如, 产生斐波那契数列中,
和小于 10000 的序列.

```elixir
Stream.unfold(
  {1, 1, 0},
  fn {a, b, sum} -> if sum < 1000, do: {a, {a + b, b, sum + a}}, else: nil end
)
|> Enum.to_list()
```

这样的 API, 虽然能完成工作, 但是代码的可读性非常差, 阅读这样的代码, 往往一头雾水.

这是因为控制流由 `Stream.unfold/2` 控制的.
`Stream.unfold(acc,fun)` 通过判断 `fun` 返回结果,
来决定为流中产生什么元素或者是否结束序列.
具体的说, 当 `fun` 返回的是 `nil` 的时候, 序列结束.
当 `fun` 返回一个二元元组的时候, 元组的第一个元素作为序列的元素,
第二个元素作为继续调用 `fun` 的参数.
这就是为什么, `Stream.unfold/2` 第二个参数的类型为
`(acc() -> {element(), acc()} | nil)` 的原因.

如果要完成更加复杂的工作, 例如写一个从文件中读取内容的 `Stream`,
那么就必须使用 `Stream.source/3`. 和 `Stream.unfold/2` 类似,
`Stream.soruce/3` 根据回调函数的返回结果来决定如何产生流的元素和什么时候结束流.
但是 `Stream.source(start_fun,next_fun,end_fun)`
因为要调用 `end_fun` 完成最后的资源清理工作,
所以不能仅要求 `next_fun` 返回 `nil` 来表示流结束.
`next_fun` 的类型规范是: `(acc() -> {[element()], acc()} | {:halt, acc()})`.
当返回的结果为`{:halt,acc()}` 的时候, `Stream.source` 调用 `end_fun(acc)`,
并结束流序列. 但为什么表示需要参数元素的时候, 不能直接返回 `{elememt(), acc()}`
而必须把要产生的序列放在列表中呢? 这是因为如果返回 `{element(),acc()}` 那么,
`Stream.unflod/2` 就无法产生一个包含 `:halt` 的 Stream 序列了.

Stream 让我想起了 Javascript 的产生子. 如果 Elixir 提供了产生子, 那么产生子函数结合上面定义的
Promise 就可以写出更加容易读的 Stream.

## 产生子(Generater)

首先来分析产生子的语法.

我打算使用宏 `defgen` 来产生一个匿名函数, 这个匿名函数调用后, 产生一个透明结构, 表示产生子.
所以, 大概的语法是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
defgen generater_name do
  a, b when a > b -> 
   c = yield a
   d = yield c + b
   yield d
  a, b ->
    yield a + b
end

g = generater_name(3,2)
3 = g |> next(1) # c is 1
3 = g |> next(4) # d is 4
4 = g |> next(:any)
true = g |> done?()
```

在 `defgen` 上下文中, 可以使用 `yield`. `yield a` 会等待 `next(g,v\\nil)` 的执行.
等 `next(g,v\\nil)` 执行后, `next/2` 会得到返回值 `a`, 
在产生子内部 `yield a` 的返回值是 `{:ok, v}`.
产生子函数中最后一个 `yield` 语句执行完成后, 再调用 `next(g,v)` 会返回 `:done`.

那么该如何来实现呢? Elixir 现有的语法中, 如何组合出这样的功能呢?
首先 `receive` 会暂定一个进程的执行, 找到收到需要的数据, 才接着执行.
所以, 产生子函数, 应该运行在另外的一个进程中, 当 `generater_name/2`
被调用的时候, 产生子函数执行, 遇到第一个 `yield` 语句, 停止执行,
等待 `next/2` 函数发送继续执行的信号. 收到 `next/2` 的继续执行信号后,
表达式 `yield a` 完成如下工作:

1. 参数 `a` 发送给 `next`
2. 把 `next` 发送过来的数据作为 `yeild a` 的返回值传递后其他语句
3. 继续执行其他语句, 直到遇到新的 `yeild` 语句

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
sequenceDiagram
    participant  主进程
    participant  产生子进程
    主进程->> 产生子进程: 启动产生子进程
    产生子进程-->>产生子进程: 运行, 遇到 yield 后,<br>等待主进程发送信号
    主进程->> 产生子进程: {:continue,3} --- next(g,1)
    产生子进程->>主进程: {:ok, b} --- yield b
    主进程 ->> 产生子进程: {:continue, 4} --- next(g, 4)
    产生子进程->>主进程: {:ok, 1 + b} --- yield c+b
    主进程 ->> 产生子进程: {:continue,:any} --- next(g, :any)
    产生子进程->>主进程: {:ok, 4} -- yield d
    主进程 -->> 主进程: 子进程还活着吗?
    主进程 ->> 主进程: 没有
```

<!-- livebook:{"break_markdown":true} -->

所以 `defgen name do...end` 产生一个匿名函数, 这个匿名函数绑定给了变量 `name`.
调用匿名函数 `name` 会启动产生子进程, 并返回一个透明结构.
这个透明结构, 对应于 Javascript 的产生子迭代器,
但是, 在我们这里, 用它来作为主进程与产生子进程通信的信道.
如果我们愿意, 还可以为这个信道实现枚举协议, 
这样就可以使用 `Enum` 模块和 `for` 来处理产生的序列了.

```elixir
quote do
  defgen hello do
    a, b ->
      c = yield a
      yield c + b
  end
  TEM = fn _hello, ref, a, b ->
    _hello, a, b ->
      c = yield a
      yield c + b
  end
  hello = fn a, b ->
    ref = make_ref()
    pid = sparn(fn ->TEM.(TEM,ref,a, b) end)
    %{pid: pid, ref: ref}
  end
  TEM = nil
end
```

```elixir
defmodule Corner.Generater do
  defmacro defgen(name, do: block) do
    case clause_arity_check(block) do
      {:ok, arity} ->
        make_any

      :error ->
        raise SyntaxError, "语法错误"
    end
  end

  defp clause_arity_check([{:->, _, [args | _]} | others]) do
    args =
      case args do
        [{:when, _, args}] ->
          {_, args} = List.pop_at(args, -1)
          args

        args ->
          args
      end

    case others do
      [] ->
        {:ok, length(args)}

      [{:->, _, [args2 | _]} | _] when length(args) == length(args2) ->
        syntax_check(others)

      true ->
        :error
    end
  end
end
```

```elixir
defmodule Coner.Generater do
  def _del_gen(m) do
    is_gen = m.module_info(:attributes)[:is_gen]
    is_gen? = is_gen && __MODULE__ in is_gen

    if is_gen? do
      pid = Process.whereis(m)
      pid && Process.exit(pid, :kill)
      :code.delete(m)
    else
      false
    end
  end

  defmacro del_gen(m) do
    quote do
      unquote(__MODULE__)._del_gen(unquote(m))
      unquote(m) = nil
    end
  end

  defmacro defgen({name, _, call}, do: block) do
    uuid = make_uuid()
    process_fun = make_process_fun(call, block, uuid)

    args = get_args(call)
    ast = make_anonymous_function(call, process_fun, args, uuid)
    {:=, [], [{name, [], nil}, ast]}
  end

  defp make_uuid() do
    NaiveDateTime.utc_now()
    |> to_string()
    |> String.to_atom()
  end

  defp make_process_fun(call, {:__block__, _, stances}, uuid) do
    stances = if is_list(stances), do: stances, else: [stances]
    make_process_fun(call, stances, uuid)
  end

  defp make_process_fun(call, t, uuid) when is_tuple(t) do
    make_process_fun(call, [t], uuid)
  end

  defp make_process_fun(call, stances, uuid) do
    stances = Enum.map(stances, &transform(&1, uuid))

    quote do
      fn unquote_splicing(call) ->
        (unquote_splicing(stances))
      end
    end
  end

  defp transform({:=, _, [_, {:yield, _, _}]} = ast, uuid),
    do: yield_to_send(ast, uuid)

  defp transform({:yield, _, _} = ast, uuid), do: yield_to_send(ast, uuid)

  defp transform(ast, _uuid), do: ast

  defp yield_to_send({:=, _, [left, {:yield, _, [after_yield]}]}, uuid) do
    quote do
      unquote(left) =
        receive do
          {me, unquote(left)} ->
            send(me, {unquote(uuid), unquote(after_yield)})
            unquote(left)
        end
    end
  end

  defp yield_to_send({:yield, _, [after_yield]}, uuid) do
    quote do
      receive do
        {me, nil} -> send(me, {unquote(uuid), unquote(after_yield)})
        {me, _} -> send(me, {unquote(uuid), unquote(after_yield)})
      end
    end
  end

  defp get_args({:when, _, args}) do
    Enum.reduce_while(args, [], fn {ele}, acc ->
      if elem(ele, 1) == [if_undefined: :apply] do
        {:cont, acc ++ [ele]}
      else
        {:halt, acc}
      end
    end)
  end

  defp get_args(args), do: args

  defp make_anonymous_function(call, process_fun, args, uuid) do
    module = make_module(uuid)

    quote do
      fn unquote_splicing(call) ->
        pid = spawn(fn -> apply(unquote(process_fun), unquote(args)) end)
        Process.register(pid, unquote(uuid))

        unquote(module)
        |> elem(1)
      end
    end
  end

  defp make_module(uuid) do
    quote do
      defmodule unquote(uuid) do
        Module.register_attribute(__MODULE__, :is_gen, persist: true)
        @is_gen unquote(__MODULE__)
        @gc_after_seconds 10 * 1000
        def running?() do
          pid = Process.whereis(unquote(uuid))
          t = pid && Process.alive?(pid)

          if t do
            :timer.apply_after(
              @gc_after_seconds,
              unquote(__MODULE__),
              :_del_gen,
              [__MODULE__]
            )
          end
        end

        def done?() do
          !__MODULE__.running?()
        end

        def next(v \\ nil) do
          if running?() do
            pid = Process.whereis(unquote(uuid))
            send(pid, {self(), v})

            receive do
              {unquote(uuid), v} -> v
            end
          else
            :done
          end
        end
      end
    end
  end
end
```

现在我们来看一下, 如何使用产生子. 这个模块, 导出了一个宏 `defgen/2`.
和 `fn` 类似, `defgen` 产生一个匿名函数. 在 `defgen` 内部,
可以使用关键字 `yield` 表示返回数据, 并中断函数执行. 就像在 Lua 或 Js 中的语法那样.

`defgen fun(a,b) do...end` 不但产生了匿名函数,
而且把这个匿名函数绑定给了 `fun` 变量.

```elixir
import Coner.Generater

defgen fun(a, b) do
  c = yield(a)
  yield(c + b)
end

:fun in (binding() |> Keyword.keys())
```

调用这个新产生的匿名函数 `fun`, 返回一个原子, 表示一个模块的名字. 在这个新的模块中,
导出了 `next/0/1`, `done?/1` 和 `running?/1`.

```elixir
g = fun.(1, 2)
is_atom(g) |> IO.inspect()
g.__info__(:functions)
```

调用这个模块的 `next()` 会返回产生子产生的元素. `next(v)` 返回产生的元素外,
还为 `yield` 指定了返回值 `v`. 当调用 `next()` 的时候, `yield` 的返回值为 `nil`.

```elixir
g.next(3)
|> IO.inspect(label: "shoud be 1, get")

(g in Process.registered()) |> IO.inspect(label: "G is registerd")

g.next(4) |> IO.inspect(label: "should be 3+2")
g |> IO.inspect(label: "g is a atom")
```

### 垃圾收集

产生子以内存内模块的形式存在, 因此, 当不再需要产生子后,
因为系统不会自动的清除不再需要的模块(?TODO?),
那么相当于为系统中引入了不能被收集的垃圾.

对于一个已经运行结束的产生子来说, 一段时间后, 系统会自动的完成垃圾收集的工作.
但是对一个还没有运行结束的产生子, 必须使用宏 `del_gen/1` 宏来手动清理.

另外, 每产生一个新的产生子, 都为系统中引入了一个新的表示原子, 而原子是不能被收集的,
所以必须节制, **不要在循环中调用 `def_gen` 产生的匿名函数**.
