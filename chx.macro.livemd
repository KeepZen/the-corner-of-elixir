# 如何理解宏

## 宏与语言分类

宏是什么? 这似乎是一个非常容易掌握的概念. 我的理解是这样的:
宏是写给编译器的指令. 这个定义非常宽泛, 从 C 这样的最简单的文本替换宏,
到 Lisp 这样的对抽象语法树做处理的宏, 都可以涵盖.

这样的理解不能说错误, 但是取没有抓住宏的本质.
我发现, 这就是为什么, 我现在学习 Elixir 的时候,
时常遇到困惑的一个根本原因.

所以如此, 和我的知识储备有关系.
我学习和熟练掌握的编程语言中, 宏在其中要么基本上没有地位(Python, Js),
要么只有非常非常小的作用(C, C++). 所以对宏的理解,
才会一直停留在概念的阶段.

按照我们的定义, 宏只能是编译型语言中才会出现的概念.
因为解释性的语言, 没有编译器的存在.
当然了, 我知道也理解, 现在大部分的解释器,
实际上也是要做编译器要做的工作的. 所以理论上, 也应该有宏的.
但是对于解释性的语言来说, 要区分宏和普通的代码是困难的.
因为代码的执行和宏的执行, 概念上有先后的两个动作,
对于解释性的语言, 从外部观察时, 这两个动作是难以区分的.
但是对于编译型的语言, 因为编译代码和运行程序可以做到时间上间断,
所以可以清楚区分它们.

例如, 同样的关于外部代码的导入的语法,
C/C++ 中以 `#include` 的形式出现, 通过预处理,
我们可以清楚的体会到宏的存在.

反观 Js 中, 以 `import` 语句的形式出现的相同功能,
不难想象, Js 解释器与 C 编译器做了大量的相同的工作.
但是JS 解释器为 `import` 语句做的工作, 从系统外部难以观察出来,
如果不考虑程序的执行的副作用的话.

不那么严格的解释, 可以认为解释性语言, 解释器对源码是解释执行的.
而编译型的语言, 编译器是要编译源码的. 通常情况下, 
**编译** 我理解就是做翻译, 把源码中的文本翻译成中央处理器(CPU)
或者虚拟机(VM) 可以理解的内容.

这样的理解对于普通的代码是没有问题的, 但是当考虑宏的时候,
编译器对宏做的事情就不能这样理解了.
普通的代码, 对编译器来说, 是要处理的数据; 但宏不是编译器要处理的数据,
而是待执行的指令. 编译器对宏, 正像解释器对源码做的一样: 解释并执行它们.

拿一个社会生活的场景来对比一下, 也许就更清楚了.

一个对翻译品质有担当的翻译者, 在翻译的时候往往会和作者沟通;
如果两人关系更密切的话, 译者甚至拿到的翻译底本, 直接就有原作者的批注.
这些批注是写给译者的, 用来提醒译者原文的正确意图的.
这些内容(批注或者作者的答复), 虽然不是原书的内容,
但是它们对译文来说, 是必要的, 因为它们确确实实的要影响译文的呈现,
进而影响读者对原文的理解. 在这里, 译者就是编译器; 原始的书稿内容是常规的代码;
作者的批注和答复, 就是宏; 译文就是编译后的目标码; 读者就是 CPU 或 VM.

在 C/C++ 以及 Erlang 这些语言中, 宏能完成的工作是非常少的,大部分的工作还是要编译器完成的,
这正像是作者答复译者, 或在书稿中做注释, 而主要的工作还是要由译者完成一样.
但是这样的意象在处理 Elixir 这样的宏的时候, 就不适用了.

例如, 对于 BEAM 虚拟机的最基本的编译单元**模块**来说.
但是在 Elixir 中, 我们必须使用宏 `defmodule`.
它和 Erlang 中的 `-module(MODULE_NAME).` 做的工作完全不是一个数量级的.
`-module(MODULE_NAME).` 只是标记了模块的名字, 并没有涉及到模块的正文.
`defmodule` 不一样, 它不但包含了模块的名字, 而且包含了模块正文.
所以脚注的意象在这里就不合适了. Elixir 宏的合适意象应该汉语屋的故事[^chinese-room].
译者对原文的翻译是智慧型的劳动; 汉语屋中的人做的却是机械的工作.

从语言学的角度来看, C/C++, Erlang 的宏不能构成一个图灵完备的语言,
或者至少设计的初衷不是把它们当作一个图灵完备的语言来设计的[^c-macro].
但是 Elixir 中的宏是图灵完备的, 从这个角度来看
Elixir 的编译器实际上就是宏的解释器.
写常规的 Elixir 代码, 大量的是对内建宏的调用, 这就像是我们在其他语言中调用标准库一样;
而定义自己的宏, 也就是说元编程, 才像是用编程语言来完成编程任务,
只是元编程的任务是对编译器的功能进行扩增或修改.

[^chinese-room]: 百度百科词条[&Lt;中文房间&Gt;](https://baike.baidu.com/item/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4/3581768)
[^c-macro]: 有关 C 语言宏的图灵完备性的讨论见 https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete

## 编译器与宏

Elixir 的编译器是 `elixirc`. 我们现在来探索一下编译器.

<!-- livebook:{"force_markdown":true} -->

```elixir
IO.puts("Hello World!")
```

把上面的代码保存到名为 hello-word.ex 文件中, 然后我们在命令行中输入`elixirc hello-world.ex`,
然后我们就看到了 "Hello, World!", 但是在当前的目录下面,
并没有产生 `hello_world.beam` 文件.

上面的代码片段, 以及它的运行的结果, 告诉我们, 在模块外的作用域中,
代码直接在编译时运行(输出 "Hello World"),
而不是把编译的结果保存到字节码文件中(所以没有 `.beam` 文件).

模块的外的代码, 编译器直接解释执行; 模块内的代码, 编译器是如何处理的呢?

```elixir
IO.puts("Say hello outside Module!")

defmodule MyModule do
  IO.puts("Say Hello in MyModule But not in function")

  def hello do
    IO.puts("Say Hello in MyModule.hello()")
  end
end
```

把上面的代码保存到 `my_module.ex` 文件中, 然后使用 `elixirc my_module.ex`
命令来编译我们的文件. 在编译的过程中, 我们可以看到第 1 行和第 4 行的输出.
在当前目录下, 还看到了编译器产生的 `Elixir.MyMoule.beam` 文件.

这说明, `defmodule/2` 的第二个参数, `do`...`end` 块,
在 `defmodule/2` 被调用的时候, 得到了执行.
其中的 IO 输出语句(第 4 行) 在编译时执行了,
所以我们在编译器的标准输出中, 看到了它的输出内容.
最后产生的 `Elixir.MyModule.beam` 文件,
这说明编译器还把其他的编译内容保存到了字节码中.

现在我们启动 `iex`. 输入 `MyModule.hello()`,
按下回车后, 第 7 行的输出语句就显示出来了.
这说明, 我们的 `hello/0` 函数的确被编译到了字节码文件中.

在模块中, 不但可以调用 `def*` 这些宏, 还可以执行其他语句, 这还是让我十分的惊讶的.
因为 C++ 和 Java 的背景知识, 不由自主的总是把 Elixir 的模块和类的概念联系到一起.
但是在类的定义的作用域中, 基本上只可以使用赋值语句, 而且 `=` 的右值还必须是编译时常量,
其他控制结构, 或者函数调用都是不允许的. C 语言的全局作用域中, 基本上也是这样的要求.
即使在亲缘关系最近的 Erlang 中, 基本上也是一样.
控制结构, 函数调用, 都只能在函数的定义中使用.

如果一定要在其他语言中寻找对应物的话, 那么可能就是 Java 的静态块了.
但是 Elixir 在 `defmodule` 上下文中, `def*` 外的其他结构的在运行时执行,
和 Java 中对静态块处理还有不同: Java 中的静态块是编译到字节码中的, 
且每次字节码被加载的时候, 都要被执行的.
而*Elixir `defmodule` 上下文中, `def*` 之外的代码, 都是在编译时被解释执行了,
并**没有**被保存到字节码中*.

这一点我们可以通过启动 `iex` 的时候, 并没有看到代码片段中第 3 行的输出而得到确认.
或者, 我们可以可以使用 Elang 提供的库函数 `:beam.chunks/2`, 
来查看编译后的代码的抽象码(字节码对应的汇编语言), 以此来更直观的证实我们的结论.

在 iex 中输入 `:beam_lib.chunks('Elixir.MyModule',[:abstract_code])`,
我们就看到了 `Elixir.MyModule.beam` 中保存的字节码对应的抽象码.

观察输出的抽象码, 不难发现, 其中的确有我们这里定义的 `hello/0` 函数;
而且真的找不到第 1 行和第 3 行相关的代码.
这全面的证实了我们上面对编译器的分析.

## 宏其实是函数

开始学习 Elixir 的时候, 最不习惯的是控制结构中的逗号和冒号.
比如 `defimpl ProtocolName, for: Integer do...`,
在这里协议名后面的 `,` 为什么是必须的呢? 还是 Elixir 中, `for` 明明是一个保留字,
为什么这里还必须用关键字的语法糖呢?
保留字 `do` 和 关键字语法糖的 `, do:` 区别在哪里?

所以会有这些疑问在于把 Elixir 中用作控制结构的宏当作是其他语言的保留字了.
只有认识到宏不是保留字, 而是特殊的函数, 才能更好的理解上面的问题.

因为宏是被编译到字节码中的, 我们还知道,
Erlang 中只有模块属性和函数可以被编译到字节码中.
所以 Elixir 宏一定是特殊函数. 不然它不能被编码到字节码中.

认识到宏是特殊函数, 那么对宏的调用自然必须遵守对一般函数调用的规则.
这其中最重要的规则就是: 调用函数时, 当参数个数多余一个的时候,
参数之间是用 `,` 做分隔符的.
这实际上就解释了为父么宏调用的时候, 往往会有 `,` 了.

在我最初的理解中, 我认为关键字列表语法糖 `do:` 是对保留字 `do` 的模仿.
但是认识到宏调用本质上也是函数调用, 那么这个理解就应该反转过来了,
关键字列表 `[do: ...]` 是合法的数据, 但是 `do` 保留字不是数据,
函数接受的应该是合法的数据, 所以 `do` 实际上的工作就是要创建 `[do: ...]`
这样的关键字列表.

类似于 `do`; `else`, `catch`, `rescue`, `after`
这些保留字本身也就是用来创建对应的原子的.

如果宏也是函数, 为什么它那么特殊, 必须导入(`import`) 或请求 (`require`)
对应的模块才能调用呢? 或者换个角度来说: 宏是如何特殊于普通函数的? 
请求(`require`) 又是如何帮助我们突破这种特殊性的?

让我们用实验来探索.

```elixir
defmodule Corner.Macro do
  defmacro foo, do: nil
  def bar, do: nil
end

Corner.Macro.module_info() |> IO.inspect()
```

上面的代码中, 我在模块中, 定义了定义了 `foo/0` 宏 和 `bar/1` 函数.
`module_info` 的返回结果中, 模块的导出中, 可以找到函数 `fun/0`;
没有找到 `hello/0` 这宏, 但是多了一个 `MACRO-hello/1` 的函数.
可以猜测, `MACRO-hello/1` 一定和我们定义的宏有关系.

```elixir
require Corner.Macro
import IEx.Helpers
b(Corner.Macro.__info__())
Corner.Macro.__info__(:macros)
```
