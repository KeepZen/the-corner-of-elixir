# ç®¡é“æ“ä½œç¬¦

## ç®¡é“æ“ä½œç¬¦ä¸æ˜¯ç»„åˆå‡½æ•°

åœ¨å‡½æ•°å¼ç¼–ç¨‹çš„ç¤¾åŒºä¸­, å‡½æ•°ç»„åˆéå¸¸çš„é‡è¦. ç»„åˆå‡½æ•°æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°, å®ƒæ¥å—å¤šä¸ªå‡½æ•°,
è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°, ä¾‹å¦‚ `fun=compose(f,g,k)`, é‚£ä¹ˆ `fun(x,y,z)` å°±ç­‰ä»·äº
`f(g(k(x,y,z)))`. ä¸ºäº†ä¸æ€ç»´çš„ä¹ æƒ¯ä¸€è‡´, äººä»¬è¿˜å®šä¹‰äº†ååºçš„ç»„åˆå‡½æ•°, å«åš `pipe` å‡½æ•°.

åœ¨ Elixir ä¸­æ²¡æœ‰å†…ç½®çš„ `compose` æˆ– `pipe` å‡½æ•°, ä½†æ˜¯å†…ç½®äº†ç®¡é“æ“ä½œç¬¦ `|>`.
æˆ‘ä¸€åº¦è®¤ä¸ºç®¡é“æ“ä½œç¬¦ `|>` å°±æ˜¯ Elixir çš„ `pipe` å‡½æ•°. ä½†æ˜¯è¿™æ˜¯ä¸€ä¸ªå¹»è§‰.
ç®¡é“æ“ä½œç¬¦ `|>` æ›´åƒ shell çš„ç®¡é“è€Œä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ `pipe` å‡½æ•°.

è‡³å°‘ Elixir ç¼–è¯‘å™¨ä¸ä¼šä¸ºæˆ‘ä»¬åšå‡½æ•°ç»„åˆçš„ä¼˜åŒ–.

å‡½æ•°å¼ç¼–ç¨‹ä¸­, å¾ˆå¤šè¯­è¨€, ä¼šå¯¹å‡½å­çš„ map æ“ä½œåšä¼˜åŒ–. æ¯”å¦‚:
`[1,2,3].map(f).map(f2)` ç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸º `[1,2,3].map(compse(f,f2))`,
ä»¥æé«˜ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡.

åœ¨ Elixir ä¸­, ç›¸åº”çš„ä»£ç æ˜¯è¿™æ ·çš„: `[1,2,3] |> Enum.map(f)|> Enum.map(f2)`.
è¿™æ ·çš„ä»£ç , å¦‚æœæœ‰ä¼˜åŒ–çš„, æœ€ååº”è¯¥ç­‰ä»·äº `[1,2,3]|> Enum.map(&f2.(f.(&1)))`.
ä½†æ˜¯å®é™…çš„æƒ…å†µå¹¶ä¸æ˜¯è¿™æ ·çš„.

ä¾‹å¦‚ä¸‹é¢çš„ä»£ç :

```elixir
fun1 = fn v -> v |> IO.inspect(label: "+1") |> then(&(&1 + 1)) end
fun2 = fn v -> v |> IO.inspect(label: "-1") |> then(&(&1 - 1)) end
range = 1..5

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

æ§åˆ¶å°çš„è¾“å‡ºä¸º:

```
+1: 1
+1: 2
+1: 3
+1: 4
+1: 5
-1: 2
-1: 3
-1: 4
-1: 5
-1: 6
result of map chain: [1, 2, 3, 4, 5]
```

ä»æ§åˆ¶å°çš„è¾“å‡ºä¸­, å¯ä»¥è§‚å¯Ÿåˆ°, æ‰€æœ‰çš„ `+1` è¾“å‡ºç»“æŸå, æ‰å¼€å§‹ `-1` çš„è¾“å‡º.
ç®¡é“æ“ä½œç¬¦ `|>` è¿æ¥èµ·æ¥çš„ `Enum.map` å¹¶æ²¡æœ‰æŠŠåˆå¹¶æˆä¸ºä¸€ä¸ª.
åªæœ‰å¯¹ `fun1` çš„è¿­ä»£è°ƒç”¨å…¨éƒ¨å®Œæˆå, å¯¹ `fun2` è°ƒç”¨æ‰å¼€å§‹æ‰§è¡Œ.
ä½†å¦‚æœæŠŠ `fun2` å’Œ `fun1` ç»„åˆæˆä¸€ä¸ªæ–°çš„å‡½æ•°, åƒä¸‹é¢çš„ä»£ç è¿™æ ·:

```elixir
range
|> Enum.map(&fun2.(fun1.(&1)))
|> IO.inspect(label: "result of compose")
```

é‚£ä¹ˆæ§åˆ¶å°çš„è¾“å‡º, `+1` `-1` äº¤æ›¿å‡ºç°çš„.

å› æ­¤, å¯è§, Elixir å†…ç½®çš„ç®¡é“æ“ä½œç¬¦ `|>` ä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ `pipe` å‡½æ•°.

å¯æ˜¯æ‰‹åŠ¨çš„ç»„åˆå‡½æ•°æ€»æ˜¯æ¯”è¾ƒçš„éº»çƒ¦, å†™ä¸€ä¸ªå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆå‡½æ•°çš„ç»„åˆä¹Ÿä¸æ˜¯éš¾äº‹,
ä½†æ˜¯ Elixir ç¤¾åŒºä¸­, å› ä¸ºå‘½åå‡½æ•°ä¸æ˜¯ä¸€ç­‰å…¬æ°‘, æ‰€ä»¥å‡½æ•°ç»„åˆçš„è¯­æ³•å¹¶ä¸å¸¸ç”¨.
å¤§å®¶æœ€ä¹ æƒ¯çš„å…¶å®è¿˜æ˜¯ä½¿ç”¨ç®¡é“æ“ä½œç¬¦ `|>`, æ‰€ä»¥å¦‚æœç®¡é“æ“ä½œç¬¦ `|>` èƒ½å¯¹ `Enum.map`
åšä¼˜åŒ–, é‚£ä¹ˆåº”è¯¥èƒ½æå‡ä»£ç çš„è¿è¡Œæ•ˆç‡.

éå¸¸å¹¸è¿, ç®¡é“æ“ä½œç¬¦ `|>` åœ¨ Elixir ä¸­å¹¶ä¸æ˜¯ç‰¹æ®Šè¡¨å•, æˆ‘ä»¬å¯ä»¥å®šä¹‰è‡ªå·±çš„ç®¡é“æ“ä½œç¬¦
`|>`.

Elixir æºç ä¸­å®šä¹‰çš„ç®¡é“æ“ä½œç¬¦ `|>` åº”è¯¥æ˜¯æˆ‘ä»¬çš„èµ·ç‚¹.
æˆ‘ä»¬å¯ä»¥åœ¨
[`kernel.ex`](https://github.com/elixir-lang/elixir/blob/9a4d10e702f33d2fa47718cde05375b506b4a3d6/lib/elixir/lib/kernel.ex#L4073)
ä¸­å‘ç°å…¶å®šä¹‰:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmacro left |> right do
  [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

  fun = fn {x, pos}, acc ->
    Macro.pipe(acc, x, pos)
  end

  :lists.foldl(fun, h, t)
end
```

ä¸ç”¨ç‰¹åˆ«çš„ç†Ÿæ‚‰ Elixir çš„å®, åªéœ€è¦ç†è§£æœ€åçš„ `:lists.foldl/3`,
æˆ‘ä»¬å°±èƒ½å¤§æ¦‚ç†è§£ç®¡é“æ“ä½œç¬¦ `|>` çš„åŸç†äº†, å…¶å®ä¸åœ¨ Javascript ä¸­å®šä¹‰
`pipe` å‡½æ•°çš„ç®—æ³•ä¸€æ ·.

ä¸Šé¢çš„ä»£ç ä¸­, `t` å°±æ˜¯ `|>` çš„æ‰€æœ‰çš„å³æ“ä½œæ•° (å‡½æ•°) ç»„æˆçš„åˆ—è¡¨,
ä¹Ÿå°±æ˜¯å‡½æ•°æ‰€æœ‰è¢«å¾…ç»„åˆçš„å‡½æ•°çš„åˆ—è¡¨.

æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ç®¡é“æ“ä½œç¬¦ `|>` æ‰€ä½œçš„ä¼˜åŒ–, æœ¬è´¨å°±æ˜¯å¯¹å‡½æ•°è°ƒç”¨åˆ—è¡¨ `t` åˆå¹¶åŒç±»é¡¹.
å…·ä½“æ¥è¯´å°±æ˜¯, è¯†åˆ«è¿ç»­ç›¸é‚»çš„ `Enum.map(f1)`, `Enum.map(f2)` ...,`Enum.map(fn)`,
å¹¶æŠŠä»–ä»¬åˆå¹¶æˆä¸€ä¸ª `Enum.map(composed_fun)`.

é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª `Optimizer` è¡Œä¸º, è¿™ä¸ªè¿™ä¸ªè¡Œä¸ºåªæœ‰ä¸€ä¸ªå‡½æ•°, å°±æ˜¯ä¼˜åŒ–å‡½æ•°,
`optimize(t,list)`.

æ‰€ä»¥å¦‚æ­¤, æ˜¯å› ä¸º, è™½ç„¶ç°åœ¨æˆ‘ä»¬åªæ˜¯å®Œæˆ `Enum.map/2` ç›¸å…³çš„å®ç°,
ä½†æ˜¯å¯¹äºç®¡é“æ“ä½œç¬¦ `|>` çš„å³æ“ä½œæ•°, å¦‚æœå°†æ¥å‘ç°, é™¤ `Enum.map/2` ç»„æˆçš„é“¾æ¡å¤–,
è¿˜æœ‰å…¶ä»–çš„æƒ…å½¢å¯ä»¥ä¼˜åŒ–, é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦å¯¹æ–°æƒ…å½¢å®ç° `Optimizer` è¡Œä¸ºå°±å¥½äº†.

å®šä¹‰ `Optimizer` è¡Œä¸º, è®©æˆ‘ä»¬çš„ä»£ç æ›´å®¹æ˜“ç»„ç»‡.

```elixir
defmodule Optimizer do
  @callback optimize(t :: any, ast_list :: List.t()) :: List.t()

  defmacro __using__(_opts) do
    quote do
      import Kernel, except: [|>: 2]
      import Optimizer.Pipe
    end
  end
end
```

ç¬¬ 2 è¡Œæˆ‘ä»¬å®šä¹‰äº†ä¼˜åŒ–å™¨çš„æ¥å£.
è€Œ `__using__/1` çš„å®šä¹‰å¯ä»¥çœ‹ä½œæ˜¯ä¼˜åŒ–å™¨å¯¹å¤–æä¾›çš„ API.
ä¼˜åŒ–å™¨çš„ä½¿ç”¨è€…, åªéœ€è¦ `use Optimizer` å°±å¯ä»¥äº†ä½¿ç”¨ä¼˜åŒ–å™¨äº†,
ä¸ç”¨å…³å¿ƒä¼˜åŒ–å™¨å†…éƒ¨çš„å®ç°.

ç°åœ¨è®©æˆ‘ä»¬æ¥å®šä¹‰é’ˆå¯¹ `Enum.map/2` çš„ä¼˜åŒ–.
æˆ‘æŠŠæœ‰å…³ä¼˜åŒ–çš„ä»£ç éƒ½æ”¾åœ¨ `optimizer` ç›®å½•ä¸‹,
ä¸º `Enum.map/2` åšä¼˜åŒ–çš„æ¨¡å—, å‘½åä¸º `Optimizer.EnumMap`.

```elixir
defmodule Optimizer.EnumMap do
  @behaviour Optimizer

  @impl Optimizer
  def optimize(__MODULE__, list) do
    reduce_map(list)
  end

  defp reduce_map(ast_list) do
    ast_list
    |> group_map_call()
    |> Enum.map(&make_enum_mape/1)
  end

  defp group_map_call(ast_list) do
    for condidate_map_call <- ast_list, reduce: [] do
      [ele | rest] = acc ->
        if is_map_call_or_fun_group(ele) and
             is_map_call_or_fun_group(condidate_map_call) do
          fun_collection = collect_funs(condidate_map_call, ele)
          [fun_collection | rest]
        else
          [condidate_map_call | acc]
        end

      [] ->
        [condidate_map_call]
    end
    |> Enum.reverse()
  end

  @tag :funs_gruop_tag

  defp is_map_call_or_fun_group(ast) do
    case ast do
      {@tag, _} -> true
      {{{:., _, [{:__aliases__, _, [:Enum]}, :map]}, _, _}, 0} -> true
      _ -> false
    end
  end

  defp collect_funs(map1, map2) do
    fun1 = get_fun(map1)
    fun2 = get_fun(map2)

    funs =
      if is_list(fun2) do
        [fun1 | fun2]
      else
        [fun1, fun2]
      end

    {@tag, funs}
  end

  defp get_fun({@tag, funs}), do: funs

  defp get_fun(map) do
    [fun1] = elem(elem(map, 0), 2)
    fun1
  end

  defp make_enum_mape({@tag, funs}) do
    fun = compose(funs)

    ast = {{{:., [], [{:__aliases__, [], [:Enum]}, :map]}, [], [fun]}, 0}
    ast
  end

  defp make_enum_mape(v), do: v

  defp compose(list, acc \\ nil)

  defp compose([fun | funs], nil) do
    acc =
      quote do
        unquote(fun).()
      end

    compose(funs, acc)
  end

  defp compose([fun | funs], acc) do
    acc =
      quote do
        unquote(fun).() |> unquote(acc)
      end

    compose(funs, acc)
  end

  defp compose([], acc) do
    quote do
      fn v -> v |> unquote(acc) end
    end
  end
end
```

å‰é¢è¯´è¿‡, è¦è‡ªå®šä¹‰ç®¡é“æ“ä½œç¬¦ `|>`, ç°åœ¨æ˜¯å…‘ç°çš„æ—¶å€™äº†.

```elixir
defmodule Optimizer.Pipe do
  import Kernel, except: [|>: 2]
  alias Optimizer.{EnumMap}
  @optimizer [EnumMap]
  defmacro left |> right do
    [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

    fun = fn {x, pos}, acc ->
      Macro.pipe(acc, x, pos)
    end

    t = Enum.reduce(@optimizer, t, &apply(&1, :optimize, [&1, &2]))
    :lists.foldl(fun, h, t)
  end
end
```

å½“å®šä¹‰äº†æ›´å¤šçš„ä¼˜åŒ–å™¨çš„æ—¶å€™, åªéœ€è¦ä¿®æ”¹ä¸Šé¢ä»£ç çš„ ç¬¬ 3, 4 ä¸¤è¡Œä»£ç , å°±å¯ä»¥äº†.

ä¸Šé¢çš„ä»£ç , å¤§éƒ¨åˆ†éƒ½æ˜¯ç…§æ¬ Elixir çš„ Kernel æ¨¡å—ä¸­ç®¡é“æ“ä½œç¬¦ `|>` çš„å®šä¹‰,
åªæ˜¯å¢åŠ äº†ç¬¬ 12 è¡Œçš„å†…å®¹.

ç°åœ¨æ¥çœ‹çœ‹, ä»£ç æ˜¯ä¸èƒ½æŒ‰ç…§æˆ‘ä»¬çš„é¢„æœŸå·¥ä½œ:

```elixir
use Optimizer

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

çœ‹èµ·æ¥, åŠŸèƒ½æµ‹è¯•é€šè¿‡äº†, ä½†æ˜¯æˆ‘ä»¬æ¯•ç«Ÿæ˜¯åšä¼˜åŒ–çš„,
æˆ‘ä»¬çš„ä»£ç çœŸçš„èƒ½æå‡ä»£ç çš„æ‰§è¡Œæ•ˆç‡å—?
è®©æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹.

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    use Optimizer

    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  test "Optimizer of |> for Enum.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t1 * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

å…¶ä¸­æœ‰ä¸€æ¬¡, ä»£ç çš„è¾“å‡ºæ˜¯è¿™æ ·çš„:

> speed up -1.5641347109939043%.

è¿™å°±å°´å°¬äº†ğŸ˜’. ä¼˜åŒ–åçš„ä»£ç ä¸æ˜¯æé€Ÿäº†, åè€Œå˜æ…¢äº† 1.5 ä¸ªç™¾åˆ†ç‚¹. å¯æ˜¯ä¸ºä»€ä¹ˆä¼šè¿™æ ·å•Š?

è¿™æ˜¯å› ä¸º LiveBook ä»£ç  Cell æœ¬è´¨ä¸Šæ˜¯è§£é‡Šæ‰§è¡Œçš„, å°±åƒæˆ‘ä»¬ä¸èƒ½ä»¥ IEx ä¸­çš„ä»£ç è¿è¡Œæ—¶é—´,
æ¥è¡¡é‡ä»£ç çš„æ•ˆç‡ä¸€æ ·, æˆ‘ä»¬ä¹Ÿä¸èƒ½ç”¨ LiveBook çš„ Cell çš„æ‰§è¡Œæ—¶é—´æ¥è¡¡é‡ä»£ç çš„æ•ˆç‡.

è¿™ä¸ªä¼˜åŒ–çš„å®ç°, å…¶å®å¹¶ä¸æ˜¯é‚£ä¹ˆçš„å¤æ‚, ä¸ºä»€ä¹ˆ Elixir ç¼–è¯‘å™¨ä¸è¿™æ ·åšå‘¢?
è¿™é‡Œæœ‰ä¸¤ä¸ªåŸå› . ç¬¬ä¸€åŸå› , å°±æ˜¯ Elixir æ ‡å‡†åº“ä¸­æœ‰ `Stream` æ¨¡å—,
æ–‡æ¡£ä¸­, æ˜ç¡®æåˆ° `Stream.map` ä¼šç»„åˆå‡½æ•°çš„. ä¹Ÿå°±æ˜¯è¯´,
Elixir æ˜¯ä»¥ `Stream.map` æ¥å®Œæˆæˆ‘ä»¬è¿™é‡Œçš„å·¥ä½œçš„.ä¾‹å¦‚æˆ‘ä»¬ä¸Šé¢çš„ä»£ç ,
æˆ‘ä»¬åªæ˜¯ç”¨ `Stream` æ›¿æ¢äº† `Enum`. å°±è·å¾—äº†ç›¸åŒçš„ç»“æœ.

```elixir
range
|> Stream.map(fun1)
|> Stream.map(fun2)
|> Enum.to_list()
|> IO.inspect(label: "result of map chain")
```

é‚£ä¹ˆæˆ‘æ˜¯ä¸æ˜¯è§£å†³äº†ä¸€ä¸ªé”™è¯¯çš„é—®é¢˜çš„é—®é¢˜å‘¢?

æˆ‘çš„ç­”æ¡ˆæ˜¯: ä¸æ˜¯çš„. è¿™ä¸ªå·¥ä½œä¾æ—§æ˜¯æœ‰æ„ä¹‰çš„.

åœ¨å¯¹ä¼˜åŒ–åšæ•ˆç‡æµ‹è¯•çš„æ—¶å€™, æˆ‘ä»¬å‘ç°æœ‰æ—¶å€™, ç†è®ºä¸Šç»å¯¹ä¸æœ‰åº”è¯¥ä¸‹é™çš„ä»£ç ,
æµ‹è¯•æœ‰æ—¶å±…ç„¶ä¼šä¸‹é™ 1.5%. é‚£ä¹ˆ Stream ç‰ˆæœ¬çš„ä¼˜åŒ–å‘¢?
ä¼šæ¯”æˆ‘ä»¬çš„çš„ä»£ç æ•ˆç‡æ›´é«˜å—?
è®©æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹:

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Stream.map(&(&1 + 1))
      |> Stream.map(&(&1 - 1))
      |> Enum.to_list()
    end
  end

  test "Enum.map vs Stream.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

è¿™æ¬¡è¿è¡Œçš„ç»“æœæ›´åŠ ç³Ÿç³•, å’Œ `Enum.map` ç›¸æ¯”,
`Stream.map` ç‰ˆæœ¬çš„ä»£ç æ•ˆç‡ä¸‹é™äº† 100% è¿˜å¤š.

1%~2% çš„æ•ˆç‡å·®å¼‚æˆ‘ä»¬è¿˜èƒ½è§£é‡Šä¸ºä»£ç æ‰§è¡Œè¿‡ç¨‹ä¸­å¶ç„¶å› ç´ å¸¦æ¥çš„,
ä½† `Stream.map` å’Œ `Enum.map` çš„å·¨å¤§å·®å¼‚ç»å¯¹ä¸èƒ½å½’ç»“ä¸ºå¶ç„¶.

æ‰€ä»¥ `Stream.map` è™½ç„¶å®Œæˆäº†çš„å‡½æ•°çš„ç»„åˆ, ä½†æ˜¯å´å¹¶æ²¡æœ‰æå‡æ•ˆç‡.

Elixir çš„ `Enum.map` ä¸ç»„åˆå‡½æ•°çš„ç¬¬äºŒä¸ªåŸå› æ˜¯, Elixir ä¸æ˜¯ä¸€ä¸ªçº¯çš„å‡½æ•°ç¼–ç¨‹è¯­è¨€.
ä¼ é€’ç»™ `Enum.map` çš„å‡½æ•°ä¸ä¿è¯æ²¡æœ‰å‰¯ä½œç”¨çš„. è€Œç†è®ºä¸Šæ¥è¯´,
åªæœ‰å½“ä¼ é€’ç»™ `Enum.map` çš„å‡½æ•°æ˜¯çº¯å‡½æ•°çš„æ—¶å€™, æ‰å¯ä»¥ç»„åˆå‡½æ•°.
ä½†æ˜¯è¦åœ¨ç¼–è¯‘æ—¶åˆ¤æ–­ä¸€ä¸ªå‡½æ•°ä¸­æ˜¯å¦æœ‰å‰¯ä½œç”¨, è¿™åŸºæœ¬ä¸Šåšä¸åˆ°,
æ‰€ä»¥ Elixir çš„æ ‡å‡†åº“ä¸­ç®¡é“æ“ä½œç¬¦ `|>`å¹¶ä¸å¯¹ `Enum.map` åšå‡½æ•°çš„ç»„åˆ.

æˆ‘ä»¬çš„ä¼˜åŒ–å™¨, å¿½ç•¥äº†å‡½æ•°ä¸­çš„å‰¯ä½œç”¨è€Œå¼ºè¡Œå¯¹å‡½æ•°åšäº†ç»„åˆ.
æŠŠä¼˜åŒ–å™¨åšæµ‹è¯•çš„ä»£ç , ä¿å­˜åˆ°æ–‡ä»¶ä¸­, ä½¿ç”¨ `mix test` æ¥é‡æ–°æµ‹è¯•, å°±ä¼šå‘ç°,
ä½¿ç”¨ä¼˜åŒ–å™¨çš„ä»£ç ,æ•ˆç‡æœ‰äº† 30%~40% çš„æ•ˆç‡æå‡.

æ‰‹åŠ¨ç»„åˆåŠŸèƒ½ä¸€æ ·çš„å‡½æ•°, å…¶æ•ˆç‡å’Œä½¿ç”¨ä¼˜åŒ–å™¨çš„ä¸€æ ·.
è¿™å°±æ˜¯å‰é¢æˆ‘çš„è¯´è¿™ä¸ªå·¥ä½œçš„æ„ä¹‰æ‰€åœ¨.
