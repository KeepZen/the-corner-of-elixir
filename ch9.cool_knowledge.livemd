# 冷知识

## 函数参数格式

在阅读 Elixir 文档的&Lt;类型规范&Gt;的[&Lt;内建的类型&Gt;](/elixir/1.13.1/typespecs.html#built-in-types)小节中, 我发现了一个以前没有注意到的知识: Elixir 中函数参数个数的限制.

[^term]: 见[Erlang参考手册数据类型](https://www.erlang.org/doc/reference_manual/data_types.html#terms)相关章节.

> arity() 定义为 0..255.

这是说, 我们的函数参数个数最多 255个吗? 要写一个 写 255 个变量, 这还真的是个体力活.
但是我们是程序员, 对于这种重复性体力劳动, 当然要用编程的方式来完成了. 
Elixir 提供了 `Code.compile_string/1` 和 `Code.eval_string/1` 函数,
可以把他们看作是 Elixir 语言为我们提供的编译器和解释器的 API.
我们可以使用这两个函数编译或解释执行对应 Elixir 代码.

通过调整生成的函数参数的个数, 可以找到函数参数个数的上限的设定.

```elixir
defmodule Explore.Arity do
  defp generate_code(arity, name_fun?) do
    params_list =
      1..arity
      |> Enum.map(&"p#{&1}")

    params_src = Enum.join(params_list, ",")
    body_src = Enum.join(params_list, " + ")

    if name_fun? do
      """
      defmodule A do
        def test(#{params_src}) do
          #{body_src}
        end
      end
      """
    else
      "fn #{params_src} -> #{body_src} end"
    end
  end

  @default_opt [fun_named?: false, compiled?: true]
  def check(arity, opt \\ []) do
    opt = Keyword.merge(@default_opt, opt)

    src = generate_code(arity, opt[:fun_named?])

    if opt[:compiled?] do
      Code.compile_string(src)
    else
      Code.eval_string(src)
    end
  rescue
    v ->
      error_tip = if opt[:compiled?], do: "compile error", else: "praser error"
      IO.inspect(v, label: error_tip)
      :bad
  else
    v ->
      IO.inspect(v, label: "check done")
      :ok
  end
end
```

让我们用单元测试功能来完成我们探索. 因为用代码, 能更清楚地表达我的意图.

```elixir
ExUnit.start(auto_run: false)

defmodule ArityTest do
  use ExUnit.Case, async: true
  alias Explore.Arity

  test "the uplimit of arity for anonymous function in complier " do
    assert Arity.check(255) == :ok
    assert Arity.check(256) == :bad
    IO.puts("")
  end

  test "the uplimie of arity for named function in complier " do
    assert Arity.check(255, fun_named?: true) == :ok
    assert 1..255 |> Enum.sum() == apply(A, :test, Enum.to_list(1..255))

    assert Arity.check(256, fun_named?: true) == :ok
    assert_raise UndefinedFunctionError, fn -> apply(A, :test, Enum.to_list(1..256)) end
    IO.puts("")
  end

  test "the uplimit of arity for anonymous function in parser" do
    assert Arity.check(20, compiled?: false) == :ok
    assert Arity.check(21, compiled?: false) == :bad
    IO.puts("")
  end

  test "the uplimit of arity for named function in parser" do
    assert Arity.check(20, fun_named?: true, compiled?: false) == :ok
    assert apply(A, :test, 1..20 |> Enum.to_list()) == 1..20 |> Enum.sum()

    assert Arity.check(21, fun_named?: true, compiled?: false) == :ok
    assert_raise UndefinedFunctionError, fn -> A.test(Enum.to_list(1..21)) end
    IO.puts("")
  end
end

ExUnit.run()
```

通过上面的实验, 可以得出以下结论:

* 在编译器中
  1. 对于匿名函数, 参数个数多于 255 个, 编译器报 UndefineFuntionError
  2. 对于命名函数, 参数个数多于 255 个, 编译器并不报错, 但是调用这个函数,
     运行时会产生 UndefineFuntionError
* 在解析器中
  1. 对于匿名函数, 参数个数多于 20 个, 解释器就会报 UndefinedFunctionError
  2. 对于命名函数, 参数个数多于 20 个, 解释器不会报错, 但是调用这个函数,
     运行时会产生 UndefineFunctionError

## 原子

1. BEAM 中原子个数上限默认为: 1048577.
2. 原子的内存长度是固定的. 原子占用系统一个字 (word) 长度的内存.
3. 原子内容最长可以有 255 个字符.

现在有提议对原子也做垃圾收集, 那么也许以后的 BEAM 实现原子上限就会被解除, 
那么对于嵌入式的系统, 用原子来代替比较长的字符串可以达到节省内存的目的.

```elixir
ExUnit.start(auto_run: false)

defmodule AtomLimitTest do
  use ExUnit.Case, async: true

  test "255 byte long atom is ok" do
    assert 1..255
           |> Enum.map(fn _ -> "1" end)
           |> Enum.join("")
           |> String.to_atom()
  end

  test "256 byte long auto is up the atom limit" do
    assert_raise SystemLimitError, fn ->
      1..256
      |> Enum.map(fn _ -> "2" end)
      |> Enum.join("")
      |> String.to_atom()
    end
  end
end

ExUnit.run()
```

调用 `:eralng.memory(:atom_used)` 可以看出当当我们的系统中, 原子使用的内存.
当我么

## 变量名的限制

变量名实际上也是原子, 所以变量名接受原子的限制, 也就是说变量名不能长于 255 个字符, 
但是实际上, 系统对变量还有一些限制, 在 Elixir 中表示变量的原子有统一的格式: `_{var_name}@1`.
所以, 变量名只能由 255-3 = 252 个字节长度.

我们可以通过下面的代码来得出这个结果.

```elixir
create_var = fn l ->
  1..l
  |> Enum.map(fn _a -> "l" end)
  |> Enum.join("")
end

var = create_var.(252)
assign = "#{var} = 1"
{1, _} = Code.eval_string(assign)
IO.puts("variable length equal 252 is ok")
var = create_var.(253)
assign = "#{var} = 1"
Code.eval_string(assign)
```
