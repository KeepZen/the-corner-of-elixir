<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>定制新结构 - 角落里的长生不老药</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="ch01.intruction.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="ch02.plus_and_minus.html"><strong aria-hidden="true">2.</strong> 加和减</a></li><li class="chapter-item expanded "><a href="ch03.pattern_match.html"><strong aria-hidden="true">3.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="ch04.parenthese.html"><strong aria-hidden="true">4.</strong> 括号</a></li><li class="chapter-item expanded "><a href="ch05.new_constructor.html" class="active"><strong aria-hidden="true">5.</strong> 定制新结构</a></li><li class="chapter-item expanded "><a href="ch06.async_programe.html"><strong aria-hidden="true">6.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="ch07.pipe.html"><strong aria-hidden="true">7.</strong> 管道操作符</a></li><li class="chapter-item expanded "><a href="ch08.error_handle.html"><strong aria-hidden="true">8.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="ch09.module.html"><strong aria-hidden="true">9.</strong> 模块</a></li><li class="chapter-item expanded "><a href="ch10.protocol_and_behaviour.html"><strong aria-hidden="true">10.</strong> 协议与行为</a></li><li class="chapter-item expanded "><a href="ch11.macro.html"><strong aria-hidden="true">11.</strong> 如何理解宏</a></li><li class="chapter-item expanded "><a href="ch12.process.html"><strong aria-hidden="true">12.</strong> 进程</a></li><li class="chapter-item expanded "><a href="chx.cold_knowledge.html"><strong aria-hidden="true">13.</strong> 附录 冷知识</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">角落里的长生不老药</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="第五章-定制新结构"><a class="header" href="#第五章-定制新结构">第五章 定制新结构</a></h1>
<h2 id="定义自己的控制控制结构"><a class="header" href="#定义自己的控制控制结构">定义自己的控制控制结构</a></h2>
<p>Elixir 是一个特别灵活的语言, 这不但是说, Elixir 本身提供的语法结构非常灵活,
更加重要的是, 如果我们不满意 Elixir 提供的控制结构, 那么可以按照自己的意图,
来定义自己的控制结构.</p>
<h2 id="赋值"><a class="header" href="#赋值">赋值</a></h2>
<h3 id="赋值与思维流"><a class="header" href="#赋值与思维流">赋值与思维流</a></h3>
<p>确切的说, <code>=</code> 叫做匹配操作符, 而不是赋值操作符.
但是变量可以匹配任意的值, 所以实际上, Elixir 中还是用 <code>=</code> 来做赋值的操作.</p>
<p>在其他编程语言中, 赋值是一个非常简单的操作, 因为赋值语句非常简短,
基本上一眼就能看清楚赋值的结果是什么.</p>
<p>其他语言中, 块语句不是表达式, 但是在 Elixir 中语句块也是表达式.
当赋值语句的右侧出现的是语句块的时候, 代码序列往往和思维序列不协调.</p>
<p>首先让我来描述一下, 我阅读这样代码时的思维过程.
因为是一个块语句, 也就是说 <code>=</code> 的右边需要多个步骤, 多个操作才能完成最后的结果.
阅读代码的时候, 思维自然要跟随代码, 以理解代码的意图.
当多个步骤执行完成后, 在我的思维中, 往往忘记了 <code>=</code> 
的左边的表达式是什么了, 因为最后结果和变量之间的距离太远了, 这个距离既是物理上的,
也是心理上的.</p>
<p>而写一个块语句的时候, 在完成整个功能之前, 实际上我不知道最后的结果会是什么,
甚至不知道, 这个块语句就是函数最后的结果, 还是只是计算的中间过程.
所以基本上, 我也是先完成块语句然后再决定是否需要把结果赋值给一个变量的.</p>
<p>当我意识到需要把块语句的结果赋值给一个变量的时候,
这时候光标往往是停留在块语句的结尾处, 要完成赋值语法, 只好移动光标,
这让我有些烦恼.</p>
<p>我更希望写出的代码能和思维流一致, 这样写代码的时候流畅, 阅读的时候也更轻松.</p>
<h3 id="设计赋值语句"><a class="header" href="#设计赋值语句">设计赋值语句</a></h3>
<p>Elixir 支持宏编程, 这就给我们提供了设计自己的赋值语句提供了可能.
但是 <code>=</code> 是一个特殊形式, 所以不能从新定义它, 而只能利用 <code>=</code>
提供的功能, 来重新设计新的语法糖.</p>
<p>首先让我来描述清楚, 我想要的语法是什么样的.</p>
<pre><code class="language-elixir">if exprestion do
  :zero
else
  :is_not_zero
end
|&gt; assign(to: v)
</code></pre>
<p>这样简单的, 可以使用 Elixir 提供的语法直接转化成为一行的代码:
<code>v = if exprestion, do: :zero, else: :is_not_zero</code>.
这个时候使用 <code>assign/2</code> 是没有必要的. 但是当 <code>if</code> 语句不能转化成一行的代码时候,
或者当需要把 <code>case</code> 或 <code>cond</code> 结果赋值为一个变量的时候,
代码序列和思维流之间的阻抗就更加的明显了. 这个时候,
使用 <code>assign/2</code> 能让代码易写易读.</p>
<p>假设我们要控制一个机器人, 机器人使用一个 GenServer 表示,
它的状态是 <code>%{x: x, y: y, diriction: direction}</code>,
表示机器人所在的位置 <code>x, y</code> 和面对的方向
(<code>:E</code>, 东方; <code>:W</code>, 西方;<code>:N</code>, 北方; <code>:S</code>, 南方).
当机器人接受到转弯的指令后, 就会按照指令转弯, 从而改变自己的状态.
那么处理右转的代码就是这样:</p>
<pre><code class="language-elixir">def handler_cast({:turn, :right}, %{direct: direct}=state) do
   direct = case direct do
     :N -&gt; :E
     :E -&gt; :S
     :S -&gt; :W
     :W -&gt; :N
   end

   {:noreply, %{state| direct: dircet}}
end
</code></pre>
<p>那么在 <code>assign/2</code> 的帮助下, 可以把上面的代码重构为:</p>
<pre><code class="language-elixir">def handler_cast({:turn, :right}, %{direct: direct}=state) do
   case direct do
     :N -&gt; :E
     :E -&gt; :S
     :S -&gt; :W
     :W -&gt; :N
   end
   |&gt; assign(to: direct)

   {:noreply, %{state| direct: dircet}}
end
</code></pre>
<p>这样的代码整洁了不少吧? 现在让我们来看看, 如何来实现 <code>assgin/2</code>.</p>
<h3 id="赋值实现"><a class="header" href="#赋值实现">赋值实现</a></h3>
<p>我们需要把 <code>assgin/2</code> 定义为一个宏, 这个宏的功能非常的简单, 只是 <code>=</code> 的语法糖嘛, 所以可以这样来实现.</p>
<pre><code class="language-elixir">defmodule Corner.Assign do
  defp do_assign(value, pattern) do
    quote do
      unquote(pattern) = unquote(value)
    end
  end
  defmacro assign(value, to: pattern), do: do_assign(value,pattern)
  #...other
end
</code></pre>
<p>这个实现, 完成了我们期望的工作.</p>
<p>这里 <code>assign/2</code> 并不改变直接使用 <code>=</code> 的语义代码的语义.
调用 <code>assign(value, to: pattern)</code>,
当 <code>pattern</code> 和 <code>value</code> 不匹配的时候, 依旧会抛出匹配错误,</p>
<p>因为 <code>assign(value, to: pattern)</code> 本质上就是 <code>pattern = value</code>,
所以任何可以作为匹配操作符 <code>=</code> 左值的语法, 都可以作为 <code>assign/2</code> 的 <code>:to</code> 的值,
毕竟 <code>assign/2</code> 仅仅是语法糖.</p>
<p>这样的语法糖, 让代码更简洁, 美观, 如此而已.</p>
<p><code>assgin/2</code> 现在帮助我们减少了代码的序列和思维流之间的阻抗,
但是像上面对 <code>hanlder_cast/2</code> 的重构那样,
最后的返回语句不能使用管道操作符 <code>|&gt;</code> 连接起来, 这样的代码序列,
反映到思维流上, 就是思维流的打断.</p>
<p>如果 <code>assign/2</code> 能帮助我们把思维流也接续起来, 那么写 elixir 代码就更加愉悦了.</p>
<p>能让思维流保持连续的代码, 我认为是这样的:</p>
<pre><code class="language-elixir">def handler_cast({:trun, :right}, %{direct: direct}=state) do
   case direct do
     :N -&gt; :E
     :E -&gt; :S
     :S -&gt; :W
     :W -&gt; :N
   end
   |&gt; assign(to: direct, do: %{state| direct: direct})
end
</code></pre>
<p>再假设有现在我们有三个函数, 分别是 <code>step1:: ()-&gt;any</code>,
<code>step2:: (any) -&gt;{:ok,t}|{:error,any}</code> 和 <code>step3::(t)-&gt;any</code>.
<code>step1</code> 的结果作为 <code>step2</code> 的输入, <code>step2</code> 返回 <code>{:ok,v}</code> 时.
<code>v</code> 作为 <code>step3</code> 输入.
那么无论是:</p>
<pre><code class="language-elxiir">{:ok, v} = step1()
|&gt; step2()

step3(v)
</code></pre>
<p>还是:</p>
<pre><code class="language-elixir">step1()
|&gt; step2()
|&gt; assign(to: {:ok, v})

step3(v)
</code></pre>
<p>阅读的时候, 思维流都是被打断的.
但如果 <code>assign</code> 允许我们写下面的代码, 就能让思维流保持连续.</p>
<pre><code class="language-elixir">step1()
|&gt; step2()
|&gt; assign(to: {:ok, v}, do: v)
|&gt; step3()
</code></pre>
<p>也就是说, 为<code>assign/2</code> 在添加一个可省略的 <code>:do</code> 选项, 就能让思维流接续起来.</p>
<p>这个实现也非常的容易, 当我们完成 <code>pattern = value</code> 的赋值后, 再计算 <code>do: expression</code>
的值可以了.</p>
<pre><code class="language-elixir">defmodule Corner.Assign do
  #assing(value, to: pattern)
  defp do_assign(value, pattern, block) do
    quote do
      unquote(pattern) = unquote(value)
      unquote(block)
    end
  end
  defmacro assign(value, to: pattern, do: expression) do
    do_assign(value, pattern, expression)
  end
  #...
end
</code></pre>
<p>有了 <code>assgin(value,to: pattern, do: block)</code> 的帮助,
上面的多步骤组合的代码就可以这样来写.</p>
<pre><code class="language-elixir">defmodule Demo do
  import Corner.Assgin, only: [assign: 2]
  defp step1(), do: 1
  defp step2(v), do: {:ok, v + 1}
  defp step3(v), do: IO.inspect(v, label: &quot;in step3 v&quot;)
  
  def do_work() do
    step1()
    |&gt; step2()
    |&gt; IO.inspect(label: &quot;after setp2&quot;)
    |&gt; assign(to: {:ok, v}, do: v)
    |&gt; IO.inspect(label: &quot;after assign/2&quot;)
    |&gt; step3()
  end
end

Demo.do_work()
#after setp2 : {:ok, 2}
#after assign/2 : 2
#in step3 v: 2
</code></pre>
<p>在 <code>assign/2</code> 的帮助下, 我们写的 Elixir 代码, 几乎也可以做到 point-free 了.</p>
<p>如果赋值之后, 我们需要做非常多的计算, 那么使用 <code>do: (...)</code> 就不那么方便,
对这种情况, 可以非常简单的提供一个 <code>assign(value, [to: pattern] ,do: block)</code>
宏来解决.</p>
<pre><code class="language-elixir">defmacro assign(value, [to: pattern], do: expression) do
  quote generated: true do
    unquote(pattern) = unquote(value)
    unquote(expression)
  end
end
</code></pre>
<p>在导入我们的宏之后, 就可以如此来使用赋值语句了:</p>
<pre><code class="language-elixir">import Corner.Assign
function()
|&gt; assing(to: {:ok, v}) do
  do_lot_of_work_with(v)
end
</code></pre>
<p>可以看出, 在管道操作符右侧, 使用 <code>do-end</code> 块会使得代码编码的不那么整齐.
所以最终的库中, 我没有提供 <code>assign/3</code> 这个宏.</p>
<p>正常的情况下, 使用 <code>:do</code> 选项中应该只有一个表达式.
如果发现 <code>:do</code> 选项中, 需要两个或更多的表达式才能完成最终的工作,
那么第一种选择是把 <code>:do</code> 选项中的语句提取为一个新的函数.
第二种选择是在 <code>:do</code> 使用变量,绑定中间结果.
然后在后续的代码中, 使用变量绑定的值, 完成剩余的工作.</p>
<pre><code class="language-elixir">step0()
|&gt; step1()
|&gt; assgin(to: {:ok, v}, do: v)
|&gt; extract_function_from_do()
|&gt; step2()
|&gt; ...
</code></pre>
<p>或者</p>
<pre><code class="language-elixir">step0()
|&gt; assign(to: {:ok, v}, do: tem = do_sample_with(v) )

the_code_use_tems
|&gt; step2()
|&gt; ...
</code></pre>
<p><code>import</code> 语句非常的方便, 但是问题在于, 如果是全部导入的话, 从文本上,
我们不知道到底导入什么内容. 所以 Elixir 官方的文档中告诉我们, 应该优先使用 <code>require</code>
其实才是 <code>import</code> 最后是使用 <code>use</code>. <code>assgin</code> 宏不是操作符, 从功能上来说,
完全可以不使用 <code>import</code> 语句. 使用 <code>require</code> 语句之后, 我们就可以带着模块名来使用,
<code>assgin/2</code> 宏了. 例如 <code>1 |&gt; Corner.Assgin.assgin(to: v, v + 1)</code>.
语法上, 这样显的非常的啰嗦. 可以定义宏 <code>to/2</code> 来消除这种啰嗦.</p>
<pre><code class="language-elixir">defmacro to(value, pattern), do: do_assign(value, pattern)
defmacro to(value, p, do: block), do: do_assign(value, p, block)
</code></pre>
<p>这样, 使用 <code>require Corner.Assgin, as: Assign</code> 后, 使用 <code>to/2</code>
可以使得代码变得整洁.</p>
<pre><code class="language-elixir">require Corner.Assign, as: Assign
some_code()
|&gt; Assgin.to({:ok,v}, do: v + 1)
#...
</code></pre>
<h2 id="with"><a class="header" href="#with">with</a></h2>
<p>如果要选<strong>最不喜欢的语言结构</strong>, Elixir 的 <code>with</code> 是我的答案.</p>
<p>我所以不喜欢这个语句结构, 首先是像 <code>with</code> 语句中的 <code>&lt;-</code> 暗示的那样,
其中的代码序列和逻辑思维流之间存在阻抗. 其次, <code>with</code> 结构的代码布局非常的不美观.</p>
<p>例如代码:</p>
<pre><code class="language-elixir">with                     # with 头部开始
     {:ok, a} &lt;- fun1(), # 产生子代码
     #...                # 更多产生子代码
     {:ok, b} &lt;- fun2(a) # with 头部结束
do                       # with 体开始
     action_with_a_and_b # with 体结束
else                     # 尾部开始
   patter1 -&gt; hanlder_error1
   patter2 -&gt; hanlder_error2 # 尾部结束
end
</code></pre>
<p>这个 <code>with</code> 结构, 像代码中注释的那样, 可以分成 3 部分, 分别是<strong>头</strong>, <strong>体</strong>和<strong>尾</strong>.
通常情况下, <code>with</code> 代码就像上面的片段展示的这样, <code>with</code> 头往往有多个语句,
而 <code>with</code> 体却只有一行或很少的几行代码. 像这样的头部或者参数部分, 
多于体或者正文的语法结构, 除了 <code>with</code> 语句外, 我没有见过别的语法有这样的布局.
这样的布局, 给我的感觉是头重脚轻, 极度不协调.
看到这样的代码, 不由自主地, 我的脑海中总是浮现出有染色体缺陷的畸形儿的形象.
所以我非常的不喜欢这个语法结构.</p>
<p>如果不使用 <code>with</code> 语句, 等价的代码应该如何写呢? 我认为可以写成这样:</p>
<pre><code class="language-elixir">try do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
rescue
  %MatchError{term: term}-&gt;
    case term do
      pattern1 -&gt; handler_error1
      pattern2 -&gt; handler_error2
    end
end
</code></pre>
<p>对于没有 <code>else</code> 部分的 <code>with</code> 语句, 就更加简单:</p>
<pre><code class="language-elixir">try do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
rescue
  %MatchError{term: term} -&gt; term
end
</code></pre>
<p>而如果语句已经在一个块结构中了, 代码还可以进一步的精简:</p>
<pre><code class="language-elixir">def fun do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  atction_with_a_and_b
rescue
  %MatchError{term: term} -&gt; term
end
</code></pre>
<p>所以我认为本质上, <code>with</code> 语句只是帮助我们写了 <code>try</code> 块.
我认为理想的 <code>with</code> 语句应该只要 <strong>体</strong> 和 <strong>尾</strong> 两部分就够了.</p>
<h3 id="特殊表达与保留字"><a class="header" href="#特殊表达与保留字">特殊表达与保留字</a></h3>
<p>在前面的章节中, 已经多次出现 <strong>特殊表单</strong> (Special Forms)这个短语了,
但是特殊表单到底意味着什么呢?</p>
<p>我最初的理解, 特殊表单就像是别的语言中的关键字或者保留字. 这些符号和词汇,
不但有语言规定的意义而且不能用作变量名和函数名, 现在不少的语言,
对保留字的限制有所放宽, 比如 Javascript 中, 保留字虽然还不允许作为变量存在,
但是已经可以作为对象的方法或者字段名了.</p>
<p>在 Elixir 中, 有些特殊表单是没法用 Elixir 的语法来实现的.</p>
<p>比如 <code>with</code> 这个特殊表单, 它的特殊就在于其参数个数是不定的,
而 Elixir 中, 无论是函数还是宏的定义, 都不允许不定参数,
所以使用 Elixir 自身的语法是没法定义 <code>with</code> 这样的参数个数不定的宏.
但是 <code>with</code> 可以作为变量吗? 可以作为我们的函数名吗?
让我们来探索一下.</p>
<pre><code class="language-elixir">with = 2
IO.inspect(with == 2, label: &quot;with can used as variable&quot;)

with {:ok, a} &lt;- {:ok, 1},
     {:ok, b} &lt;- {:ok, a + 2} do
  a + b
end
|&gt; then(&amp;(&amp;1 == 4))
|&gt; IO.inspect(label: &quot;with can still work&quot;)

defmodule A do
  def with(a, b), do: a + b
end

A.with(1, 2)
|&gt; then(&amp;(&amp;1 == 1 + 2))
|&gt; IO.inspect(label: &quot;with can use as function name&quot;)
</code></pre>
<p>特殊表居然可以用作变量和函数名. 而且即使用作变量, 也不影响它作为特殊表单的功能.</p>
<p>但是保留字不一样, Elixir 中也有保留字, 虽然非常非常的少.
只有: <code>true</code>, <code>false</code>, <code>nil</code>,<code>when</code>, <code>and</code>, <code>or</code>, <code>not</code>,<code>in</code>, <code>fn</code>, <code>do</code>,
<code>end</code>,<code>throw</code>, <code>catch</code>,<code>rescue</code>, <code>after</code> 和 <code>else</code>, 共 16 个.
但是 <code>with</code> 不是, 只要不是保留字, 就可以作为变量, 以及函数名, 甚至模块名.</p>
<p>从上面的代码的输出中, 我们可以看出, 实际上 Elixir 对 <code>with</code> 几乎没有做限制.</p>
<p>我不满意 <code>with</code> 结构, 现在知道, 我们可以使用 <code>with</code> 来定义宏.
但是这不是一个好决定.</p>
<p>首先, 使用 <code>with</code> 作为宏的名字, 使得定义的宏不能直接导入到客户端的上下文中,
而只能用 <code>require</code> 加载宏, 然后带着模块名来使用我们定义的宏,
像上面的代码第 15 行展示的那样, 使用模块前缀来调用模块中的, 以 <code>with</code> 命名的宏.
因为特殊表单 (这里是 <code>with</code>) 不允许被覆盖, 我们不能通过
<code>import Kernel.SpecialForms, expect: [with: 1]</code> 来排除它.</p>
<pre><code class="language-elixir">defmodule CanNotExceptSpecailForm do
  import Kernel.SpecialForms, except: [with: 1]
  # ... other code not use Kernel.with
end
</code></pre>
<p>所以, 只要向环境导入特殊表单同名且参数个数一样的函数或宏, 比如 <code>A.with/1</code>,
就会引发了编译器的报错.</p>
<p>最后, 即使不是特殊表达, 而是一般的宏, 如果我们自定义的和 <code>Kernel</code> 模块中的不兼容的话,
还是不建议使用同名覆盖的策略. 让我们看以下, 假如我们要覆盖 <code>if/2</code> 这个宏会发生什么吧.</p>
<pre><code class="language-elixir">defmodule IF do
  import Kernel, except: [if: 2]

  defmacro __using__(_opt) do
    quote do
      import Kernel, except: [if: 2]
      import IF
    end
  end

  defmacro if(a, b) do
    a &amp;&amp; b
  end
end

defmodule ExceptIfButStillUseIt do
  use IF
  a = 1
  if(a, IO.puts(&quot;hello&quot;))
  # ... other code use the IF.if
  Kernel.if(a, do: IO.puts(a))
end
</code></pre>
<p>这里的问题主要是两点:</p>
<ol>
<li>对于不熟悉我们的模块的人来说, 看到第 19 行的 <code>if</code> 语句会让非常的困惑.</li>
<li>在已经导入我们的宏的上下文中, 如 19 行那样, 必须使用 <code>Kernel.if</code> 的时候,
就只能带着 <code>Kernel</code> 模块前缀了.</li>
</ol>
<p>核心模块中提供的宏, 特殊表单和保留字, 编译器对它们的限制, 可以总结为下表.
| 标识符类型 | 举例 | 用作普通标志? | 可以被覆盖? |
|--------|----|----|---|
| 一般标识符 | <code>if</code> | 可以 | 是的 |
| 特殊表达 | <code>with</code>, <code>case</code> <code>cond</code> | 可以  | 不可以 |
| 保留字 | <code>fn</code>, <code>do</code> 等 | 不可以 | 不可以 |</p>
<p>回到 <code>with</code> 的话题上, 现在知道, 我们定义的新宏, 不应该命名为 <code>with</code>,
那么应该叫什么呢?</p>
<p>Erlang 的新版本 OTP 25 中引入了新的特性 <code>maybe</code><sup class="footnote-reference"><a href="#erlang-maybe">1</a></sup>.
它实际上和 <code>with</code> 解决一样的问题. 因此, 为了向 Erlang 靠拢,
我们以 <code>maybe</code> 来命名我们定义的宏.</p>
<div class="footnote-definition" id="erlang-maybe"><sup class="footnote-definition-label">1</sup>
<p>详细内容见, https://www.erlang.org/doc/reference_manual/expressions.html#maybe</p>
</div>
<h3 id="maybe-的用法"><a class="header" href="#maybe-的用法">maybe 的用法</a></h3>
<p>首先, 让我们确定如何使用 <code>maybe</code>.
对于使用 <code>with</code> 的代码:</p>
<pre><code class="language-elixir">with                     # with 头部开始
     {:ok, a} &lt;- fun1(), 
     {:ok, b} &lt;- fun2(a) # with 头部结束
do # with 体开始
     action_with_a_and_b #with 体结束
else #尾部开始
   patter1 -&gt; hanlder_error1
   patter2 -&gt; hanlder_error2 # 尾部结束
end
</code></pre>
<p>和</p>
<pre><code class="language-elixir">with                   # with 头部开始
     {:ok, a} &lt;- fun1(), 
     {:ok, b} &lt;- fun2(a) # with 头部结束
do # with 体开始
     action_with_a_and_b #with 体结束
end
</code></pre>
<p>使用 <code>maybe</code> 应该重构为:</p>
<pre><code class="language-elixir">maybe do                     #maybe body begin
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b        #maybe body end
else                         #maybe tail start
   patter1 -&gt; hanlder_error1
   patter2 -&gt; hanlder_error2 #maybe tail end
end
</code></pre>
<p>和</p>
<pre><code class="language-elixir">maybe do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
end
</code></pre>
<p>需要注意的是:</p>
<ol>
<li>我们的 <code>maybe</code> 中使用的是 <code>=</code> 而不再是 <code>&lt;-</code>, 而且和 Erlang 中的 <code>maybe</code> 也不一样,
我们不用引入新操作符(Erlang 的 <code>maybe</code> 结构中, 引入了新的操作符 <code>?=</code>).</li>
<li>新的 <code>maybe</code> 结构中, 在 <code>action_with_a_and_b</code> 对应的代码中,
如果发生匹配错误, 会直接返回匹配操作符的右值或跳转到 <code>else</code> 段落;
在 <code>with</code> 代码中, <code>action_with_a_and_b</code> 对应的代码发生匹配错误, 会抛出异常的.
这是一点不同.</li>
</ol>
<h3 id="maybe-的定义"><a class="header" href="#maybe-的定义">maybe 的定义</a></h3>
<p>现在让我们定义 <code>maybe</code> 宏.</p>
<p>我们的 <code>maybe</code> 接受一个参数, <code>[do: body, else: tail]</code>,
<code>maybe</code> 宏把代码转化成为对应的 <code>try</code> 语句块.</p>
<pre><code class="language-elixir">defmodule Corner.Maybe do
  defmacro maybe(do: body) do
    quote do
      try do
        unquote(body)
      catch
        :error, {:badmatch, v} -&gt; v
      end
    end
  end

  defmacro maybe(do: body, else: tail) do
    quote do
      try do
        unquote(body)
      catch
        :error, {:badmatch, v} -&gt;
          case v do
            unquote(tail)
          end
      end
    end
  end
end
</code></pre>
<p>要使用 <code>maybe</code> 只要导入我们的宏就可以了.</p>
<h2 id="可递归的匿名函数"><a class="header" href="#可递归的匿名函数">可递归的匿名函数</a></h2>
<p>匿名函数, 因为没有名字, 所以不能直接的在其内部调用自己.
计算机科学中, 这个问题, 可以通过不动点组合子来完成<sup class="footnote-reference"><a href="#fixed_point_combinators">2</a></sup>.
但是老实说, 对于 Y 组合子, 如果不查看文档的话, 我不能写出正确的表达.
对我来说, Y 组合子太绕了.</p>
<div class="footnote-definition" id="fixed_point_combinators"><sup class="footnote-definition-label">2</sup>
<p>见 Wikipedia<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">≪不动点组合子≫</a>词条.</p>
</div>
<p>不使用 Y 组合子, 当然也可以完成匿名函数的递归:</p>
<pre><code class="language-elixir">tem_fun = fn(fun, n,acc) -&gt;
  if n == 0 do
    acc
  else
    fun.(fun,n-1,acc + n)
  end
end
fun = fn(n,acc) -&gt;
  tem_fun.(tem_fun,n,acc)
end
</code></pre>
<p>这样的代码框架几乎是固定的, 所以可以定义一个宏 <code>fn!</code> 来为自动生产这样的框架.
例如, 我想这样来写代码:</p>
<pre><code class="language-elixir">fn! fun do
  (n, acc) -&gt;
  if n == 0 do
   acc
  else
    fun.(n-1, acc + n)
  end
end
</code></pre>
<p><code>fn!</code> 和 <code>fn</code> 很像, 通用用来定义匿名函数, 但是在 <code>fn!</code> 的上下文中,
可以用函数名来完成递归调用. 从这一点上来说, <code>fn!</code> 可以看作是 <code>fn</code> 的加强版.</p>
<h3 id="fn-的定义"><a class="header" href="#fn-的定义"><code>fn!</code> 的定义</a></h3>
<p>现在让我们仔细分析 <code>fn!</code> 到底应该帮助我们做些什么.
首先, 我们分析 <code>fn!</code> 的输入. 第一个参数是表示递归匿名函数名字的变量.
第二个参数是一个 <code>do-block</code>, 其中的内容应该一个或多个 <code>args -&gt; bodys</code> 表达式.</p>
<p>我们需要把 <code>do-block</code> 中的内容转化为一个真正的递归调用函数,
而所作的就是为每个分句都添加一个表示递归函数自身的参数.
当分句中没有对 <code>name</code> 函数的调用时, 新添加的第一个参数, 没有用处,
所以应该添加 <code>_</code> 前缀, 以避免恼人的编译警告.
虽然这个新添加的变量, 只要不予 <code>args</code> 中的变量重复, 叫什么都无所谓,
但是为了逻辑的清晰, 我们还是用 <code>name</code> 来命名这个表示递归函数自己的参数.
在这个整整的递归调用函数内容, 如果有对 <code>name</code> 函数的调用,
例如 <code>name.(a,b)</code> 这样的表达式, 需要转化为 <code>name.(name, a,b)</code>.</p>
<p>这是我们的 <code>fn!</code> 宏的最困难的工作, 这个工作由 <code>make_fn/2</code> 完成.
而 <code>make_fn/2</code> 要做的就是处理没有命名函数的的分句.
处理所有分句后, 把这些分句组合成为一个匿名函数. 所以 <code>make_fn/2</code> 的代码也非常简单.</p>
<pre><code class="language-elixir">defmodule Corner.Fn do
  # 其他代码
  defp make_fn(name, body) do
    new_body = Enum.map(body, &amp;clause_handler(name, &amp;1))
    {:fn, [], new_body}
  end
  # 其他代码
end
</code></pre>
<p><code>clause_handler/2</code>函数完成对每个分句的处理.
它做的工作也非常简单, 检查整个函数分句的函数体的语法树, 并修正其中的递归调用的部分.
如果分句的函数体中有修正, 那么修正后的抽象语法树, 也修正前的不一样,
这样, 我们就能知道, 为这个分句新添加的表示递归函数自己的参数, 用不用添加 <code>_</code> 前缀.</p>
<p>向参数列表中添加新参数的工作由 <code>make_args/2</code> 完成.
这个工作相对来说比较简单, 只是向列表头部添加一个元素而已.
唯一需要注意地方就是, 需要考虑参数中的哨兵语句.</p>
<p>当新的参数和新的函数体都完成后, 最后只需要把它们重新组合为匿名函数,
就完成了对可递归调用匿名函数的定义.</p>
<pre><code class="language-elixir">defp clause_handler(name_ast = {atom, _, _}, {:-&gt;, meta, [args | body]}) do
  new_body = Macro.postwalk(body, &amp;correct_recursive_call(atom, &amp;1))
  new_args =
    if new_body != body do
      make_args(args, name_ast)
    else
      name_ast = &quot;_#{atom}&quot; |&gt; String.to_atom()
      make_args(args, {name_ast, [], nil})
    end
  {:-&gt;, meta, [new_args | new_body]}
end

defp make_args([{:when, meta, args}], fun) do
  [{:when, meta, [fun | args]}]
end
defp make_args(args, fun) do
  [fun | args]
end
</code></pre>
<p>对递归调用的修正工作由函数 <code>correct_recursive_call/2</code> 完成.
假设我们的匿名的递归函数叫做 <code>fun</code>, 那么 <code>correct_recursive_call/2</code> 做的工作就是,
找到 <code>fun.(a,b)</code> 对应的抽象语法树, 修改为 <code>fun.(fun,a,b)</code> 对应的抽象语法树.
而其他的语法树, 保持原样.</p>
<pre><code class="language-elixir"># call is ast of `atom.(...args)`.
# The return is ast of `atom.(atom,...args)`.
defp correct_recursive_call(
       atom,
       call = {{:., _, [{atom, _, _} = fun]}, _, args}
     ) do
  call
  |&gt; Tuple.delete_at(2)
  |&gt; Tuple.append([fun | args])
end
defp correct_recursive_call(_, ast), do: ast
</code></pre>
<p>最后, <code>fn!</code> 函数完成的的工作就非常简单了. 首先检查递归匿名函数的所有的分句,
都有相同个数的参数. 然后创建与递归匿名函数参数个数相同的匿名函数,
在其内部代理已经定义好的可递归的匿名函数.</p>
<p>这里有一点点风险, 最后定义的代理匿名函数的变量是自动生成的.
作为中间变量存储可递归匿名函数的变量, 必须和它们不一样.
为了保证这一点, 我们当然可以自己定义参数生产函数.
这里并没有这样做, 而是使用了一点小技巧, 可以确保用来保存可递归匿名函数的变量绝对不会和
<code>Macro.generate_arguments/2</code> 产生的参数重复.
<code>Macro.generate_arguments/2</code> 产生的参数, 都是小写字母开头的,
所以只要定义的变量, 以大写字母开头就可以了.
在常规的 Elixir 中, 是不能定义大写字母开头的变量的,
但是在宏定义中, 可以这样做.</p>
<pre><code class="language-elixir">defmacro fn!(name, do: block) do
  case syntax_check(block) do
    {:ok, arity} -&gt;
      var = {:TEM_fun, [], nil}
      tem_fun = make_fn(name, block)
      params = Macro.generate_arguments(arity, nil)
      quote do
        unquote(name) = fn unquote_splicing(params) -&gt;
          unquote(var) = unquote(tem_fun)
          unquote(var).(unquote(var), unquote_splicing(params))
        end
      end
    :error -&gt;
      raise SyntaxError, &quot;the clauses must have the same arity.&quot;
  end
end
</code></pre>
<p>对递归函数子句参数个数做检查的工作有 <code>syntax_chexk/1</code> 完成.
它的工作非常的简单, 如果只有一个子句, 那么无论这个子句有多少参数, 都是合法的.
返回 <code>{:ok,arity}</code> 就可以了, 子句多于一个, 那么后续子句的参数个数,
必须和第一个子句的参数个数一样. 这是非常典型对列表的递归检查.</p>
<pre><code class="language-elixir">defp syntax_check([{:-&gt;, _, [args | _]} | others]) do
  args = Ast.get_args(args)
  check_args_length(others, length(args))
end
defp check_args_length([], len) do
  {:ok, len}
end
defp check_args_length([{:-&gt;, _, [args | _]} | others], len) do
  args = Ast.get_args(args)
  if len == length(args) do
    check_args_length(others, len)
  else
    :error
  end
end
</code></pre>
<p>最后, 让我们来检验一下我们劳动成果.</p>
<pre><code class="language-elixir">import Corner.Fn

fn! sum_from_one_to do
  0 -&gt; 0
  n -&gt; n + sum_from_one_to.(n - 1)
end

sum.(100) # 5050 
</code></pre>
<p>看起来, 我们成功了.</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="ch04.parenthese.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch06.async_programe.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="ch04.parenthese.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="ch06.async_programe.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>

    <!-- Livereload script (if served using the cli tool) -->
    <script type="text/javascript">
        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
        const socket = new WebSocket(wsAddress);
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload();
            }
        };

        window.onbeforeunload = function () {
            socket.close();
        }
    </script>
    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    <script type="text/javascript" src="theme/mermaid.min.js"></script>
    <script type="text/javascript" src="theme/mermaid-init.js"></script>
</body>

</html>