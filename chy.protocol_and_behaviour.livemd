# 协议与行为

## 如何选择

就像 `case` 和 `cond` 一度让我感觉感觉选择困难一样,
协议和行为, 在我开始学习的时候, 也有一样的困难.

但是这种困难不是语言语义方面的, 而是系统设计知识不足带来了.
这个问题其实和语言无关.

可以这样理解, 协议就是 OOP 编程中的接口 (Java) 或者纯抽象类(C++);
而行为就是一般的抽象类. 至少协议和行为解决的问题与 OOP 中接口与抽象类解决的问题是一样的.

接口和协议可以看作一个系统的 API 接口, 系统的使用者只需要关心系统提供了那些功能,
而不用关心这些功能是如何实现的.

抽象类或行为可以看作是可供 DIY 的产品. 基础的功能行为已经为我们定义好了,
系统各个部分交互的规则也已经完成了, 核心的和自己的需求相关的业务部分,
需要用户自己 DIY.

如果我们的代码最主要的目的, 是简化系统的调用, 那么应该使用协议及其实现来完成工作.
如果代码提供的服务, 需要支持定制化的开发功能, 那么就使用协议.

## 协议与模块

在前面的模块的章节中, 我们已经知道了 `defprotocol` 和 `defimpl` 宏的调用,
和 `defmodule` 的调用一样, 在编译后会产生编译模块, 反映到文件系统中就是 `.beam` 文件.
现在让我们定义一个 `Addable` 协议.

```elixir
defprotocol Addable do
  def add(a, b)
end

defimpl Addable, for: [Integer, Float] do
  def add(a, b), do: a + b
end
```

首先, 用 `elixirc` 来编译这段代码, 得到 3 个 `.beam` 文件,
分别是: `Elixir.Addable.beam`, `Elixir.Addable.Integer`
和 `Elixir.Addable.Float`.

也就是说, 协议的实现代码, 实际上是定义在 `Protocol.Type` 这样的模块中的,
而且这和 `defimpl` 调用的上下文没有关系.

例如下面的代码第 4 ~ 9 行, 我们在 `TimeSpan` 模块的定义的上下文中调用 `defimpl`,
生产的字节码文件依旧是 `Addable.TimeSpan`.

`defmodule` 是支持嵌套的, 内部模块编译后会, 其模块名会被添加外部模块名的前缀.

也就是说, 虽然 `defimpl` 也可以嵌套在 `defmodule` 调用内部,
但是它并不遵守 `defmodule` 嵌套模块模块名展开的规则. 无论是在顶层作用域中,
还是在 `defmodule` 作用域中, `defimpl` 模块名都一样展开为 `Protocol.Type`.

```elixir
defmodule TimeSpan do
  defstruct hour: 0, min: 0, second: 0

  defimpl Addable, for: __MODULE__ do
    def add(a, b) do
      %{hour: h1, min: m1, second: s1} = a
      %{hour: h2, min: m2, second: s2} = b
      # %__MODULE__{hour: h1 + h2, min: m1 + m2, second: s1 + s2}
      %TimeSpan{hour: h1 + h2, min: m1 + m2, second: s1 + s2}
    end

    IO.inspect(__MODULE__, lable: "__MODULE__")
  end
end
```

第 4 行的 `__MODULE__` 展开为 `TimeSpan` 不出乎我的意料.
但是第 10 行的 `__MODULE__` 展开是什么呢? 或者说,
第 8 行的最终的语义和第 9 行一样吗? 通过控制台的输出,
我们知道是第 10 行的 `__MODULE__` 展开为 `Addable.TimeSpan`.
因此不难推测, 注释掉的第 8 行, 其语义和第 9 行的是不同的.
虽然上面的讨论已经知道 `defimpl` 是要定义一个新的模块,
但是我第一次编码的时候, 还是犯了第 8 行这样的错.

现在我们知道了, `defimpl` 可以嵌套到 `defmodule` 中, 那么 `defimpl` 可以自己可以嵌套吗?
或者在在推广一下问题, `defimpl` 都可以在什么样的上下文中调用呢?

以前的章节中, 我们见到的 `defimpl` 调用的上下文有:

* 顶层作用域
* `defmodule` 作用域

剩下的作用还有如下几个:

* `defprotoc`
* `defimpl`
* `def`, `defp`, `defmacro` `defmacop`

```elixir
defprotocol Addable2 do
  def add(a, b)

  defimpl Addable2, for: Integer do
    def add(a, b) do
      a + b
    end
  end
end
```

编译这段代码, 我们得到了编译错误. 
错误由 `defimpl` 调用引发, 其中提醒的错误信息是不能加载模块 `Addable2`.
这说明, 调用 `defimpl` 的时候, 会加载 `:for` 选线指定的模块.
现在我们的 `Addable2` 模块的定义还没有完成, 加载这个模块自然是失败的.

**结论**: 在 `defprotcoc` 中不能嵌入 `defimpl`.

那么 `defimpl` 可以嵌套自己吗?

```elixir
defimpl Addable, for: String do
  def add(a, b) do
    a <> b
  end

  defimpl Addable, for: BitString do
    def add(a, b) do
      a <> b
    end
  end
end
```

**`defimpl` 中可以嵌入 `defimpl`; `defimpl` 在 `defimpl` 的上下文中, 与在顶层的上下文中没有区别**.

这还真的出乎我的意料.

`def` 和 `defp` 是用来在模块中定义函数的. 函数不可以嵌套定义,
所以我预计, 在 `def` 上下文中, 是不可以调用 `defimpl` 的.
但是还是让我们实验一下吧.

```elixir
defmodule EmbedImplToFun do
  def fun() do
    defimpl Addable, for: Tuple do
      def add(a, b) do
        Tuple.concat(a, b)
      end
    end
  end
end
```

又超出了预期了, 居然可以!

那么可以预期, 在 `def` 中也是可以调用 `defmodule`.

Elixir 中不允许命名函数嵌套, 但是知道了上面的知识,
我们就可以让函数返回模块, 然后在模块中定义命名函数,
以这种迂回的方式来实现函数的嵌套.

## 函数返回模块

上一节, 我们认识到可以在函数中返回模块. 现在让我们实验一下.

```elixir
defmodule EmbedModuleToFun do
  def createFun() do
    defmodule :_ do
      def hello(), do: IO.puts("I am in #{__MODULE__}, hello!")
    end
    |> elem(1)
  end
end

m = EmbedModuleToFun.createFun()
m.hello()
```

这让我想起来 Java 的匿名类. Java 的早期版本中, 不支持函数类型,
所以也不得不使用结构来做类型传递函数.
我们这里使用的方法, 和当年 Java 中使用的方法是一样的.

但是使用这个方法的时候, 还有需要注意的地方.
首先本质上, 这个方法时在运行时动态编译了新模块.
所以每次调用 `createFun()` 都会产生新的模块, 这就意味着, 1) 效率下降,

1. 如果需要在多个函数中返回模块, 必须注意为函数返回的模块取不同的名字.

我们可以写一个宏来解决这两个问题.

```elixir
defmodule Nest do
  import Kernel, except: [def: 2]

  defmacro def(call, exp) do
    if __CALLER__.function == nil do
      raise "Nest.def must cal in def/2"
    end

    {name, args} = name_and_args(call)
    module_name = String.to_atom("#{__CALLER__.module}.nest_#{name}_#{length(args)}")
    make_module(module_name, call, exp)
  end

  defp name_and_args({:when, _, [{name, _, args}, _]}), do: {name, args}
  defp name_and_args({name, _, args}), do: {name, args}

  defp make_module(module_name, call, exp) do
    quote do
      if :code.is_loaded(unquote(module_name)) do
        unquote(module_name)
      else
        defmodule unquote(module_name) do
          IO.puts("Compile #{unquote(module_name)}")
          def unquote(call), unquote(exp)
        end
        |> elem(1)
      end
    end
  end
end
```

测试一下, 当我们在 LiveBook 中运行一下的代码的时候, 如果是第一次允许行下面的代码,
那么第 3 行的的输出之前, 控制台中应该有编译内部模块是的提示输出;
但是第 4 行再次调用的时候 `M.hello()`, 并没有再次编译内部的模块.

但是以后再次编译运行的时候, 因为内部模块, 已经被加载到模块中了,
所以控制台中, 只会有第 3 行的输出控制台的内容, 而不能再看到编译提示内容.

```elixir
defmodule TestNest do
  require Nest

  def hello() do
    Nest.def(hello(a, b), do: a + b)
  end
end

3 = TestNest.hello().hello(1, 2)
IO.puts("-----------")
3 = TestNest.hello().hello(1, 2)
```

## 协议对函数的限制与辅助

协议看起了足够的简单. 看起来它是上下文只允许 `def/1` 的模块.

但是实际上不是这么简单的.
首先协议对其中的定义函数是有现在的, 协议中的函数, 不可以为零元函数.
例如下面的协议定义, 是编译错误的.

```elixir
defprotocol ZeroArityFun do
  def sayHi()
end
```

上面我们展示了, `defprotocol` 对 `def/1` 的限制. 但是为什么必须有一个参数呢?
协议实际帮助我们消弭模块名, 来实现函数的动态调度.

但是 Elixir 是函数编程语言, 不支持面向对象的编程, 动态调度只能通过模式匹配来完成.
函数调用的匹配包括一下内容的匹配:

1. 模块名
2. 函数名
3. 参数模式

零元函数, 因为没有参数, 所以只能通过模块名和函数名来匹配.

协议就时要帮助我们取消不同模块的差异, 而去掉模块名后,
不同的模块内的同名函数, 在调度的时候时没法区分了.
所以协议定义上下文中, 要求 `def/1` 定义的函数, 必须至少含有一个参数.

现在让我们探索一下, 协议是如何动态动态调度它的实现的.
对于上面的 `Addable` 协议, 让我们为整数和浮点数提供实现,
为了能清楚的看出到底是那个模块被调用了, 我在实现代码中加入可观察的副作用.

```elixir
defimpl Addable, for: Integer do
  def add(a, b) do
    IO.puts("add(i,i)")
    a + b
  end
end

defimpl Addable, for: Float do
  def add(a, b) do
    IO.puts("add(f,f)")
    a + b
  end
end
```

`add(1,2)` 自然应该调用的是 `Addable.Interger` 模块内的代码.
`add(1.0,2.0)` 调用的是 `Addable.Float` 模块内的代码.
但是, 当调用 `add(1,2.0)` 的时候, 到底调用的是那个模块的代码呢?
`add(1.0,2)` 呢? 现在让我们来实验一下:

```elixir
Addable.add(1, 2)
Addable.add(1.0, 2.0)
Addable.add(1.0, 2)
Addable.add(1, 2.0)
```

> add(i,i)  
> add(f,f)  
> add(f,f)  
> add(i,i)

这样的输出结果, 有没有让你意外呢? 老实说, 这和我最初的预期还是不一样的.
我预期 `Addable.add(1.0, 2)` 和 `Addable.add(1, 2.0)` 会报错, 而不是分别调用 `Addable.Float.add` 或
`Addable.Integer.add`.

在上面的代码中, 虽然我们的实现中, 并没利用 guard 子句对 `add(a,b)` 的 `a` 参数做类型检查,
但实验的结果显示, `Addable.add(a,b)` 对 `a` 做了类型检查, 并以此来作为函数的调度依据, 来调度实现.

但是具体是如何实现的呢?

## 协议动态调度

调用协议中定义的函数时, 协议模块内的函数会根据第一个参数来动态的调度协议的实现的函数. 
现在我们来思考, 如何实现这一点?

Elixir 协议模块文档的[反射章节](https://hexdocs.pm/elixir/Protocol.html#module-reflection),
告诉我们每个协议模块都会包含了以下三个, 用来完成对协议及其实现模块的反射操作的函数:

1. `__protocol__/1` 返回这个协议模块的相关的元信息.   
   `__protocol__(:functions)` 返回这个协议定义的函数的名字和元的关键字列表.
2. `impl_for/1` 返回给定数据的处理模块, 或者返回 `nil`.
3. `impl_for!/1` 和上面的函数类似, 但是如果没有找到对应的实现的话, 会引发异常.

所以通过 `impl_for` 和 `impl_for!` 可以用来完成对实现模块的动态调用.
比如我们上面定义的 `Addable` 协议,
其中的 `add/2` 函数就可以非常简单的这样来实现:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Addable do
  #...
  def add(a,b) do
    m = impl_for!(a)
    m.add(a,b)
  end
end
```

但是 `impl_for` 和 `impl_for!` 又是如何完成它们的工作的呢?
因为

<!-- livebook:{"break_markdown":true} -->



<!-- livebook:{"break_markdown":true} -->

行为是模块的属性. 行为在 Erlang 中是由对应的概念的.
这一点行为和协议不一样; 协议这种概念在 Erlang 语言层面是没有对应物的.
但是 Elixir 的代码运行在 Erlang 的虚拟机上, 所以协议

在理解 `defprotocol` 的时候, 我试图通过阅读 Elixir 的源码来理解,
协议到底是如何做的, 但是失败, 所以最后还是走上了以实验探索的道路.

上面的探索的虽然让我对 `defprotocol` 的行为有了较为深刻的理解.
但是协议实现动态调度的细节, 我还是不清楚.
那么能不能从行为来模拟协议呢? 或者说, 是否可以基于行为来显示自己的
`defprotocol` 和 `defimpl`?

一个协议基本上, 就是只有行为属性的模块.
但是, 但是这个模块要实现对 `defimpl` 生成的模块的动态调度.
所以 `defprotocol` 对 其中 `def/1` 做的工作, 就是设置模块的 `@callback` 属性,
此外就是生成动态调度的代码.

`defimpl` 的功能是实现 `defprotocol` 产生的模块的行为.
但是如何来让 `defprotocol` 产生的协议模块在运行时感知所有的实现模块呢?
至少感知到了实现模块, 那么才能实现调度嘛!

也许可以用模块名, 或者在 `defimpl` 被调用的时候, 从 协议的实现中获取某些唯一性的东西,
并作为模块属性记录到实现的模块属性中, 这样, 可以通过对所有加载到系统中的模块过滤而找相关的模块.

那么, 要解决的第一个问题是, 如何获取系统中的所有的已经加载的模块呢?
Erlang 的 `:code` 库中提供了两个相关的方法:

1. `all_available/0`
2. `all_loaded/0`

顾名思义, 这两个函数一个用来返回所有加载到系统中的模块, 一个用来获取所有的可以加载到系统中的模块.

那么如何来动态调度呢?

获取所有的实现后, 根据第一个参数来查早可以使用的模块? `impl_for(v)` 
以什么样的顺序来检查呢?

然后使用对应的模块的同名函数完成调用?

```elixir
defmodule Proto.Helper do
  def find_impls(protocol_name) do
    protocol_name.__info__(:functions)
    |> IO.inspect(label: "all_info")

    vsn =
      protocol_name.__info__(:attributes)
      |> IO.inspect(label: "module_info")
      |> Keyword.get(:vsn)

    :code.all_available()
    |> Enum.map(&{elem(&1, 0), elem(&1, 2)})
    |> Enum.filter(&filter(&1, name_pattern: ~r/#{protocol_name}\..+/))
    |> Enum.filter(&filter(&1, protocol_vsn: vsn))
  end

  defp filter({name, _}, name_pattern: name_pattern) do
    "#{name}" =~ name_pattern
  end

  defp filter({name, true}, protocol_vsn: value) do
    module = to_string(name) |> String.to_atom()

    module.__info__(:functions)
    |> IO.inspect(label: "funs")

    p_vsn =
      module.__info__(:attributes)
      |> IO.inspect(label: "attributes")
      |> Keyword.get(:protocol_vsn)

    p_vsn == value
  end
end

Proto.Helper.find_impls(Addable)
```

```elixir
defmodule Proto do
  defmacro defproto(name, do: block) do
    callbacks =
      defs(block)
      |> Enum.map(&function_header/1)
      |> Enum.map(&make_callback/1)

    ast =
      quote do
        defmodule unquote(name) do
          (unquote_splicing(callbacks))
        end
      end

    ast
    |> Macro.to_string()
    |> then(&IO.puts("L14: #{&1}"))

    ast
  end

  defp defs({:__block__, _, defs}), do: defs
  defp defs(one_def), do: [one_def]

  defp function_header({:def, _, [f]}) do
    {name, _, args} = f
    args = args |> Enum.map(&var_to_type/1)
    %{fun_name: name, args: args}
  end

  defp var_to_type(var) do
    {:"::", [], [var, {:any, [], Elixir}]}
  end

  defp make_callback(%{fun_name: name, args: args}) do
    {:@, [context: Elixir, import: Kernel],
     [
       {:callback, [context: Elixir], [{:"::", [], [{name, [], args}, {:any, [], Elixir}]}]}
     ]}
  end
end
```

```elixir
require Proto

Proto.defproto Hello do
  def say_hi(name, lll)
end

# quote do
#   @callback say_hi(name :: any, lll :: any) :: any;
# end
```
