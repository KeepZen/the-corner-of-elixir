# 管道操作符 `|>`

## 管道操作不是组合操作

在函数式编程的社区中, 函数组合非常的重要. 组合函数是一个高阶函数, 它接受多个函数, 返回一个新的函数,
例如 `fun=compose(f,g,k)`, 那么 `fun(x,y,z)` 就等价于 `f(g(k(x,y,z)))`, 
为了和思维的习惯一致, 还有人定义了反序的组合函数, 叫做 `pipe` 函数.

在 Elixir 中没有内置的 `compose` 或 `pipe` 函数, 但是有内置的 `|>` 操作符.
我一度认为 `|>` 就是 Elixir 的 `pipe` 函数. 但是这是一个幻觉.
`|>` 更像 shell 的管道操作而不是函数式编程中的 `pipe` 函数.

至少 Elixir 编译器不会为我们做函数组合的优化.

函数式编程中, 很多语言, 会对函子的 map 操作做优化. 比如:
`[1,2,3].map(f).map(f2)` 编译器会优化为 `[1,2,3].map(compse(f,f2))`,
以提高了程序的执行效率.

在 Elixir 中, 相应的代码时这样的: `[1,2,3] |> Enum.map(f)|> Enum.map(f2)`.
这样的代码, 如果有优化的, 最后应该等价于 `[1,2,3]|> Enum.map(&f2.(f.(&1)))`.
但是实际的情况并不是这样的.

例如下面的代码:

```elixir
fun1 = fn v -> v |> IO.inspect(label: "+1") |> then(&(&1 + 1)) end
fun2 = fn v -> v |> IO.inspect(label: "-1") |> then(&(&1 - 1)) end
range = 1..5

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

从控制台的输出中, 可以看到 `|>` 连接起来的 `Enum.map` 并没有把合并成为一个.
只有等待整个的 list 对 `fun1` 的迭代完成后, fun2 才会在新产生的 list 上迭代. 
所以终端中, 所有的 `+1` 输出结束后, 才开始 `-1` 的输出. 但如果把 `fun2` 和 `fun1`
组合成一个新的函数, 像:

```elixir
range
|> Enum.map(&fun2.(fun1.(&1)))
|> IO.inspect(label: "result of compose")
```

那么客户端的输出时 `+1` `-1` 交替执行的.

因此, 可见, Elixir 内置的 `|>` 不是函数式编程的 `pipe` 函数.

可是手动的组合函数总是比较的麻烦, 写一个函数来帮助我们完成函数的组合也不是难事,
但是 Elixir 社区中, 因为命名函数不是第一个公民, 所以函数组合的语法并不常用.
大家最习惯的其实还是使用 `|>`, 所以如果 `|>` 能对 `Enum.map` 做优化, 
实际上应该能提升我们的代码的运行效率.

非常幸运, `|>` 在 Elixir 中并不是特殊形式, 我们可以定义自己的 `|>`.

Elixir 定义的 `|>` 应该是我们的起点. `|>` 的定义, 在 [`kernel.ex`文件中](https://github.com/elixir-lang/elixir/blob/9a4d10e702f33d2fa47718cde05375b506b4a3d6/lib/elixir/lib/kernel.ex#L4073).

<!-- livebook:{"force_markdown":true} -->

```elixir
defmacro left |> right do
  [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

  fun = fn {x, pos}, acc ->
    Macro.pipe(acc, x, pos)
  end

  :lists.foldl(fun, h, t)
end
```

不用特别的熟悉 Elixir 的宏, 只需要理解最后的 `:lsits.foldl/3` 就可以了, 
我们大概就知道 `|>` 的原理了, 其实在 Javascript 中定义 `pipe` 函数的语法一样.

理解这一点, 那么我们就知道 `t` 应该就是 `|>` 的右操作符数列表, 也就是一个函数调用的列表.

我们自己定义的 `|>` 要优化版本, 就应该式对函数调用列表 `t` 的合并同类项. 具体来说就是, 
识别连续相邻的 `Enum.map(f1)`, `Enum.map(f2)` ..., 
并把他们合并成一个 `Enum.map(compose_fn)`.

首先我们定义一个 `Optimizer` 行为, 这个这个行为只有一个函数, 就是优化函数,
`optimize(t,list)`.

所以如此, 是因为现在我们只是完成 `Enum.map/2` 相关的实现, 但是对于 `|>` 的右操作符, 
不只是 `Enum.map/2` 组成的链条可以优化, 应该还有更多的优化空间. 
以后, 如果我们发现可以为其他的情形做优化了, 那么我们只需要对我们可以优化的的行为, 
实现这个优化就好了.

定义优化行为, 让我们的代码更容易组织.

```elixir
defmodule Optimizer do
  @callback optimize(t :: any, ast_list :: List.t()) :: List.t()

  defmacro __using__(_opts) do
    quote do
      import Kernel, except: [|>: 2]
      import Optimizer.Pipe
    end
  end
end
```

第 2 行我们定义了我们得优化器的接口. 
而 `__using__/1` 的定义可以看作是我们的优化器的客户端. 
使用优化器的使用者, 只需要 `use Optimizer` 引入代码就可以了,
不用关心内部的实现.

现在让我们来定义我们的针对 `Enum.map/2` 的优化.
我认为应该把有关优化的代码都放在 `optimizer` 目录下,
而为 `Enum.map/2` 做优化的模块就命名为 `Optimizer.EnumMap` 吧.

```elixir
defmodule Optimizer.EnumMap do
  @behaviour Optimizer
  @impl true
  def optimize(__MODULE__, list) do
    reduce_map(list)
  end

  defp reduce_map(list) do
    list =
      for condidate_map_call <- list, reduce: [] do
        [ele | rest] = acc ->
          if is_map_call(ele) and is_map_call(condidate_map_call) do
            new_map_call = compose_enum_maper(condidate_map_call, ele)
            [new_map_call | rest]
          else
            [condidate_map_call | acc]
          end

        [] ->
          [condidate_map_call]
      end

    Enum.reverse(list)
  end

  defp is_map_call({{{:., _, [{:__aliases__, _, [:Enum]}, :map]}, _, _}, 0}),
    do: true

  defp is_map_call(_), do: false

  defp compose_enum_maper(map1, map2) do
    fun1 = get_fun(map1)
    fun2 = get_fun(map2)

    fun =
      quote do
        fn v -> unquote(fun1).(unquote(fun2).(v)) end
      end

    make_enum_maper(fun)
  end

  defp get_fun(map) do
    [fun1] = elem(elem(map, 0), 2)
    fun1
  end

  defp make_enum_maper(fun) do
    {{{:., [], [{:__aliases__, [], [:Enum]}, :map]}, [], [fun]}, 0}
  end
end
```

说好的我们是要自定义管道操作符 `|>` , 那么最后让我们完成它的定义吧.

```elixir
defmodule Optimizer.Pipe do
  import Kernel, except: [|>: 2]
  alias Optimizer.{EnumMap}
  @optimizer [EnumMap]
  defmacro left |> right do
    [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

    fun = fn {x, pos}, acc ->
      Macro.pipe(acc, x, pos)
    end

    t = Enum.reduce(@optimizer, t, &apply(&1, :optimize, [&1, &2]))
    :lists.foldl(fun, h, t)
  end
end
```

当我们定义了更多的优化器的时候, 我们只需要修改上面代码的 第 3~4 两行代码, 就可以了.

上面的代码, 大部分都是照搬 Elixir 的 Kernel 模块中管道操作符 `|>` 的定义,
我们只是增加了第 12 行的内容.

代码实现了, 现在来看看结果如何吧?

```elixir
use Optimizer

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

看起来, 功能测试通过了, 但是我们毕竟是做优化的,
我们的代码真的能提升代码的执行效率吗?
让我们来测试一下.

```elixir
defmodule M do
  @range 1..100_000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    use Optimizer

    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def add1(e), do: e + 1
  def sub1(e), do: e - 1

  def fun3(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&sub1(add1(&1)))
    end
  end
end

(M.fun1() == M.fun2()) |> IO.inspect(label: "fun1 == fun2")

arg = [100]
task1 = Task.async(fn -> :timer.tc(M, :fun1, arg) end)
task2 = Task.async(fn -> :timer.tc(M, :fun2, arg) end)
[{t, _v}, {t1, _v}] = Task.await_many([task1, task2], 10_000 * 3600)

IO.puts("speed up #{(t - t1) / t1 * 100}%.")
```

其中有一次, 代码的输出是这样的:

> warning: the underscored variable "_v" appears more than once in a match. This means the pattern will only match if all "_v" bind to the same value. If this is the intended behaviour, please remove the leading underscore from the variable name, otherwise give the variables different names
>  ch7.pipe.livemd#cell:38
> 
> fun1 == fun2: true  
> speed up -1.5641347109939043%.

😒 结果优化后的代码不是提速了, 反而变慢了 1.5 个百分点. 可是为什么会这样啊?

这是因为 LiveBook 代码 Cell 本质上是解释执行的, 就像我们不能以 Iex 中的代码运行速度来衡量代码的效率一样,
我们也不能用 LiveBook 的 Cell 的执行时间来衡量代码的运行速度.

把代码保存到文件中, 并为之编写测试文件, 然后使用 `mix test` 来测试, 
那么优化后的代码总是比不优化的代码运行的更快的, 虽然每次测试的结果不一样, 
但提升的效率的区间为: 20%~36%, 取中间值, 那么优化的结果评价应该提升 28%.

这个结果不过是一个长度是 2 的 `Enum.map/2` 链优化的结果, 如果我们的 `Enum.map/2` 链更长, 
理论上可以有更大的效率提升.
