# 管道操作符 `|>`

## 管道操作不是组合操作

在函数式编程的社区中, 函数组合非常的重要. 组合函数是一个高阶函数, 它接受多个函数, 返回一个新的函数,
例如 `fun=compose(f,g,k)`, 那么 `fun(x,y,z)` 就等价于 `f(g(k(x,y,z)))`, 
为了和思维的习惯一致, 还有人定义了反序的组合函数, 叫做 `pipe` 函数.

在 Elixir 中没有内置的 `compose` 或 `pipe` 函数, 但是有内置的 `|>` 操作符.
我一度认为 `|>` 就是 Elixir 的 `pipe` 函数. 但是这是一个幻觉.
`|>` 更像 shell 的管道操作而不是函数式编程中的 `pipe` 函数.

至少 Elixir 编译器不会为我们做函数组合的优化.

函数式编程中, 很多语言, 会对函子的 map 操作做优化. 比如:
`[1,2,3].map(f).map(f2)` 编译器会优化为 `[1,2,3].map(compse(f,f2))`,
以提高了程序的执行效率.

在 Elixir 中, 相应的代码时这样的: `[1,2,3] |> Enum.map(f)|> Enum.map(f2)`.
这样的代码, 如果有优化的, 最后应该等价于 `[1,2,3]|> Enum.map(&f2.(f.(&1)))`.
但是实际的情况并不是这样的.

例如下面的代码:

```elixir
fun1 = fn v -> v |> IO.inspect(label: "+1") |> then(&(&1 + 1)) end
fun2 = fn v -> v |> IO.inspect(label: "-1") |> then(&(&1 - 1)) end
range = 1..5

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

从控制台的输出中, 可以看到 `|>` 连接起来的 `Enum.map` 并没有把合并成为一个.
只有等待整个的 list 对 `fun1` 的迭代完成后, fun2 才会在新产生的 list 上迭代. 
所以终端中, 所有的 `+1` 输出结束后, 才开始 `-1` 的输出. 但如果把 `fun2` 和 `fun1`
组合成一个新的函数, 像:

```elixir
range
|> Enum.map(&fun2.(fun1.(&1)))
|> IO.inspect(label: "result of compose")
```

那么客户端的输出时 `+1` `-1` 交替执行的.

因此, 可见, Elixir 内置的 `|>` 不是函数式编程的 `pipe` 函数.

可是手动的组合函数总是比较的麻烦, 写一个函数来帮助我们完成函数的组合也不是难事,
但是 Elixir 社区中, 因为命名函数不是第一个公民, 所以函数组合的语法并不常用.
大家最习惯的其实还是使用 `|>`, 所以如果 `|>` 能对 `Enum.map` 做优化, 
实际上应该能提升我们的代码的运行效率.

非常幸运, `|>` 在 Elixir 中并不是特殊形式, 我们可以定义自己的 `|>`.

Elixir 定义的 `|>` 应该是我们的起点. `|>` 的定义, 在 [`kernel.ex`文件中](https://github.com/elixir-lang/elixir/blob/9a4d10e702f33d2fa47718cde05375b506b4a3d6/lib/elixir/lib/kernel.ex#L4073).

<!-- livebook:{"force_markdown":true} -->

```elixir
defmacro left |> right do
  [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

  fun = fn {x, pos}, acc ->
    Macro.pipe(acc, x, pos)
  end

  :lists.foldl(fun, h, t)
end
```

不用特别的熟悉 Elixir 的宏, 只需要理解最后的 `:lsits.foldl/3` 就可以了, 
我们大概就知道 `|>` 的原理了, 其实在 Javascript 中定义 `pipe` 函数的语法一样.

理解这一点, 那么我们就知道 `t` 应该就是 `|>` 的右操作符数列表, 也就是一个函数调用的列表.

我们自己定义的 `|>` 要优化版本, 就应该式对函数调用列表 `t` 的合并同类项. 具体来说就是, 
识别连续相邻的 `Enum.map(f1)`, `Enum.map(f2)` ..., 
并把他们合并成一个 `Enum.map(compose_fn)`.

首先我们定义一个 `Optimizer` 行为, 这个这个行为只有一个函数, 就是优化函数,
`optimize(t,list)`.

所以如此, 是因为现在我们只是完成 `Enum.map/2` 相关的实现, 但是对于 `|>` 的右操作符, 
不只是 `Enum.map/2` 组成的链条可以优化, 应该还有更多的优化空间. 
以后, 如果我们发现可以为其他的情形做优化了, 那么我们只需要对我们可以优化的的行为, 
实现这个优化就好了.

定义优化行为, 让我们的代码更容易组织.

```elixir
defmodule Optimizer do
  @callback optimize(t :: any, ast_list :: List.t()) :: List.t()

  defmacro __using__(_opts) do
    quote do
      import Kernel, except: [|>: 2]
      import Optimizer.Pipe
    end
  end
end
```

第 2 行我们定义了我们得优化器的接口. 
而 `__using__/1` 的定义可以看作是我们的优化器的客户端. 
使用优化器的使用者, 只需要 `use Optimizer` 引入代码就可以了,
不用关心内部的实现.

现在让我们来定义我们的针对 `Enum.map/2` 的优化.
我认为应该把有关优化的代码都放在 `optimizer` 目录下,
而为 `Enum.map/2` 做优化的模块就命名为 `Optimizer.EnumMap` 吧.

```elixir
defmodule Optimizer.EnumMap do
  @behaviour Optimizer

  @impl Optimizer
  def optimize(__MODULE__, list) do
    reduce_map(list)
  end

  defp reduce_map(ast_list) do
    ast_list
    |> group_map_call()
    |> Enum.map(&make_enum_maper/1)
  end

  defp group_map_call(ast_list) do
    for condidate_map_call <- ast_list, reduce: [] do
      [ele | rest] = acc ->
        if is_map_call_or_fun_group(ele) and
             is_map_call_or_fun_group(condidate_map_call) do
          fun_collection = collect_funs(condidate_map_call, ele)
          [fun_collection | rest]
        else
          [condidate_map_call | acc]
        end

      [] ->
        [condidate_map_call]
    end
    |> Enum.reverse()
  end

  @tag :funs_gruop_tag

  defp is_map_call_or_fun_group(ast) do
    case ast do
      {@tag, _} -> true
      {{{:., _, [{:__aliases__, _, [:Enum]}, :map]}, _, _}, 0} -> true
      _ -> false
    end
  end

  defp collect_funs(map1, map2) do
    fun1 = get_fun(map1)
    fun2 = get_fun(map2)

    funs =
      if is_list(fun2) do
        [fun1 | fun2]
      else
        [fun1, fun2]
      end

    {@tag, funs}
  end

  defp get_fun({@tag, funs}), do: funs

  defp get_fun(map) do
    [fun1] = elem(elem(map, 0), 2)
    fun1
  end

  defp make_enum_maper({@tag, funs}) do
    fun = compose(funs)

    ast = {{{:., [], [{:__aliases__, [], [:Enum]}, :map]}, [], [fun]}, 0}
    ast
  end

  defp make_enum_maper(v), do: v

  defp compose(list, acc \\ nil)

  defp compose([fun | funs], nil) do
    acc =
      quote do
        unquote(fun).()
      end

    compose(funs, acc)
  end

  defp compose([fun | funs], acc) do
    acc =
      quote do
        unquote(fun).() |> unquote(acc)
      end

    compose(funs, acc)
  end

  defp compose([], acc) do
    quote do
      fn v -> v |> unquote(acc) end
    end
  end
end
```

说好的我们是要自定义管道操作符 `|>` , 那么最后让我们完成它的定义吧.

```elixir
defmodule Optimizer.Pipe do
  import Kernel, except: [|>: 2]
  alias Optimizer.{EnumMap}
  @optimizer [EnumMap]
  defmacro left |> right do
    [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

    fun = fn {x, pos}, acc ->
      Macro.pipe(acc, x, pos)
    end

    t = Enum.reduce(@optimizer, t, &apply(&1, :optimize, [&1, &2]))
    :lists.foldl(fun, h, t)
  end
end
```

当我们定义了更多的优化器的时候, 我们只需要修改上面代码的 第 3~4 两行代码, 就可以了.

上面的代码, 大部分都是照搬 Elixir 的 Kernel 模块中管道操作符 `|>` 的定义,
我们只是增加了第 12 行的内容.

代码实现了, 现在来看看结果如何吧?

```elixir
use Optimizer

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

看起来, 功能测试通过了, 但是我们毕竟是做优化的,
我们的代码真的能提升代码的执行效率吗?
让我们来测试一下.

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    use Optimizer

    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  test "Optimizer of |> for Enum.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t1 * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

其中有一次, 代码的输出是这样的:

> speed up -1.5641347109939043%.

😒 结果优化后的代码不是提速了, 反而变慢了 1.5 个百分点. 可是为什么会这样啊?

这是因为 LiveBook 代码 Cell 本质上是解释执行的, 就像我们不能以 IEx 中的代码运行时间来衡量代码的效率一样,
我们也不能用 LiveBook 的 Cell 的执行时间来衡量代码的效率.

这个优化的实现, 其实并不是那么的复杂, 为什么 Elixir 编译器不这样做呢?
这里有两个原因. 第一原因, 就是 Elixir 标准库中有 `Stream` 模块, 
文档中, 明确提到 `Stream.map` 会组合函数的. 也就是说, 
Elixir 是以 `Stream.map` 来完成我们这里的工作的.例如我们上面的代码, 
我们只是用 `Stream` 替换了 `Enum`. 就获得了相同的结果.

```elixir
range
|> Stream.map(fun1)
|> Stream.map(fun2)
|> Enum.to_list()
|> IO.inspect(label: "result of map chain")
```

那么是不是我是不是解决了一个错误的问题的问题呢?

我的答案是: 不是的. 我们的工作依旧是有意义的.

在对我们的优化做效率测试的时候, 我们发现有时候, 理论上绝对不有应该下降的代码,
测试的时候, 有时居然会下降 1.5%. 那么 Stream 版本的优化呢?
会比我们的的代码效率更高吗?
让我们来测试一下:

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Stream.map(&(&1 + 1))
      |> Stream.map(&(&1 - 1))
      |> Enum.to_list()
    end
  end

  test "Enum.map vs Stream.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

这次运行的结果更加糟糕, 和 `Enum.map` 相比, 
`Stream.map` 版本的代码效率下降了 100% 还多.

1%~2% 的效率差异我们还能接受是代码执行过程中偶然因素带来的,
但 `Stream.map` 和 `Enum.map` 的巨大差异绝对不能归结为运行时的偶然因素.

所以 `Stream.map` 虽然完成了的函数的组合, 但是却并没有提升效率.

Elixir 的 `Enum.map` 不组合函数的第二个原因是, Elixir 不是一个纯的函数编程语言.
传递给 `Enum.map` 不能保证没有副作用的. 而理论上来说,
只有当 `Enum.map` 中的函数是纯函数的时候, 才可以组合函数.
但是要在编译时判断一个函数中是否有副作用, 这基本上做不到,
所以 Elixir 的标准库中 `Enum.map` 并不做函数的组合.

现在我们的优化器, 忽略了函数中的副作用而强行对函数做了组合.
把优化器做测试的代码, 保存到文件中, 使用 `mix test` 来重新测试, 就会发现, 
优化器的效率有了 30%~40% 的效率提升.

对功能一样, 手动组合的函数做测试, 其效率和我们的代码的一样.
这就是前面我的说这个工作的意义所在.
