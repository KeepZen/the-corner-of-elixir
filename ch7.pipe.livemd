# ç®¡é“æ“ä½œç¬¦ `|>`

## ç®¡é“æ“ä½œä¸æ˜¯ç»„åˆæ“ä½œ

åœ¨å‡½æ•°å¼ç¼–ç¨‹çš„ç¤¾åŒºä¸­, å‡½æ•°ç»„åˆéå¸¸çš„é‡è¦. ç»„åˆå‡½æ•°æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°, å®ƒæ¥å—å¤šä¸ªå‡½æ•°, è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°,
ä¾‹å¦‚ `fun=compose(f,g,k)`, é‚£ä¹ˆ `fun(x,y,z)` å°±ç­‰ä»·äº `f(g(k(x,y,z)))`, 
ä¸ºäº†å’Œæ€ç»´çš„ä¹ æƒ¯ä¸€è‡´, è¿˜æœ‰äººå®šä¹‰äº†ååºçš„ç»„åˆå‡½æ•°, å«åš `pipe` å‡½æ•°.

åœ¨ Elixir ä¸­æ²¡æœ‰å†…ç½®çš„ `compose` æˆ– `pipe` å‡½æ•°, ä½†æ˜¯æœ‰å†…ç½®çš„ `|>` æ“ä½œç¬¦.
æˆ‘ä¸€åº¦è®¤ä¸º `|>` å°±æ˜¯ Elixir çš„ `pipe` å‡½æ•°. ä½†æ˜¯è¿™æ˜¯ä¸€ä¸ªå¹»è§‰.
`|>` æ›´åƒ shell çš„ç®¡é“æ“ä½œè€Œä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ `pipe` å‡½æ•°.

è‡³å°‘ Elixir ç¼–è¯‘å™¨ä¸ä¼šä¸ºæˆ‘ä»¬åšå‡½æ•°ç»„åˆçš„ä¼˜åŒ–.

å‡½æ•°å¼ç¼–ç¨‹ä¸­, å¾ˆå¤šè¯­è¨€, ä¼šå¯¹å‡½å­çš„ map æ“ä½œåšä¼˜åŒ–. æ¯”å¦‚:
`[1,2,3].map(f).map(f2)` ç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸º `[1,2,3].map(compse(f,f2))`,
ä»¥æé«˜äº†ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡.

åœ¨ Elixir ä¸­, ç›¸åº”çš„ä»£ç æ—¶è¿™æ ·çš„: `[1,2,3] |> Enum.map(f)|> Enum.map(f2)`.
è¿™æ ·çš„ä»£ç , å¦‚æœæœ‰ä¼˜åŒ–çš„, æœ€ååº”è¯¥ç­‰ä»·äº `[1,2,3]|> Enum.map(&f2.(f.(&1)))`.
ä½†æ˜¯å®é™…çš„æƒ…å†µå¹¶ä¸æ˜¯è¿™æ ·çš„.

ä¾‹å¦‚ä¸‹é¢çš„ä»£ç :

```elixir
fun1 = fn v -> v |> IO.inspect(label: "+1") |> then(&(&1 + 1)) end
fun2 = fn v -> v |> IO.inspect(label: "-1") |> then(&(&1 - 1)) end
range = 1..5

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

ä»æ§åˆ¶å°çš„è¾“å‡ºä¸­, å¯ä»¥çœ‹åˆ° `|>` è¿æ¥èµ·æ¥çš„ `Enum.map` å¹¶æ²¡æœ‰æŠŠåˆå¹¶æˆä¸ºä¸€ä¸ª.
åªæœ‰ç­‰å¾…æ•´ä¸ªçš„ list å¯¹ `fun1` çš„è¿­ä»£å®Œæˆå, fun2 æ‰ä¼šåœ¨æ–°äº§ç”Ÿçš„ list ä¸Šè¿­ä»£. 
æ‰€ä»¥ç»ˆç«¯ä¸­, æ‰€æœ‰çš„ `+1` è¾“å‡ºç»“æŸå, æ‰å¼€å§‹ `-1` çš„è¾“å‡º. ä½†å¦‚æœæŠŠ `fun2` å’Œ `fun1`
ç»„åˆæˆä¸€ä¸ªæ–°çš„å‡½æ•°, åƒ:

```elixir
range
|> Enum.map(&fun2.(fun1.(&1)))
|> IO.inspect(label: "result of compose")
```

é‚£ä¹ˆå®¢æˆ·ç«¯çš„è¾“å‡ºæ—¶ `+1` `-1` äº¤æ›¿æ‰§è¡Œçš„.

å› æ­¤, å¯è§, Elixir å†…ç½®çš„ `|>` ä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ `pipe` å‡½æ•°.

å¯æ˜¯æ‰‹åŠ¨çš„ç»„åˆå‡½æ•°æ€»æ˜¯æ¯”è¾ƒçš„éº»çƒ¦, å†™ä¸€ä¸ªå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆå‡½æ•°çš„ç»„åˆä¹Ÿä¸æ˜¯éš¾äº‹,
ä½†æ˜¯ Elixir ç¤¾åŒºä¸­, å› ä¸ºå‘½åå‡½æ•°ä¸æ˜¯ç¬¬ä¸€ä¸ªå…¬æ°‘, æ‰€ä»¥å‡½æ•°ç»„åˆçš„è¯­æ³•å¹¶ä¸å¸¸ç”¨.
å¤§å®¶æœ€ä¹ æƒ¯çš„å…¶å®è¿˜æ˜¯ä½¿ç”¨ `|>`, æ‰€ä»¥å¦‚æœ `|>` èƒ½å¯¹ `Enum.map` åšä¼˜åŒ–, 
å®é™…ä¸Šåº”è¯¥èƒ½æå‡æˆ‘ä»¬çš„ä»£ç çš„è¿è¡Œæ•ˆç‡.

éå¸¸å¹¸è¿, `|>` åœ¨ Elixir ä¸­å¹¶ä¸æ˜¯ç‰¹æ®Šå½¢å¼, æˆ‘ä»¬å¯ä»¥å®šä¹‰è‡ªå·±çš„ `|>`.

Elixir å®šä¹‰çš„ `|>` åº”è¯¥æ˜¯æˆ‘ä»¬çš„èµ·ç‚¹. `|>` çš„å®šä¹‰, åœ¨ [`kernel.ex`æ–‡ä»¶ä¸­](https://github.com/elixir-lang/elixir/blob/9a4d10e702f33d2fa47718cde05375b506b4a3d6/lib/elixir/lib/kernel.ex#L4073).

<!-- livebook:{"force_markdown":true} -->

```elixir
defmacro left |> right do
  [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

  fun = fn {x, pos}, acc ->
    Macro.pipe(acc, x, pos)
  end

  :lists.foldl(fun, h, t)
end
```

ä¸ç”¨ç‰¹åˆ«çš„ç†Ÿæ‚‰ Elixir çš„å®, åªéœ€è¦ç†è§£æœ€åçš„ `:lsits.foldl/3` å°±å¯ä»¥äº†, 
æˆ‘ä»¬å¤§æ¦‚å°±çŸ¥é“ `|>` çš„åŸç†äº†, å…¶å®åœ¨ Javascript ä¸­å®šä¹‰ `pipe` å‡½æ•°çš„è¯­æ³•ä¸€æ ·.

ç†è§£è¿™ä¸€ç‚¹, é‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“ `t` åº”è¯¥å°±æ˜¯ `|>` çš„å³æ“ä½œç¬¦æ•°åˆ—è¡¨, ä¹Ÿå°±æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨çš„åˆ—è¡¨.

æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ `|>` è¦ä¼˜åŒ–ç‰ˆæœ¬, å°±åº”è¯¥å¼å¯¹å‡½æ•°è°ƒç”¨åˆ—è¡¨ `t` çš„åˆå¹¶åŒç±»é¡¹. å…·ä½“æ¥è¯´å°±æ˜¯, 
è¯†åˆ«è¿ç»­ç›¸é‚»çš„ `Enum.map(f1)`, `Enum.map(f2)` ..., 
å¹¶æŠŠä»–ä»¬åˆå¹¶æˆä¸€ä¸ª `Enum.map(compose_fn)`.

é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª `Optimizer` è¡Œä¸º, è¿™ä¸ªè¿™ä¸ªè¡Œä¸ºåªæœ‰ä¸€ä¸ªå‡½æ•°, å°±æ˜¯ä¼˜åŒ–å‡½æ•°,
`optimize(t,list)`.

æ‰€ä»¥å¦‚æ­¤, æ˜¯å› ä¸ºç°åœ¨æˆ‘ä»¬åªæ˜¯å®Œæˆ `Enum.map/2` ç›¸å…³çš„å®ç°, ä½†æ˜¯å¯¹äº `|>` çš„å³æ“ä½œç¬¦, 
ä¸åªæ˜¯ `Enum.map/2` ç»„æˆçš„é“¾æ¡å¯ä»¥ä¼˜åŒ–, åº”è¯¥è¿˜æœ‰æ›´å¤šçš„ä¼˜åŒ–ç©ºé—´. 
ä»¥å, å¦‚æœæˆ‘ä»¬å‘ç°å¯ä»¥ä¸ºå…¶ä»–çš„æƒ…å½¢åšä¼˜åŒ–äº†, é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦å¯¹æˆ‘ä»¬å¯ä»¥ä¼˜åŒ–çš„çš„è¡Œä¸º, 
å®ç°è¿™ä¸ªä¼˜åŒ–å°±å¥½äº†.

å®šä¹‰ä¼˜åŒ–è¡Œä¸º, è®©æˆ‘ä»¬çš„ä»£ç æ›´å®¹æ˜“ç»„ç»‡.

```elixir
defmodule Optimizer do
  @callback optimize(t :: any, ast_list :: List.t()) :: List.t()

  defmacro __using__(_opts) do
    quote do
      import Kernel, except: [|>: 2]
      import Optimizer.Pipe
    end
  end
end
```

ç¬¬ 2 è¡Œæˆ‘ä»¬å®šä¹‰äº†æˆ‘ä»¬å¾—ä¼˜åŒ–å™¨çš„æ¥å£. 
è€Œ `__using__/1` çš„å®šä¹‰å¯ä»¥çœ‹ä½œæ˜¯æˆ‘ä»¬çš„ä¼˜åŒ–å™¨çš„å®¢æˆ·ç«¯. 
ä½¿ç”¨ä¼˜åŒ–å™¨çš„ä½¿ç”¨è€…, åªéœ€è¦ `use Optimizer` å¼•å…¥ä»£ç å°±å¯ä»¥äº†,
ä¸ç”¨å…³å¿ƒå†…éƒ¨çš„å®ç°.

ç°åœ¨è®©æˆ‘ä»¬æ¥å®šä¹‰æˆ‘ä»¬çš„é’ˆå¯¹ `Enum.map/2` çš„ä¼˜åŒ–.
æˆ‘è®¤ä¸ºåº”è¯¥æŠŠæœ‰å…³ä¼˜åŒ–çš„ä»£ç éƒ½æ”¾åœ¨ `optimizer` ç›®å½•ä¸‹,
è€Œä¸º `Enum.map/2` åšä¼˜åŒ–çš„æ¨¡å—å°±å‘½åä¸º `Optimizer.EnumMap` å§.

```elixir
defmodule Optimizer.EnumMap do
  @behaviour Optimizer
  @impl true
  def optimize(__MODULE__, list) do
    reduce_map(list)
  end

  defp reduce_map(list) do
    list =
      for condidate_map_call <- list, reduce: [] do
        [ele | rest] = acc ->
          if is_map_call(ele) and is_map_call(condidate_map_call) do
            new_map_call = compose_enum_maper(condidate_map_call, ele)
            [new_map_call | rest]
          else
            [condidate_map_call | acc]
          end

        [] ->
          [condidate_map_call]
      end

    Enum.reverse(list)
  end

  defp is_map_call({{{:., _, [{:__aliases__, _, [:Enum]}, :map]}, _, _}, 0}),
    do: true

  defp is_map_call(_), do: false

  defp compose_enum_maper(map1, map2) do
    fun1 = get_fun(map1)
    fun2 = get_fun(map2)

    fun =
      quote do
        fn v -> unquote(fun1).(unquote(fun2).(v)) end
      end

    make_enum_maper(fun)
  end

  defp get_fun(map) do
    [fun1] = elem(elem(map, 0), 2)
    fun1
  end

  defp make_enum_maper(fun) do
    {{{:., [], [{:__aliases__, [], [:Enum]}, :map]}, [], [fun]}, 0}
  end
end
```

è¯´å¥½çš„æˆ‘ä»¬æ˜¯è¦è‡ªå®šä¹‰ç®¡é“æ“ä½œç¬¦ `|>` , é‚£ä¹ˆæœ€åè®©æˆ‘ä»¬å®Œæˆå®ƒçš„å®šä¹‰å§.

```elixir
defmodule Optimizer.Pipe do
  import Kernel, except: [|>: 2]
  alias Optimizer.{EnumMap}
  @optimizer [EnumMap]
  defmacro left |> right do
    [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

    fun = fn {x, pos}, acc ->
      Macro.pipe(acc, x, pos)
    end

    t = Enum.reduce(@optimizer, t, &apply(&1, :optimize, [&1, &2]))
    :lists.foldl(fun, h, t)
  end
end
```

å½“æˆ‘ä»¬å®šä¹‰äº†æ›´å¤šçš„ä¼˜åŒ–å™¨çš„æ—¶å€™, æˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ä¸Šé¢ä»£ç çš„ ç¬¬ 3~4 ä¸¤è¡Œä»£ç , å°±å¯ä»¥äº†.

ä¸Šé¢çš„ä»£ç , å¤§éƒ¨åˆ†éƒ½æ˜¯ç…§æ¬ Elixir çš„ Kernel æ¨¡å—ä¸­ç®¡é“æ“ä½œç¬¦ `|>` çš„å®šä¹‰,
æˆ‘ä»¬åªæ˜¯å¢åŠ äº†ç¬¬ 12 è¡Œçš„å†…å®¹.

ä»£ç å®ç°äº†, ç°åœ¨æ¥çœ‹çœ‹ç»“æœå¦‚ä½•å§?

```elixir
use Optimizer

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

çœ‹èµ·æ¥, åŠŸèƒ½æµ‹è¯•é€šè¿‡äº†, ä½†æ˜¯æˆ‘ä»¬æ¯•ç«Ÿæ˜¯åšä¼˜åŒ–çš„,
æˆ‘ä»¬çš„ä»£ç çœŸçš„èƒ½æå‡ä»£ç çš„æ‰§è¡Œæ•ˆç‡å—?
è®©æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹.

```elixir
defmodule M do
  @range 1..100_000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    use Optimizer

    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def add1(e), do: e + 1
  def sub1(e), do: e - 1

  def fun3(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&sub1(add1(&1)))
    end
  end
end

(M.fun1() == M.fun2()) |> IO.inspect(label: "fun1 == fun2")

arg = [100]
task1 = Task.async(fn -> :timer.tc(M, :fun1, arg) end)
task2 = Task.async(fn -> :timer.tc(M, :fun2, arg) end)
[{t, _v}, {t1, _v}] = Task.await_many([task1, task2], 10_000 * 3600)

IO.puts("speed up #{(t - t1) / t1 * 100}%.")
```

å…¶ä¸­æœ‰ä¸€æ¬¡, ä»£ç çš„è¾“å‡ºæ˜¯è¿™æ ·çš„:

> warning: the underscored variable "_v" appears more than once in a match. This means the pattern will only match if all "_v" bind to the same value. If this is the intended behaviour, please remove the leading underscore from the variable name, otherwise give the variables different names
>  ch7.pipe.livemd#cell:38
> 
> fun1 == fun2: true  
> speed up -1.5641347109939043%.

ğŸ˜’ ç»“æœä¼˜åŒ–åçš„ä»£ç ä¸æ˜¯æé€Ÿäº†, åè€Œå˜æ…¢äº† 1.5 ä¸ªç™¾åˆ†ç‚¹. å¯æ˜¯ä¸ºä»€ä¹ˆä¼šè¿™æ ·å•Š?

è¿™æ˜¯å› ä¸º LiveBook ä»£ç  Cell æœ¬è´¨ä¸Šæ˜¯è§£é‡Šæ‰§è¡Œçš„, å°±åƒæˆ‘ä»¬ä¸èƒ½ä»¥ Iex ä¸­çš„ä»£ç è¿è¡Œé€Ÿåº¦æ¥è¡¡é‡ä»£ç çš„æ•ˆç‡ä¸€æ ·,
æˆ‘ä»¬ä¹Ÿä¸èƒ½ç”¨ LiveBook çš„ Cell çš„æ‰§è¡Œæ—¶é—´æ¥è¡¡é‡ä»£ç çš„è¿è¡Œé€Ÿåº¦.

æŠŠä»£ç ä¿å­˜åˆ°æ–‡ä»¶ä¸­, å¹¶ä¸ºä¹‹ç¼–å†™æµ‹è¯•æ–‡ä»¶, ç„¶åä½¿ç”¨ `mix test` æ¥æµ‹è¯•, 
é‚£ä¹ˆä¼˜åŒ–åçš„ä»£ç æ€»æ˜¯æ¯”ä¸ä¼˜åŒ–çš„ä»£ç è¿è¡Œçš„æ›´å¿«çš„, è™½ç„¶æ¯æ¬¡æµ‹è¯•çš„ç»“æœä¸ä¸€æ ·, 
ä½†æå‡çš„æ•ˆç‡çš„åŒºé—´ä¸º: 20%~36%, å–ä¸­é—´å€¼, é‚£ä¹ˆä¼˜åŒ–çš„ç»“æœè¯„ä»·åº”è¯¥æå‡ 28%.

è¿™ä¸ªç»“æœä¸è¿‡æ˜¯ä¸€ä¸ªé•¿åº¦æ˜¯ 2 çš„ `Enum.map/2` é“¾ä¼˜åŒ–çš„ç»“æœ, å¦‚æœæˆ‘ä»¬çš„ `Enum.map/2` é“¾æ›´é•¿, 
ç†è®ºä¸Šå¯ä»¥æœ‰æ›´å¤§çš„æ•ˆç‡æå‡.
