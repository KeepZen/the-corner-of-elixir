# ç®¡é“æ“ä½œç¬¦ `|>`

## ç®¡é“æ“ä½œä¸æ˜¯ç»„åˆæ“ä½œ

åœ¨å‡½æ•°å¼ç¼–ç¨‹çš„ç¤¾åŒºä¸­, å‡½æ•°ç»„åˆéå¸¸çš„é‡è¦. ç»„åˆå‡½æ•°æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°, å®ƒæ¥å—å¤šä¸ªå‡½æ•°, è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°,
ä¾‹å¦‚ `fun=compose(f,g,k)`, é‚£ä¹ˆ `fun(x,y,z)` å°±ç­‰ä»·äº `f(g(k(x,y,z)))`, 
ä¸ºäº†å’Œæ€ç»´çš„ä¹ æƒ¯ä¸€è‡´, è¿˜æœ‰äººå®šä¹‰äº†ååºçš„ç»„åˆå‡½æ•°, å«åš `pipe` å‡½æ•°.

åœ¨ Elixir ä¸­æ²¡æœ‰å†…ç½®çš„ `compose` æˆ– `pipe` å‡½æ•°, ä½†æ˜¯æœ‰å†…ç½®çš„ `|>` æ“ä½œç¬¦.
æˆ‘ä¸€åº¦è®¤ä¸º `|>` å°±æ˜¯ Elixir çš„ `pipe` å‡½æ•°. ä½†æ˜¯è¿™æ˜¯ä¸€ä¸ªå¹»è§‰.
`|>` æ›´åƒ shell çš„ç®¡é“æ“ä½œè€Œä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ `pipe` å‡½æ•°.

è‡³å°‘ Elixir ç¼–è¯‘å™¨ä¸ä¼šä¸ºæˆ‘ä»¬åšå‡½æ•°ç»„åˆçš„ä¼˜åŒ–.

å‡½æ•°å¼ç¼–ç¨‹ä¸­, å¾ˆå¤šè¯­è¨€, ä¼šå¯¹å‡½å­çš„ map æ“ä½œåšä¼˜åŒ–. æ¯”å¦‚:
`[1,2,3].map(f).map(f2)` ç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸º `[1,2,3].map(compse(f,f2))`,
ä»¥æé«˜äº†ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡.

åœ¨ Elixir ä¸­, ç›¸åº”çš„ä»£ç æ—¶è¿™æ ·çš„: `[1,2,3] |> Enum.map(f)|> Enum.map(f2)`.
è¿™æ ·çš„ä»£ç , å¦‚æœæœ‰ä¼˜åŒ–çš„, æœ€ååº”è¯¥ç­‰ä»·äº `[1,2,3]|> Enum.map(&f2.(f.(&1)))`.
ä½†æ˜¯å®é™…çš„æƒ…å†µå¹¶ä¸æ˜¯è¿™æ ·çš„.

ä¾‹å¦‚ä¸‹é¢çš„ä»£ç :

```elixir
fun1 = fn v -> v |> IO.inspect(label: "+1") |> then(&(&1 + 1)) end
fun2 = fn v -> v |> IO.inspect(label: "-1") |> then(&(&1 - 1)) end
range = 1..5

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

ä»æ§åˆ¶å°çš„è¾“å‡ºä¸­, å¯ä»¥çœ‹åˆ° `|>` è¿æ¥èµ·æ¥çš„ `Enum.map` å¹¶æ²¡æœ‰æŠŠåˆå¹¶æˆä¸ºä¸€ä¸ª.
åªæœ‰ç­‰å¾…æ•´ä¸ªçš„ list å¯¹ `fun1` çš„è¿­ä»£å®Œæˆå, fun2 æ‰ä¼šåœ¨æ–°äº§ç”Ÿçš„ list ä¸Šè¿­ä»£. 
æ‰€ä»¥ç»ˆç«¯ä¸­, æ‰€æœ‰çš„ `+1` è¾“å‡ºç»“æŸå, æ‰å¼€å§‹ `-1` çš„è¾“å‡º. ä½†å¦‚æœæŠŠ `fun2` å’Œ `fun1`
ç»„åˆæˆä¸€ä¸ªæ–°çš„å‡½æ•°, åƒ:

```elixir
range
|> Enum.map(&fun2.(fun1.(&1)))
|> IO.inspect(label: "result of compose")
```

é‚£ä¹ˆå®¢æˆ·ç«¯çš„è¾“å‡ºæ—¶ `+1` `-1` äº¤æ›¿æ‰§è¡Œçš„.

å› æ­¤, å¯è§, Elixir å†…ç½®çš„ `|>` ä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ `pipe` å‡½æ•°.

å¯æ˜¯æ‰‹åŠ¨çš„ç»„åˆå‡½æ•°æ€»æ˜¯æ¯”è¾ƒçš„éº»çƒ¦, å†™ä¸€ä¸ªå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆå‡½æ•°çš„ç»„åˆä¹Ÿä¸æ˜¯éš¾äº‹,
ä½†æ˜¯ Elixir ç¤¾åŒºä¸­, å› ä¸ºå‘½åå‡½æ•°ä¸æ˜¯ç¬¬ä¸€ä¸ªå…¬æ°‘, æ‰€ä»¥å‡½æ•°ç»„åˆçš„è¯­æ³•å¹¶ä¸å¸¸ç”¨.
å¤§å®¶æœ€ä¹ æƒ¯çš„å…¶å®è¿˜æ˜¯ä½¿ç”¨ `|>`, æ‰€ä»¥å¦‚æœ `|>` èƒ½å¯¹ `Enum.map` åšä¼˜åŒ–, 
å®é™…ä¸Šåº”è¯¥èƒ½æå‡æˆ‘ä»¬çš„ä»£ç çš„è¿è¡Œæ•ˆç‡.

éå¸¸å¹¸è¿, `|>` åœ¨ Elixir ä¸­å¹¶ä¸æ˜¯ç‰¹æ®Šå½¢å¼, æˆ‘ä»¬å¯ä»¥å®šä¹‰è‡ªå·±çš„ `|>`.

Elixir å®šä¹‰çš„ `|>` åº”è¯¥æ˜¯æˆ‘ä»¬çš„èµ·ç‚¹. `|>` çš„å®šä¹‰, åœ¨ [`kernel.ex`æ–‡ä»¶ä¸­](https://github.com/elixir-lang/elixir/blob/9a4d10e702f33d2fa47718cde05375b506b4a3d6/lib/elixir/lib/kernel.ex#L4073).

<!-- livebook:{"force_markdown":true} -->

```elixir
defmacro left |> right do
  [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

  fun = fn {x, pos}, acc ->
    Macro.pipe(acc, x, pos)
  end

  :lists.foldl(fun, h, t)
end
```

ä¸ç”¨ç‰¹åˆ«çš„ç†Ÿæ‚‰ Elixir çš„å®, åªéœ€è¦ç†è§£æœ€åçš„ `:lsits.foldl/3` å°±å¯ä»¥äº†, 
æˆ‘ä»¬å¤§æ¦‚å°±çŸ¥é“ `|>` çš„åŸç†äº†, å…¶å®åœ¨ Javascript ä¸­å®šä¹‰ `pipe` å‡½æ•°çš„è¯­æ³•ä¸€æ ·.

ç†è§£è¿™ä¸€ç‚¹, é‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“ `t` åº”è¯¥å°±æ˜¯ `|>` çš„å³æ“ä½œç¬¦æ•°åˆ—è¡¨, ä¹Ÿå°±æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨çš„åˆ—è¡¨.

æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ `|>` è¦ä¼˜åŒ–ç‰ˆæœ¬, å°±åº”è¯¥å¼å¯¹å‡½æ•°è°ƒç”¨åˆ—è¡¨ `t` çš„åˆå¹¶åŒç±»é¡¹. å…·ä½“æ¥è¯´å°±æ˜¯, 
è¯†åˆ«è¿ç»­ç›¸é‚»çš„ `Enum.map(f1)`, `Enum.map(f2)` ..., 
å¹¶æŠŠä»–ä»¬åˆå¹¶æˆä¸€ä¸ª `Enum.map(compose_fn)`.

é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª `Optimizer` è¡Œä¸º, è¿™ä¸ªè¿™ä¸ªè¡Œä¸ºåªæœ‰ä¸€ä¸ªå‡½æ•°, å°±æ˜¯ä¼˜åŒ–å‡½æ•°,
`optimize(t,list)`.

æ‰€ä»¥å¦‚æ­¤, æ˜¯å› ä¸ºç°åœ¨æˆ‘ä»¬åªæ˜¯å®Œæˆ `Enum.map/2` ç›¸å…³çš„å®ç°, ä½†æ˜¯å¯¹äº `|>` çš„å³æ“ä½œç¬¦, 
ä¸åªæ˜¯ `Enum.map/2` ç»„æˆçš„é“¾æ¡å¯ä»¥ä¼˜åŒ–, åº”è¯¥è¿˜æœ‰æ›´å¤šçš„ä¼˜åŒ–ç©ºé—´. 
ä»¥å, å¦‚æœæˆ‘ä»¬å‘ç°å¯ä»¥ä¸ºå…¶ä»–çš„æƒ…å½¢åšä¼˜åŒ–äº†, é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦å¯¹æˆ‘ä»¬å¯ä»¥ä¼˜åŒ–çš„çš„è¡Œä¸º, 
å®ç°è¿™ä¸ªä¼˜åŒ–å°±å¥½äº†.

å®šä¹‰ä¼˜åŒ–è¡Œä¸º, è®©æˆ‘ä»¬çš„ä»£ç æ›´å®¹æ˜“ç»„ç»‡.

```elixir
defmodule Optimizer do
  @callback optimize(t :: any, ast_list :: List.t()) :: List.t()

  defmacro __using__(_opts) do
    quote do
      import Kernel, except: [|>: 2]
      import Optimizer.Pipe
    end
  end
end
```

ç¬¬ 2 è¡Œæˆ‘ä»¬å®šä¹‰äº†æˆ‘ä»¬å¾—ä¼˜åŒ–å™¨çš„æ¥å£. 
è€Œ `__using__/1` çš„å®šä¹‰å¯ä»¥çœ‹ä½œæ˜¯æˆ‘ä»¬çš„ä¼˜åŒ–å™¨çš„å®¢æˆ·ç«¯. 
ä½¿ç”¨ä¼˜åŒ–å™¨çš„ä½¿ç”¨è€…, åªéœ€è¦ `use Optimizer` å¼•å…¥ä»£ç å°±å¯ä»¥äº†,
ä¸ç”¨å…³å¿ƒå†…éƒ¨çš„å®ç°.

ç°åœ¨è®©æˆ‘ä»¬æ¥å®šä¹‰æˆ‘ä»¬çš„é’ˆå¯¹ `Enum.map/2` çš„ä¼˜åŒ–.
æˆ‘è®¤ä¸ºåº”è¯¥æŠŠæœ‰å…³ä¼˜åŒ–çš„ä»£ç éƒ½æ”¾åœ¨ `optimizer` ç›®å½•ä¸‹,
è€Œä¸º `Enum.map/2` åšä¼˜åŒ–çš„æ¨¡å—å°±å‘½åä¸º `Optimizer.EnumMap` å§.

```elixir
defmodule Optimizer.EnumMap do
  @behaviour Optimizer

  @impl Optimizer
  def optimize(__MODULE__, list) do
    reduce_map(list)
  end

  defp reduce_map(ast_list) do
    ast_list
    |> group_map_call()
    |> Enum.map(&make_enum_maper/1)
  end

  defp group_map_call(ast_list) do
    for condidate_map_call <- ast_list, reduce: [] do
      [ele | rest] = acc ->
        if is_map_call_or_fun_group(ele) and
             is_map_call_or_fun_group(condidate_map_call) do
          fun_collection = collect_funs(condidate_map_call, ele)
          [fun_collection | rest]
        else
          [condidate_map_call | acc]
        end

      [] ->
        [condidate_map_call]
    end
    |> Enum.reverse()
  end

  @tag :funs_gruop_tag

  defp is_map_call_or_fun_group(ast) do
    case ast do
      {@tag, _} -> true
      {{{:., _, [{:__aliases__, _, [:Enum]}, :map]}, _, _}, 0} -> true
      _ -> false
    end
  end

  defp collect_funs(map1, map2) do
    fun1 = get_fun(map1)
    fun2 = get_fun(map2)

    funs =
      if is_list(fun2) do
        [fun1 | fun2]
      else
        [fun1, fun2]
      end

    {@tag, funs}
  end

  defp get_fun({@tag, funs}), do: funs

  defp get_fun(map) do
    [fun1] = elem(elem(map, 0), 2)
    fun1
  end

  defp make_enum_maper({@tag, funs}) do
    fun = compose(funs)

    ast = {{{:., [], [{:__aliases__, [], [:Enum]}, :map]}, [], [fun]}, 0}
    ast
  end

  defp make_enum_maper(v), do: v

  defp compose(list, acc \\ nil)

  defp compose([fun | funs], nil) do
    acc =
      quote do
        unquote(fun).()
      end

    compose(funs, acc)
  end

  defp compose([fun | funs], acc) do
    acc =
      quote do
        unquote(fun).() |> unquote(acc)
      end

    compose(funs, acc)
  end

  defp compose([], acc) do
    quote do
      fn v -> v |> unquote(acc) end
    end
  end
end
```

è¯´å¥½çš„æˆ‘ä»¬æ˜¯è¦è‡ªå®šä¹‰ç®¡é“æ“ä½œç¬¦ `|>` , é‚£ä¹ˆæœ€åè®©æˆ‘ä»¬å®Œæˆå®ƒçš„å®šä¹‰å§.

```elixir
defmodule Optimizer.Pipe do
  import Kernel, except: [|>: 2]
  alias Optimizer.{EnumMap}
  @optimizer [EnumMap]
  defmacro left |> right do
    [{h, _} | t] = Macro.unpipe({:|>, [], [left, right]})

    fun = fn {x, pos}, acc ->
      Macro.pipe(acc, x, pos)
    end

    t = Enum.reduce(@optimizer, t, &apply(&1, :optimize, [&1, &2]))
    :lists.foldl(fun, h, t)
  end
end
```

å½“æˆ‘ä»¬å®šä¹‰äº†æ›´å¤šçš„ä¼˜åŒ–å™¨çš„æ—¶å€™, æˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ä¸Šé¢ä»£ç çš„ ç¬¬ 3~4 ä¸¤è¡Œä»£ç , å°±å¯ä»¥äº†.

ä¸Šé¢çš„ä»£ç , å¤§éƒ¨åˆ†éƒ½æ˜¯ç…§æ¬ Elixir çš„ Kernel æ¨¡å—ä¸­ç®¡é“æ“ä½œç¬¦ `|>` çš„å®šä¹‰,
æˆ‘ä»¬åªæ˜¯å¢åŠ äº†ç¬¬ 12 è¡Œçš„å†…å®¹.

ä»£ç å®ç°äº†, ç°åœ¨æ¥çœ‹çœ‹ç»“æœå¦‚ä½•å§?

```elixir
use Optimizer

range
|> Enum.map(fun1)
|> Enum.map(fun2)
|> IO.inspect(label: "result of map chain")
```

çœ‹èµ·æ¥, åŠŸèƒ½æµ‹è¯•é€šè¿‡äº†, ä½†æ˜¯æˆ‘ä»¬æ¯•ç«Ÿæ˜¯åšä¼˜åŒ–çš„,
æˆ‘ä»¬çš„ä»£ç çœŸçš„èƒ½æå‡ä»£ç çš„æ‰§è¡Œæ•ˆç‡å—?
è®©æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹.

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    use Optimizer

    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  test "Optimizer of |> for Enum.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t1 * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

å…¶ä¸­æœ‰ä¸€æ¬¡, ä»£ç çš„è¾“å‡ºæ˜¯è¿™æ ·çš„:

> speed up -1.5641347109939043%.

ğŸ˜’ ç»“æœä¼˜åŒ–åçš„ä»£ç ä¸æ˜¯æé€Ÿäº†, åè€Œå˜æ…¢äº† 1.5 ä¸ªç™¾åˆ†ç‚¹. å¯æ˜¯ä¸ºä»€ä¹ˆä¼šè¿™æ ·å•Š?

è¿™æ˜¯å› ä¸º LiveBook ä»£ç  Cell æœ¬è´¨ä¸Šæ˜¯è§£é‡Šæ‰§è¡Œçš„, å°±åƒæˆ‘ä»¬ä¸èƒ½ä»¥ IEx ä¸­çš„ä»£ç è¿è¡Œæ—¶é—´æ¥è¡¡é‡ä»£ç çš„æ•ˆç‡ä¸€æ ·,
æˆ‘ä»¬ä¹Ÿä¸èƒ½ç”¨ LiveBook çš„ Cell çš„æ‰§è¡Œæ—¶é—´æ¥è¡¡é‡ä»£ç çš„æ•ˆç‡.

è¿™ä¸ªä¼˜åŒ–çš„å®ç°, å…¶å®å¹¶ä¸æ˜¯é‚£ä¹ˆçš„å¤æ‚, ä¸ºä»€ä¹ˆ Elixir ç¼–è¯‘å™¨ä¸è¿™æ ·åšå‘¢?
è¿™é‡Œæœ‰ä¸¤ä¸ªåŸå› . ç¬¬ä¸€åŸå› , å°±æ˜¯ Elixir æ ‡å‡†åº“ä¸­æœ‰ `Stream` æ¨¡å—, 
æ–‡æ¡£ä¸­, æ˜ç¡®æåˆ° `Stream.map` ä¼šç»„åˆå‡½æ•°çš„. ä¹Ÿå°±æ˜¯è¯´, 
Elixir æ˜¯ä»¥ `Stream.map` æ¥å®Œæˆæˆ‘ä»¬è¿™é‡Œçš„å·¥ä½œçš„.ä¾‹å¦‚æˆ‘ä»¬ä¸Šé¢çš„ä»£ç , 
æˆ‘ä»¬åªæ˜¯ç”¨ `Stream` æ›¿æ¢äº† `Enum`. å°±è·å¾—äº†ç›¸åŒçš„ç»“æœ.

```elixir
range
|> Stream.map(fun1)
|> Stream.map(fun2)
|> Enum.to_list()
|> IO.inspect(label: "result of map chain")
```

é‚£ä¹ˆæ˜¯ä¸æ˜¯æˆ‘æ˜¯ä¸æ˜¯è§£å†³äº†ä¸€ä¸ªé”™è¯¯çš„é—®é¢˜çš„é—®é¢˜å‘¢?

æˆ‘çš„ç­”æ¡ˆæ˜¯: ä¸æ˜¯çš„. æˆ‘ä»¬çš„å·¥ä½œä¾æ—§æ˜¯æœ‰æ„ä¹‰çš„.

åœ¨å¯¹æˆ‘ä»¬çš„ä¼˜åŒ–åšæ•ˆç‡æµ‹è¯•çš„æ—¶å€™, æˆ‘ä»¬å‘ç°æœ‰æ—¶å€™, ç†è®ºä¸Šç»å¯¹ä¸æœ‰åº”è¯¥ä¸‹é™çš„ä»£ç ,
æµ‹è¯•çš„æ—¶å€™, æœ‰æ—¶å±…ç„¶ä¼šä¸‹é™ 1.5%. é‚£ä¹ˆ Stream ç‰ˆæœ¬çš„ä¼˜åŒ–å‘¢?
ä¼šæ¯”æˆ‘ä»¬çš„çš„ä»£ç æ•ˆç‡æ›´é«˜å—?
è®©æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹:

```elixir
ExUnit.start(autorun: false)

defmodule MyTest do
  use ExUnit.Case, async: true
  @range 1..1000

  def fun1(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Enum.map(&(&1 + 1))
      |> Enum.map(&(&1 - 1))
    end
  end

  def fun2(up \\ 10) do
    for _ <- 1..up do
      @range
      |> Stream.map(&(&1 + 1))
      |> Stream.map(&(&1 - 1))
      |> Enum.to_list()
    end
  end

  test "Enum.map vs Stream.map" do
    arg = [10000]
    task1 = Task.async(fn -> :timer.tc(&fun1/1, arg) end)
    task2 = Task.async(fn -> :timer.tc(&fun2/1, arg) end)

    [{t, v}, {t1, v1}] = Task.await_many([task1, task2], 60_000)
    IO.puts("speed up #{(t - t1) / t * 100}%.")
    assert v == v1
  end
end

ExUnit.run()
```

è¿™æ¬¡è¿è¡Œçš„ç»“æœæ›´åŠ ç³Ÿç³•, å’Œ `Enum.map` ç›¸æ¯”, 
`Stream.map` ç‰ˆæœ¬çš„ä»£ç æ•ˆç‡ä¸‹é™äº† 100% è¿˜å¤š.

1%~2% çš„æ•ˆç‡å·®å¼‚æˆ‘ä»¬è¿˜èƒ½æ¥å—æ˜¯ä»£ç æ‰§è¡Œè¿‡ç¨‹ä¸­å¶ç„¶å› ç´ å¸¦æ¥çš„,
ä½† `Stream.map` å’Œ `Enum.map` çš„å·¨å¤§å·®å¼‚ç»å¯¹ä¸èƒ½å½’ç»“ä¸ºè¿è¡Œæ—¶çš„å¶ç„¶å› ç´ .

æ‰€ä»¥ `Stream.map` è™½ç„¶å®Œæˆäº†çš„å‡½æ•°çš„ç»„åˆ, ä½†æ˜¯å´å¹¶æ²¡æœ‰æå‡æ•ˆç‡.

Elixir çš„ `Enum.map` ä¸ç»„åˆå‡½æ•°çš„ç¬¬äºŒä¸ªåŸå› æ˜¯, Elixir ä¸æ˜¯ä¸€ä¸ªçº¯çš„å‡½æ•°ç¼–ç¨‹è¯­è¨€.
ä¼ é€’ç»™ `Enum.map` ä¸èƒ½ä¿è¯æ²¡æœ‰å‰¯ä½œç”¨çš„. è€Œç†è®ºä¸Šæ¥è¯´,
åªæœ‰å½“ `Enum.map` ä¸­çš„å‡½æ•°æ˜¯çº¯å‡½æ•°çš„æ—¶å€™, æ‰å¯ä»¥ç»„åˆå‡½æ•°.
ä½†æ˜¯è¦åœ¨ç¼–è¯‘æ—¶åˆ¤æ–­ä¸€ä¸ªå‡½æ•°ä¸­æ˜¯å¦æœ‰å‰¯ä½œç”¨, è¿™åŸºæœ¬ä¸Šåšä¸åˆ°,
æ‰€ä»¥ Elixir çš„æ ‡å‡†åº“ä¸­ `Enum.map` å¹¶ä¸åšå‡½æ•°çš„ç»„åˆ.

ç°åœ¨æˆ‘ä»¬çš„ä¼˜åŒ–å™¨, å¿½ç•¥äº†å‡½æ•°ä¸­çš„å‰¯ä½œç”¨è€Œå¼ºè¡Œå¯¹å‡½æ•°åšäº†ç»„åˆ.
æŠŠä¼˜åŒ–å™¨åšæµ‹è¯•çš„ä»£ç , ä¿å­˜åˆ°æ–‡ä»¶ä¸­, ä½¿ç”¨ `mix test` æ¥é‡æ–°æµ‹è¯•, å°±ä¼šå‘ç°, 
ä¼˜åŒ–å™¨çš„æ•ˆç‡æœ‰äº† 30%~40% çš„æ•ˆç‡æå‡.

å¯¹åŠŸèƒ½ä¸€æ ·, æ‰‹åŠ¨ç»„åˆçš„å‡½æ•°åšæµ‹è¯•, å…¶æ•ˆç‡å’Œæˆ‘ä»¬çš„ä»£ç çš„ä¸€æ ·.
è¿™å°±æ˜¯å‰é¢æˆ‘çš„è¯´è¿™ä¸ªå·¥ä½œçš„æ„ä¹‰æ‰€åœ¨.
