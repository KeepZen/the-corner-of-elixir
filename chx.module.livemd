# 模块和宏

## 从 Elixir 到 Erlang

Elixir 的模块让我理解起来非常的困惑, 因为感觉模块在 Elixir 中是一个语法概念, 
而不是代码组织的概念. 所以当我学习 Elixir 的时候, 学习到模块的时候, 我完全是囫囵吞枣的,
对于模块是什么是没有概念的, 而且 Elixir 的社区文档中, 对模块也没有清晰的定义,
或者说我对模块的认识和期望是有巨大差距的.

但是当我学习了一点点 Erlang 的知识后, 对 Elixir 相关知识就清晰起来了.

模块是什么呢?

首先模块是虚拟机组织程序的单元. 这里虚拟机指的是 BEAM 的运行时环境,
运行时以模块为单元来加载编译好的字节码, 所以这里就要求编译器必须以模块为输出单元,
编译器是 BEAM 和源码之间的桥梁, 也因此模块就成了 Erlang 组织代码的单元.

Erlang 的源码和字节码是一一对应的, 不知识一个 `.erl` 的源文件对应一个 `.beam`的字节码文件,
这种物理上的一一对应, 还有概念上的.
比如模块属性, 模块属性在 Eralng 中是如此简单, 就是这个模块的元信息.
在 Erlang 的语言层面, 就是代码开始时写的以 `-` 到头文件.
不难想象 Erlang 的编译器是如何把源码中的这些信息, 转化成 `.beam` 字节码中的字段的.
这个 `.beam` 文件的生成是困难的, 只是 `.beam` 文件的元信息, 其实是不难的.
例如, 看到这样的 Erlang 代码:

```erlang
-module(hello).
-export([say_hi/1,say_by/1]).
...
```

那么我就明白了, 模块中的属性: 模块名, 导出函数, 以及私有的函数这些模块的元信息,
编译器怎么产生得了.

但是 Elixir 中, 这些知识不是那么自然的. 因为 Elixir 源码和字节码之间不在是一一对应了.
而关于这一点, 我认为就需要先立即什么时宏(Macro).

我们不做学理性的定义, 我认为宏就是编译时指导编译器的代码和指令.

这样的定义, 可以涵盖从 C 和 Erlang 这样的预处理宏,
又可以覆盖像 Elixir 这样的直接操纵 AST 的宏.

在 Erlang 中宏的使用时非常节俭的, 所以 Erlang 的宏提供的功能非常有限,
所以不能给 Erlang 编译器太多的指导, 编译器自己指导如何处理源码.

Elixir 就不同了. Elixir 中几乎处处都是宏.

Erlang 代码, 还可以说时编译器解析处理源码, 产生字节码, 其中的源码是需要处理的数据.

Elixir 因为大量代码都是宏, 安装我们对宏的定义, 也就是密集的对编译器的指令,
所以 Elixir 源码不是编译器处理的数据, 而是在对编译器编程, 然编译器根据自己的指令,
来产生出字节码.

这也就是为什么, Erlang 中清楚明了的模块概念, 到 Elixir 中让我晕头转向了.
因为视角错了, 不理解宏是编译器时的概念, 而依旧把 Elixir 的编译过程,
看作是编译器对源码的处理, 那就难怪找不到北了.

## 运行时探测模块


