# 如何理解宏

## 宏 与 语言分类

宏是什么? 这似乎是一个非常容易掌握的概念. 我的理解是这样的:
宏是写给编译器的指令. 这个定义非常宽泛, 从 C 这样的最简单的文本替换宏,
到 Lisp 这样的对抽象语法树做处理的宏, 都可以包括.

这样的理解不能说错误, 但是取没有抓住宏的本质.
我发现, 这就是为什么, 我现在学习 Elixir 的时候,
时常遇到困惑的一个根本原因.

所以如此, 和我的知识储备有关系.
我学习和熟练掌握的编程语言中, 宏在其中要么基本上没有地位(Python, Js),
要么只有非常非常小的作用(C, C++). 所以对宏的理解,
才会一直停留在概念的阶段.

按照我们的定义, 宏只能是编译型语言中才会出现的概念.
因为解释性的语言, 没有编译器的存在.
当然了, 我知道也理解, 现在大部分的解释器,
实际上也是要做编译器要做的工作的. 所以理论上, 也应该有宏的.
但是对于解释性的语言来说, 要区分宏和普通的代码是困难的.
因为代码的执行和宏的执行, 概念上有先后的两个动作,
对于解释性的语言, 从外部观察时, 这两个动作是难以区分的.
但是对于编译型的语言, 因为编译代码和运行程序可以做到时间上间断,
所以可以清楚区分它们. 例如, 同样的关于外部代码的导入的语法,
C/C++ 中以 `#include` 的形式出现, 通过预处理,
我们可以清楚的体会到宏的存在; 而 Js 中以 `import` 语句,
Js 解释器与 C 编译器做了大量的相同的工作,
却难以从外部观察到, 如果不考虑程序的执行的话.

不那么严格的解释, 可以认为解释性语言, 解释器对源码是解释执行的.
而编译型的语言, 编译器是要编译源码的. 通常情况下, 
**编译** 我理解就是做翻译, 把源码中的文本翻译成中央处理器(CPU)
或者虚拟机(VM) 可以理解的内容.
这样的理解对于普通的代码是没有问题的, 但是当考虑宏的时候,
编译器对宏做的事情就不能这样理解了.
普通的代码, 对编译器来说, 是要处理的数据; 但宏不是编译器要处理的数据,
而是代执行的指令. 编译器对宏, 正像解释器对源码做的一样, 解释执行它们.

拿一个社会生活的场景来对比一下, 也许就更清楚了.

一个对翻译品质有担当的翻译者, 在翻译的时候往往会和作者沟通,
如果两人关系更密切的话, 甚至拿到的翻译底本, 直接就有原作者的批注.
这些批注是写给译者的, 是提醒译者原文的正确意图是什么.
这些内容(批注或者作者的答复), 虽然不是原书的内容,
但是它们对译文来说, 是必要的, 因为它们确确实实的要影响最后译文,
进而影响读者对原文的理解.
那么在这里, 译者就是编译器; 原始的书稿内容是常规的代码;
作者的批注和答复, 就是宏; 译文就是编译后的目标码; 读者就是 CPU 或 VM.

在 C/C++ 以及 Erlang 这些语言中, 宏能完成的工作是非常少的,
就像作者给译者的注释那样, 大部分的工作还是要译者自己辛苦完成的.

但是在 Elixir 中, 毫不夸张的说, 离不开宏几乎没法写代码.

例如, 定义 BEAM 的一个最基本的编译单元 -- **模块**.
但是在 Elixir 中, 我们必须使用宏 `defmodule`.
它和 Erlang 中的 `-module(MODULE_NAME).` 做的工作完全不是一个数量级别的.
`-module(MODULE_NAME).` 只是标记了模块的名字, 并没有涉及到模块的正文.
`defmodule` 不一样, 它不但包含了模块的名字,而且包含了模块正文.
所以脚注的意象在这里就不合适了. Elixir 宏的合适意象应该汉语屋的故事[^chinese-room].
译者对原文的翻译是智慧型的劳动; 汉语屋中的人做的却是机械的工作.

从语言学的角度来看, C/C++, Erlang 的宏不能构成图灵完备的一个语言,
或者精确的说, 设计的初衷不是把它们当作一个完整的语言来使用的[^c-macro].
但是 Elixir 中的宏是图灵完备的, 这就是为什么, 我们可以写 Elixir 脚本的原因.
Elixir 脚本中, 和 Erlang 的 escript 不一样, Elixir 脚本,
我们都不需要写一个入口点函数, 理论上, 我们真的可以让 Elixir
的编译器在编译的过程中完成所有的工作, 就像使用其他的脚本语言那样.

[^chinese-room]: 见百度百科[中文房间](https://baike.baidu.com/item/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4/3581768), 或维基百科[中文屋](https://en.jinzhao.wiki/wiki/Chinese_room).

[^c-macro]: 有关 C 语言图灵完备性的讨论见 https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete

接下来, 让我们近距离的观察 `defmodule` 这个宏.

```elixir
IO.puts("hello")
```

## 模块

Elixir 的模块, 无论对比于 Erlang 的模块, 还是 C++ 或 Java 的类都是不合适的.

但是当我学习了一点点 Erlang 的知识后, 对 Elixir 相关知识就清晰起来了.

模块是什么呢?

首先模块是虚拟机组织程序的单元. 这里虚拟机指的是 BEAM 的运行时环境,
运行时以模块为单元来加载编译好的字节码, 所以这里就要求编译器必须以模块为输出单元,
编译器是 BEAM 和源码之间的桥梁, 也因此模块就成了 Erlang 组织代码的单元.

Erlang 的源码和字节码是一一对应的, 不知识一个 `.erl` 的源文件对应一个 `.beam`的字节码文件,
这种物理上的一一对应, 还有概念上的.
比如模块属性, 模块属性在 Eralng 中是如此简单, 就是这个模块的元信息.
在 Erlang 的语言层面, 就是代码开始时写的以 `-` 到头文件.
不难想象 Erlang 的编译器是如何把源码中的这些信息, 转化成 `.beam` 字节码中的字段的.
这个 `.beam` 文件的生成是困难的, 只是 `.beam` 文件的元信息, 其实是不难的.
例如, 看到这样的 Erlang 代码:

```erlang
-module(hello).
-export([say_hi/1,say_by/1]).
...
```

那么我就明白了, 模块中的属性: 模块名, 导出函数, 以及私有的函数这些模块的元信息,
编译器怎么产生得了.

但是 Elixir 中, 这些知识不是那么自然的. 因为 Elixir 源码和字节码之间不在是一一对应了.
而关于这一点, 我认为就需要先立即什么时宏(Macro).

我们不做学理性的定义, 我认为宏就是编译时指导编译器的代码和指令.

这样的定义, 可以涵盖从 C 和 Erlang 这样的预处理宏,
又可以覆盖像 Elixir 这样的直接操纵 AST 的宏.

在 Erlang 中宏的使用时非常节俭的, 所以 Erlang 的宏提供的功能非常有限,
所以不能给 Erlang 编译器太多的指导, 编译器自己指导如何处理源码.

Elixir 就不同了. Elixir 中几乎处处都是宏.

Erlang 代码, 还可以说时编译器解析处理源码, 产生字节码, 其中的源码是需要处理的数据.

Elixir 因为大量代码都是宏, 安装我们对宏的定义, 也就是密集的对编译器的指令,
所以 Elixir 源码不是编译器处理的数据, 而是在对编译器编程, 然编译器根据自己的指令,
来产生出字节码.

这也就是为什么, Erlang 中清楚明了的模块概念, 到 Elixir 中让我晕头转向了.
因为视角错了, 不理解宏是编译器时的概念, 而依旧把 Elixir 的编译过程,
看作是编译器对源码的处理, 那就难怪找不到北了.

## 模块

## Section
