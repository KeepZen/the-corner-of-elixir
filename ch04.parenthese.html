<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>括号 - 角落里的长生不老药</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="ch01.intruction.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="ch02.plus_and_minus.html"><strong aria-hidden="true">2.</strong> 加和减</a></li><li class="chapter-item expanded "><a href="ch03.pattern_match.html"><strong aria-hidden="true">3.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="ch04.parenthese.html" class="active"><strong aria-hidden="true">4.</strong> 括号</a></li><li class="chapter-item expanded "><a href="ch05.new_constructor.html"><strong aria-hidden="true">5.</strong> 定制新结构</a></li><li class="chapter-item expanded "><a href="ch06.async_programe.html"><strong aria-hidden="true">6.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="ch07.pipe.html"><strong aria-hidden="true">7.</strong> 管道操作符</a></li><li class="chapter-item expanded "><a href="ch08.error_handle.html"><strong aria-hidden="true">8.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="ch09.module.html"><strong aria-hidden="true">9.</strong> 模块</a></li><li class="chapter-item expanded "><a href="ch10.protocol_and_behaviour.html"><strong aria-hidden="true">10.</strong> 协议与行为</a></li><li class="chapter-item expanded "><a href="ch11.macro.html"><strong aria-hidden="true">11.</strong> 如何理解宏</a></li><li class="chapter-item expanded "><a href="ch12.process.html"><strong aria-hidden="true">12.</strong> 进程</a></li><li class="chapter-item expanded "><a href="chx.cold_knowledge.html"><strong aria-hidden="true">13.</strong> 附录 冷知识</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">角落里的长生不老药</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="第四章-括号"><a class="header" href="#第四章-括号">第四章 括号</a></h1>
<h2 id="本章的目的"><a class="header" href="#本章的目的">本章的目的</a></h2>
<p>在这一章我们讨论的是 <strong>语法上可以如何做</strong>, 而 <strong>不是实际编码上应该怎么做</strong>.
可以做是一个硬规则, 是面向编译器的; 应该怎么做是一个规范, 是面向程序员的.
所以很多地方, 在讨论完可以如何做后, 我又用黑体给出了社区推荐的做法,
也就是应该如何作.</p>
<p>本章讨论可以做的方法绝大部分, 不符合社区的推荐做法. 一边展示不推荐的做法,
一边规劝大家不要这样做, 这看起来似乎是在左右互博,自相矛盾.
所以这样做, 是为了搞清楚所以然 --- --- 社区给出这些规范的所以然, 也就是规范背后的原因.</p>
<p>当真正的理解了什么是可以做的, 以及什么必须做的时候, 才能理解规范所以如此的原因.</p>
<h2 id="使用括号改变优先级"><a class="header" href="#使用括号改变优先级">使用括号改变优先级</a></h2>
<p>使用括号改变优先级, 这是最普通的括号的用法. 这和我们在数学课堂上使用括号的情形一样.
例如数学公式 $a\times{}(b+c)$, 对应的程序表达式就是 <code>a*(b+c)</code>.
如果要消除括号, 那么需要调整代码, 并需要引入中间变量. 例如上面的等价的表达式,
可以写作 <code>tem=b+c</code> 和 <code>a*tem</code> 两个表达式.
但是这里有一个前提: 最初的表达式, 在一个块环境中. 因为多个表达式, 必须在块环境中.</p>
<h2 id="括号与匿名函数定义"><a class="header" href="#括号与匿名函数定义">括号与匿名函数定义</a></h2>
<h3 id="使用-fn----end-定义匿名函数"><a class="header" href="#使用-fn----end-定义匿名函数">使用 <code>fn ... -&gt; end</code> 定义匿名函数</a></h3>
<p>当我们使用 <code>fn ... -&gt; end</code> 来定义匿名函数的时候, 括号是可选的.</p>
<pre><code class="language-elixir">pi = fn -&gt; :math.pi() end
e= fn ()-&gt; :math.exp(1) end
pi.() |&gt; IO.inspect(label: &quot;pi.()&quot;)
e.()  |&gt; IO.inspect(label: &quot; e.()&quot;)

id = fn v -&gt; v end
add_1 = fn ( v ) -&gt; v + 1 end
id.(1)    |&gt; IO.inspect(label: &quot;   id.(1)&quot;)
add_1.(1) |&gt; IO.inspect(label: &quot;add_1.(1)&quot;)

add = fn a, b -&gt; a + b end
sub = fn (a,b) -&gt; a-b end
add.(1,2) |&gt; IO.inspect(label: &quot;add.(1,2)&quot;)
sub.(1,2) |&gt; IO.inspect(label: &quot;sub.(1,2)&quot;)
</code></pre>
<p>上面的代码中, 对于零元, 一元和二元匿名函数, 用带括号和不带括号两种样式分别做了定义.
可以看出, 在定义匿名函数的时候, 括号完全是可选的.</p>
<p><strong>社区的推荐</strong>: 使用 <code>fn...-&gt;end</code> 定义匿名函数的时候, 不用括号来包裹参数列表.</p>
<p>那么为什么 <code>fn...-&gt;end</code> 定义匿名函数的时候可以不用括号呢?</p>
<p>从形式来看, <code>-&gt;</code> 是参数列表结束而函数分句开始的标识.
所以不需要一个额外的括号来界定参数什么时候开始什么时候结束.</p>
<h3 id="使用函数捕获操作符--定义匿名函数"><a class="header" href="#使用函数捕获操作符--定义匿名函数">使用函数捕获操作符 &amp; 定义匿名函数</a></h3>
<p>使用函数捕获操作符 <code>&amp;</code> 定义定义函数的时候, <code>()</code> 的作用只限于调整代码的优先级.</p>
<p>而 Elixir 中函数捕获操作符 <code>&amp;</code> 的优先级只高于 <code>=&gt;</code>, <code>|</code>, <code>::</code> <code>&lt;-</code> 和 <code>\\</code>
这几个操作符, 而这几个操作符, 又都是在特殊的环境下才有意义的, 所以几乎可以说,
函数捕获操作符 <code>&amp;</code> 是最低的优先级的操作符.</p>
<p>因此, 对定义匿名函数的表达式 <code>&amp;(expression)</code> 来说,
因为函数捕获操作符 <code>&amp;</code> 的优先级最低, 而且在 <code>expression</code> 中不允许嵌套函数捕获表达式,
因此 <code>expression</code> 中的其他的操作符, 优先级都比函数捕获操作符 <code>&amp;</code> 的高. 
所以, 在表达式 <code>&amp;(expression)</code> 中有没有括号, 表达式的计算顺序都一样.
换句话说, 这里的括号就是多余的, 可以省略.</p>
<p>当需要把定义的函数赋值给一个变量的时候, 匹配操作符 <code>=</code> 的优先级高于函数捕获操作符 <code>&amp;</code>,
但是匹配操作符 <code>=</code> 是右结合的, 会优先完成左值的计算.
所以使用函数捕获操作符, 在匹配操作符 <code>=</code> 右侧定义匿名函数的时候,
像表达式 <code>a=(&amp; expression)</code> 这样, 其中的括号也可以省略.
下面的代码片段, 展示了这种这种情形.</p>
<pre><code class="language-elixir">id2 = &amp; &amp;1
add_1 = &amp; &amp;1 + 1
sum = &amp; &amp;1 + &amp;2
sub = &amp; &amp;1 - &amp;2
id2.(1) |&gt; IO.inspect(label:    &quot;  id2.(1)&quot;)
add_1.(1) |&gt; IO.inspect(label:  &quot;add_1.(1)&quot;)
sum.(1, 2) |&gt; IO.inspect(label: &quot;sum.(1,2)&quot;)
sub.(1, 2) |&gt; IO.inspect(label: &quot;sub.(1,2)&quot;)
</code></pre>
<p>所以和 <code>fn -&gt; end</code> 语法定义匿名函数情形几乎一样, 使用函数捕获操作符 <code>&amp;</code>
定义匿名函数的也不需要小括号, 但是这里有一点点的不同.</p>
<ol>
<li>
<p><code>fn</code> 和 <code>end</code> 是作为保留字存在的, 优先级高于其他的操作符.</p>
</li>
<li>
<p>匿名函数可以作为参数传递给其他高阶函数</p>
<p>当把匿名函数通过管道操作符 <code>|&gt;</code>, 传递给其他高阶函数的时候,
使用函数捕获操作符 <code>&amp;</code> 定义的匿名函数就必须使用括号,
因为管道操作符符 <code>|&gt;</code> 的优先级高于函数捕获操作符 <code>&amp;</code>.</p>
</li>
</ol>
<p>例如:</p>
<pre><code class="language-elixir">(&amp; &amp;1 + &amp;2 + &amp;3) |&gt; apply([1, 2, 3])
</code></pre>
<p>因为管道操作符 <code>|&gt;</code> 优先级高于函数捕获操作符 <code>&amp;</code>,
所以要表达, 把匿名函数作为管道操作符 <code>|&gt;</code> 的左操作数, 这样的意图,
就必须为函数捕获操作符 <code>&amp;</code> 定义匿名函数的表达式加上括号.</p>
<p>现在我们分析一下, 表达式 <code>&amp; &amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])</code> 的语义.</p>
<pre><code class="language-elixir">fun = &amp; &amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])
true = is_function(fun,3)
</code></pre>
<p>所以, 这个表达式 <code>&amp; &amp;1+&amp;2+&amp;3 |&gt; apply([1,2,3])</code> 计算后的结果为一个匿名的三元函数.
如果我们以参数 <code>1,2,3</code> 来调用这个匿名函数, 得到一个错误:</p>
<blockquote>
<p>** (BadFunctionError) expected a function, got: 6.</p>
</blockquote>
<p>为什么会这样呢?</p>
<ol>
<li>函数捕获操作符 <code>&amp;</code> 操作优先级最低, 所以整个表达式等价于
<code>&amp;(&amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3]))</code>.</li>
<li>加法运算符 <code>+</code> 优先级高于管道运算符 <code>|&gt;</code>, 所以
<code>&amp;1 + &amp;2 + &amp;3 |&gt; apply([1,2,3])</code> 等价于 <code>(&amp;1 + &amp;2 + &amp;3) |&gt; apply([1,2,3])</code>.</li>
<li>因此整个表达式的意思就是: 这是一个三元匿名函数(<code>&amp;1,&amp;2,&amp;3</code>),
参数求和后 (<code>&amp;1+ &amp;2 + &amp;3</code>), 把结果作为第一个参数传递给 <code>apply/2</code>.</li>
</ol>
<p>虽然我们获得了一个三元的匿名函数, 但是这个匿名函数无论我们输入的参数是什么,
都是要报错的.</p>
<p>三个参数按加法计算, 所以接受的只能是数值类型, 计算后的结果也只能是 <strong>数值</strong>,
但是 <code>apply/2</code> 要求的第一个参数是一个 <strong>函数</strong>,
所以无论我们以什么参数来调用这个匿名函数, 其结果都是抛出报错.</p>
<p><strong>结论</strong>: 在用函数捕获操作符 <code>&amp;</code> 定义匿名函数时, 不需要括号的参与,
但是要直接把函数捕获操作符 <code>&amp;</code> 定义的函数, 通过管道操作符 <code>|&gt;</code> 传递给其他函数的时候,
因为涉及优先级的问题, 所以必须使用括号, 把函数捕获操作符的优先级提高.</p>
<p>但是在使用函数捕获操作符 <code>&amp;</code> 的时候, 基于代码的可读性, 社区的推荐使用括号.</p>
<p><strong>社区推荐做法</strong>: 使用 <code>&amp;</code> 定义匿名函数的时候, 使用括号把<strong>表达式括起来</strong>,
即使很多时候语法上是不必要的.</p>
<p>也就是说, 按照社区的规范上面的代码中对匿名函数 <code>id2</code>, <code>add_2</code> 等函数的定义, 应该写作:</p>
<pre><code class="language-elixir">id2 = &amp; &amp;1
add_1 = &amp;(&amp;1 + 1)
sum = &amp;(&amp;1 + &amp;2)
sub = &amp;(&amp;1 - &amp;2)
</code></pre>
<h2 id="括号与命名函数定义"><a class="header" href="#括号与命名函数定义">括号与命名函数定义</a></h2>
<p><code>def/2</code>, <code>defp/2</code>, <code>defmacro/2</code> 和 <code>defmacrop/2</code> 用来在模块中定义函数,
私有函数, 宏以及私有宏. 这里为了论述的方便, 用函数指代命名函数, 私有函数,
宏以及私有宏.</p>
<h3 id="函数的调用格式"><a class="header" href="#函数的调用格式">函数的调用格式</a></h3>
<p>查看文档可以知道这些宏接受的第一个参数叫做 <code>call</code>,
而且我们知道这些宏都有一个同名的一元宏, 其功能就是定义函数或宏的签名,
所以 <code>call</code> 在其他语言中的对应物, 就是函数签名 (function signature) 
或者函数头 (function head).</p>
<p>但是为什么不叫函数签名或函数头, 而叫 call 呢? 用一个动词命名参数名,
这多少还是有悖正常的思维. 其中又什么深意吗?</p>
<p>还真是的, 我在 Elixir 论坛中, 得到了答案: 这些宏接受的第一个参数,
必须是函数的调用的形式. 或者说, 代码 <code>def fun(a,b) do...end</code>,
是在编译时调用 <code>def/2</code>, 这个函数接受两个参数, 第一个是 <code>fun(a,b)</code>
这个函数调用的返回值, 当然这个函数不存在.
<code>def</code> 会解析出函数名, 参数列表, 并按照我们的调用的方式, 为我们创建这个函数.</p>
<p>现在让我们来看看函数调用. 函数调用有两种形式:</p>
<ol>
<li><code>fun_name arg1, arg2</code></li>
<li><code>fun_name(arg1, arg2)</code></li>
</ol>
<p>所以 <code>call</code> 参数, 也就这些宏接受的第一个参数, 也必须符合这两种模式之一.
要特别注意第二种形式, 括号和函数名之间不能有空格的.</p>
<p>但是为什么要有两种形式呢? 大部分的编程语言, 实际上都只支持第 2 种形式.
Elixir 所以支持第 1 种形式有两个原因:</p>
<ol>
<li>零元函数调用, 省略括号, 看起来像常数的引用, 对于纯函数来说, 零元函数表现的也真的就像一个常数.</li>
<li>宏忽略小括号, 可以更像其他语言的关键字</li>
</ol>
<p>Elixir 很多功能是宏提供的, 这就使得必须支持宏调用的时候可以省略括号,
否则就需要使用大量的嵌套的括号, 这会使得代码看起来非常的繁琐.
例如这样的代码:</p>
<pre><code class="language-elixir">defmodule(M,
  do: (
    def(
      fun_name(a, c),
      do: (
        a + c ))))
</code></pre>
<p>看起来真正像 M 表达式<sup class="footnote-reference"><a href="#m-exp">1</a></sup>啊.</p>
<div class="footnote-definition" id="m-exp"><sup class="footnote-definition-label">1</sup>
<p>Meta-expression, 这是 List 语言的设计者最初打算实现的,
给程序员使用的表达式格式, 但是最终 S 表达式流行起来, M 表达式从来没有实现.</p>
</div>
<h3 id="函数体"><a class="header" href="#函数体">函数体</a></h3>
<p><code>def*/2</code> 这几个宏的, 第一个参数 <code>call</code> 我们已经学习了,
他们的第二个参数是 <code>expression</code>, 也就是表达式. 但是实际上必须是 <code>do-block</code>,
其他的表达式, 都是语法错误, 比如我们就不能这样写代码 <code>def add(a,b), a+b</code>.</p>
<p>也就说, 这几个 <code>def*/2</code> 宏接受的第二个参数必须是一个 <code>[do: expression]</code>.
但是需要注意的是, <code>:do</code> 的值只能是一个表达式, 当函数体有不只一个表达式的时候,
就需要用代码块, 或者说块表达式.</p>
<p>而 Elixir 中定义函数体的代码块的有以下两种方式:</p>
<ol>
<li><code>do...end</code> 直接创建的是一个 <code>do-block</code>.</li>
<li>还可以使用 <code>()</code> 作为块的分界符, 换行或分号作为语句之间分隔符, 来创建块表达式.
也就是说, 还可以使用 <code>[do: (...;...)]</code> 来创建了一个 <code>do-block</code>.</li>
</ol>
<h3 id="函数定义"><a class="header" href="#函数定义">函数定义</a></h3>
<p>这几个 <code>def*/2</code> 宏, 2 个参数各有两种风格, 总共就有 4 种组合.
但是这四种组合中, <strong>不带括号的函数调用</strong> 与 <strong><code>[do: (...)]</code></strong> 的组合<strong>不完全支持</strong>.
例如下面的代码:</p>
<pre><code class="language-elixir">defmodule FunDefine do
  def add(a, b) do
    a + b
  end

  def sub(a, b), do: a - b

  def div(a, b) do
    if is_integer(a) and is_integer(b) do
      Kernel.div(a, b)
    else
      a / b
    end
  end

  # def multiply a, b, do: a * b
  # def multiply a, b  do: a * b
  # 注意这里没有逗号  ^, 可是依旧不能通过编译
end
</code></pre>
<p>我试图通过定义 <code>add</code>, <code>sub</code>, <code>div</code> 和 <code>multiply</code> 来演示函数定义的全部 4 种组合.
但是第 4 种样式报错, 为什么呢?
<code>def multiply a, b, do: a * b</code> 不正确的原因在于,
词法分析器无法判断<strong>函数参数列表</strong>什么时候结束. 那么对于代码:</p>
<pre><code class="language-elixir">def add a,b do
  a + b
end
</code></pre>
<p>词法分析器是怎么就能知道参数列表什么时候结束呢? 这就是 <code>do</code> 的作用了.
否则, 如果编译器只是通过 <code>:do</code> 前面是不是有逗号, 来判断参数定义是否结束的话,
那么 <code>def multiply a,b do: (a*b)</code> 就应该通过编译的.
现在这样的代码不能通过编译, 说明在编译的词法分析阶段, 对 <code>do</code> 是做了特殊处理.
这是正是 <code>do</code> 作为保留字的原因, <code>do</code> 在这里并没有引入控制结构,
它充当了参数列表与函数体之间的分界符, 并创建了 <code>do-block</code>.</p>
<p>上面我们说, 第四种组合不被完全支持, 换句话说, 这种组合方式得到了部分支持的.
那么什么时候支持这种格式呢? 那就是定义无参数函数的时候.
例如下面的代码, 语法上是正确的:</p>
<pre><code class="language-elixir">def e, do: :math.exp(1)
</code></pre>
<p><strong>推荐规范</strong>: 定义函数或宏的时候, 零元函数除外, 推荐带有括号的函数头格式.</p>
<h2 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h2>
<p>命名的函数调用可以省略括号, 而匿名函数调用的时候必须使用括号.
函数调用的时候, 如果使用括号, <strong>函数名和括号之间不能有空白</strong>.</p>
<h3 id="命名函数的省略括号调用"><a class="header" href="#命名函数的省略括号调用">命名函数的省略括号调用</a></h3>
<p>我认为允许命名函数和私有函数调用可以省略括号<sup class="footnote-reference"><a href="#function">2</a></sup>, 这是 Elixir
语言的一个设计缺陷. 理由如下:</p>
<ol>
<li>这样做使得命名函数, 不再是一等公民了, 一个函数式编程的语言, 命名函数不是一等公民,
总是些不协调的.</li>
<li>允许不带括号调用函数, 使得不能直接以函数名来引用函数, 而必须使用 <code>&amp;</code> 或者
<code>Function.capture/3</code>.</li>
</ol>
<div class="footnote-definition" id="function"><sup class="footnote-definition-label">2</sup>
<p>这一小结节中, 函数就只是函数, 不再包括宏.</p>
</div>
<p>允许函数调用省略括号带来的好处非常的小; 但因此导致必须使用函数捕获的相关语法,
才能引用函数. 这使得函数引用的语法非常不经济.</p>
<p>在我编码的时候, 首先思考的是哪个函数可以满足需求, 无论是要调用它,
还是要把它作为参数传递其他高阶函数. 所以首先确定是函数的名字,
然后才是思考是 <em>调用</em> 还是 <em>引用</em>.</p>
<p>如果是要调用这个函数, 写括号也非常的流畅,
因为这时的思维的运行步骤与代码的书写步骤是一致的.</p>
<p>但是在需要引用这个函数的地方, 因为函数捕获操作符 <code>&amp;</code> 放在函数名的前面,
当意识到需要的是这个函数的引用的时候, 必须把光标重新移动到函数名的前面,
更糟心的是, 引用命名函数 (准确的说是捕获), 还需要指定函数的元数,
这意味着, 还需要再次把光标移动到函数名的后面.
也就是说, 对于代码, <code>&amp;String.length/1</code>, 我往往是先写出中间的 <code>String.length</code> 部分,
然后向左移动光标, 到这个表达式的头部补上函数捕获操作符 <code>&amp;</code>,
再向右移动光标到表达式末尾, 指定函数的元数. 这种体验实在是太糟糕了.</p>
<p>很多时候, 看到代码中 <code>&amp;String.length(&amp;1)</code> 这样的表达式,
我忍不住就想把其修改为 <code>&amp;String.length/1</code>. 也许 <code>&amp;String.length/1</code> 更正确和高效,
但是 <code>&amp;String.length(&amp;1)</code> 更加符合思维的顺序.</p>
<p>我的期望, 应该禁止命名函数的无括号调用语法, 而只允许宏调用可以省略括号.
这样函数名就是对函数的引用, 命名函数可以作为第一类公民了,
或者非常接近第一类公民了. 考虑到命名函数, 可能有多个同名而元数不同的函数,
引用命名函数的时候可以使用Eralng 函数导出一样的语法: <code>String.length/1</code>.
函数类型是不能作为除法的运算数的, 所以这样就没必要使用函数捕获操作符了.
实际上 Erlang 中就是这样来区分函数的引用, 还是函数的调用的.</p>
<p>可是这是一个大工程, 必须在 Elixir 的源码级别改动, 且如此改动, 还会引发不兼容问题.</p>
<h3 id="匿名函数调用必须用括号"><a class="header" href="#匿名函数调用必须用括号">匿名函数调用必须用括号</a></h3>
<p>调用匿名函数的时候, 必须使用括号.</p>
<p>例如这样的代码:</p>
<pre><code class="language-elixir">fun=fn a, b -&gt; (a**2 + b**2)**0.5 end;
fun.(3,5)
</code></pre>
<p>关于 Elixir 的匿名函数调用需要一个句号 <code>.</code> , Erlang 之父 Joe Armstrong 在
<a href="https://joearms.github.io/#2013-05-31%20A%20week%20with%20Elixir">A Weak of Elixir</a> 的文章中,
认为这是 Elixir 语义设计的不好的地方. 当然了, 也有不少人认为这不是问题.</p>
<p>我想从另一个角度来考虑这个问题. 一个函数, 尤其是支持函数编程语言中的函数,
总是需要从语法上来区分 <strong>调用</strong>  还是 <strong>引用</strong> 的.
Elixir 的命名函数, 牺牲了对函数的引用的便捷, 换来调用命名函数时括号的可省略.
匿名函数的值, 本身就是存在一个变量中的, 所以引用非常的方便, 那么调用这个匿名函数的时候,
变量名后面的这个 <code>.</code> 实际上就是一种宣告: 这是对函数的调用, 而不是引用其值.
所以理论上, 对匿名函数的调用也没必要必须使用括号.
但是为什么 Elixir 中却要求必须使用括号呢? 这里我们先把问题搁下,
让我们先来总结一些括号在 Elixir 中的用法.</p>
<h2 id="括号小结"><a class="header" href="#括号小结">括号小结</a></h2>
<p>上面的几节中, 我们学习了括号在函数定义, 调用, 以及其他场景下的作用.
总结一下, 其实共有三个作用:</p>
<ol>
<li>作为参数的列表的分界符</li>
<li>改变代码运行的优先级</li>
<li>创建块表达式</li>
</ol>
<p>现在问一个问题: 以下的代码, 语法上正确吗? 如果正确的话, 返回值是什么呢?</p>
<p><code>[]</code>, <code>{}</code>, <code>()</code></p>
<p>第一个问题的答案是: 这三个都是语法正确的.
前两个非常的常见, 它们是空的列表和空的元组.</p>
<p><code>()</code> 的返回的是 <code>nil</code>. 不知道这个答案有没有让你感到意外, 但是我第一次知道的时候,
感觉非常的意外.</p>
<pre><code class="language-elixir">true = is_list []
true = is_tuple {}
true = nil === ()
</code></pre>
<p>这个知识点, 实际上解释了函数调用的这个规则: 命名函数的调用, 如果要使用括号,
括号必须紧跟着函数名,其间 <strong>不能有任何空白字符</strong>. 实际上函数定义的时候也是这样.</p>
<p>其他编程语言中, 基本上没有这样的语法规则, 大家所以这样做, 不过只是编码规范.
但是在 Elixir 中, 因为允许调用命名函数的时候, 可以不使用括号,
而一个空括号 <code>()</code> 的返回值又是 <code>nil</code>.
这样 <code>fun_name ()</code> 的语义就变成了: 以空括号 <code>()</code> 表达式的结果 <code>nil</code> 为参数,
调用函数 <code>fun_name</code>.</p>
<p>所以 Elixir 中就多了这样一个关于函数调用时括号的语法.
这是一个语法, 而不是编码规范.</p>
<p>但是为什么 <code>()</code> 的返回值是 <code>nil</code> 呢? 这里 <code>()</code> 实际上是空的块表达式.
块表达式的值是块中的最后一个表达式的值, 而空块表达式 <code>()</code> 没有表达式,
Elixir 所有代码都是表达式, 因此都需要有返回值. 对于空的块表达式,
最合理的返回值只能是用来表示空的 <code>nil</code> 了.</p>
<p>其他语言中, 括号的作用只有括号在 Elixir 中的前两个功能,
所以其他语言函数调用的时候, 语法上不用做这个要求.</p>
<p>现在重新来探索上面搁置的问题: 匿名函数的调用为什么必须使用括号呢?</p>
<p>思考代码: <code>fun. (3, 4)</code> 语法正确吗? 如果正确, 那么等价于 <code>fun.(3,4)</code> 还是 <code>fun.(4)</code>?</p>
<p>如果 <code>fun</code> 是一个二元函数, 你会发现, <code>fun. (3,4)</code> 和 <code>fun.(3,4)</code> 是一样的.
也就是说, <strong>匿名函数的调用, 虽然必须使用小括号把参数括起来, 但是小括号和 <code>.</code>
之间可以有空白</strong>.</p>
<p>意外不?</p>
<p>实际上, 我们甚至可以把函数名和 <code>.</code> 之间也添加空白, 像这样: <code>fun . (3, 4)</code>.</p>
<p>我所以感到意外, 是因为自己先入为主的错误偏见: 命名函数调用时,
括号和函数名之间都不能有空白, 而 Elixir 的官方对匿名函数后面的 <code>.</code> 解释是:
本来这个点后面应该是函数名的, 但是因为这是一个无名的函数, 所以就只剩下括号了.
虽然没有说, 点和括号直接不可以有空格, 但是, 如果我们接受 Elixir 官方对 <code>.</code> 的解释,
自然的推断就是不能有空格.</p>
<p>但是从另外一个角度来看, 其实 <code>.</code> 两边可以有空白又是那么的自然, 完全不应该惊讶:
<code>.</code> 是一个二元操作符. 所有的二元操作符, 比如 <code>+</code>, <code>-</code> 和操作数之间不都可以有空白的吗?</p>
<p>这种惊讶只是思维盲区带来的. 一旦我们认识到 <code>.</code> 是一个二元操作符, 就豁然开朗了.</p>
<p>但是如果我们意识到 <code>.</code> 是一个操作符, 那么为什么调用匿名函数的时候又必须使用括号呢?
毕竟 <code>(2)</code> 的返回值就是 2 吗? 在抽象语法上表示中, <code>(2)</code> 和 <code>2</code> 也没有任何的区别.
但是实际上是有区别的, <code>(2)</code> 所以等于 <code>2</code>, 是 <code>(2)</code> 被作为块表达式,
计算后的结果等于 2. 但是如果当作参数表来处理, <code>(2)</code> 就不等于2.
我们不可以在不需要参数列表的时候, 提供参数列表的语法的.
例如单独的 <code>(1,2)</code> 就不是一个合法的表达式. 匿名函数调用, 所以必须使用括号,
是因为 <code>.</code> 操作符要求, 当其左操作数是函数的时候, 右操作数必须是参数列表.</p>
<h2 id="块表达式不是作用域"><a class="header" href="#块表达式不是作用域">块表达式不是作用域</a></h2>
<p>最后需要讨论一下块表达式和作用域的关系.</p>
<p>块表达式, 还是表达式, 它没有创建新的作用域.</p>
<p>但是 <code>do ... end</code> 的代码块, 因为是跟在作用域相关的语法结构后面, 所以,
其中的代码一般都是在新的作用域中的.
例如下面的代码:</p>
<pre><code class="language-elixir">a = 0
(
  b = 1
  IO.inspect(a, label: &quot;in block exprssion, a&quot;)
  a = b + 1
)
IO.puts(inspect(a: a, b: b))
</code></pre>
<p>在块作用表达式中, 当然可以访问外部的变量 <code>a</code> 就像第 4 行代码显示的那样.
而且, 还可以对外部作用域中定义的变量 <code>a</code> 赋新值. 而第 7 行表明,
不但变量 <code>a</code> 的值改变了, 而且块表达式中定义的变量 <code>b</code>, 在块外部也可见.</p>
<p><strong>结论</strong>: <em>块表达式并<strong>不创建</strong>新的作用域</em>.</p>
<p>不但块表达式不创建新的作用域, 使用括号表示的参数列表, 其作用域也属于外部.
例如下面的代码:</p>
<pre><code class="language-elixir">b = :math.sin(a = :math.pi() / 2)
{a, b} |&gt; IO.inspect() # {1.5707963267948966, 1.0}
</code></pre>
<p>但是宏调用不一样. 宏是特殊的函数, 它接受 ast, 返回的也是 ast.
以宏的功能的不同, 可能会向运行时中注入宏参数一样的变量,
也可能不注入, 甚至还可能注入和宏参数完全无关的变量.</p>
<pre><code class="language-elixir">(c = 1) &amp;&amp; (d = 2)
false = :d in (binding() |&gt; Keyword.keys())
false = c in (binding() |&gt; Keyword.keys())
</code></pre>
<p>上面的代码展示了, <code>&amp;&amp;</code> 宏, 并不把其接受的 ast 中的变量, 注入到运行时.</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="ch03.pattern_match.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch05.new_constructor.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="ch03.pattern_match.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="ch05.new_constructor.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>

    <!-- Livereload script (if served using the cli tool) -->
    <script type="text/javascript">
        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
        const socket = new WebSocket(wsAddress);
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload();
            }
        };

        window.onbeforeunload = function () {
            socket.close();
        }
    </script>
    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    <script type="text/javascript" src="theme/mermaid.min.js"></script>
    <script type="text/javascript" src="theme/mermaid-init.js"></script>
</body>

</html>