<!-- livebook:{"persist_outputs":true} -->

# 括号

## 本节的目的

在这里我们讨论的是 **语法上可以如何做**, 而 **不是实际编码上应该怎么做**.
可以做是一个因规则, 是面向编译器的; 应该怎么做是一个规范, 是面向程序员的.
所以很多地方, 在讨论完可以如何做后, 我又用黑体给出了社区推荐的做法.

不少地方, 讨论的可以做的方法不符合社区的推荐做法, 看起来似乎是在左右互博,
自相矛盾. 所以这样做, 是因为, 我这里是为了搞清楚所以然, 
社区给出这些规范的所以然, 也就是规范背后的原因.

当真正的理解了, 什么是可以做的, 以及什么必须做的时候, 
才能理解规范所以这样做的原因.

## 使用括号明确操作分组

这是最普通得小括号得用法. 和我们在数学课堂上使用括号的时候一样.
例如数学公式 $a(b+c)$ 对应的程序表达式就是 `a*(b+c)`.

如果要消除括号, 需要引入中间变量. 例如上面的等价的表达式, 可以写作 `tem=b+c;a*tem`. 
但是这里有一个前提, 那就是表达式是在一个块环境中的才可以做这样的拆封.

## 括号与匿名函数定义

### 使用 `fn ... -> end` 定义匿名函数

当我们使用 `fn ... -> end` 来定义匿名函数的时候, 小括号是可选的.

<!-- livebook:{"disable_formatting":true,"reevaluate_automatically":true} -->

```elixir
pi = fn -> :math.pi() end
e= fn ()-> :math.exp(1) end

pi.() |> IO.inspect(label: "pi.()")
e.()  |> IO.inspect(label: " e.()")

id = fn v -> v end
add_1 = fn ( v ) -> v + 1 end
id.(1)    |> IO.inspect(label: "   id.(1)")
add_1.(1) |> IO.inspect(label: "add_1.(1)")
add = fn a, b -> a + b end
sub = fn (a,b) -> a-b end
add.(1,2) |> IO.inspect(label: "add.(1,2)")
sub.(1,2) |> IO.inspect(label: "sub.(1,2)")
```

<!-- livebook:{"output":true} -->

```
pi.(): 3.141592653589793
 e.(): 2.718281828459045
   id.(1): 1
add_1.(1): 2
add.(1,2): 3
sub.(1,2): -1
```

<!-- livebook:{"output":true} -->

```
-1
```

上面的代码中, 对于零元匿名函数, 一元和二元匿名函数, 分别使用和不使用小括号个定义了函数.
可以看出, 在定义匿名函数的时候, 小括号完全是可选的.

**社区的推荐**: 使用 `fn ...->end` 定义匿名函数的时候, 不使用括号来包裹参数列表.

那么为什么可以这样呢?

简单来说, 这是因为从形式来看, `->` 是参数列表结束, 而函数体开始的标识.

所以不需要一个额外的括号来界定参数什么时候开始什么时候结束.

### 使用函数捕获操作符 & 定义匿名函数

当使用函数捕获操作符 `&` 定义匿名函数的时候, 牢记它的优先级最低,
然后可以根据具体的需要来在适当的地方添加括号.

使用 `&` 定义函数的表达式, `&(expression)`, 因为函数捕获操作符 `&` 的优先级最低,
而且 `expression` 不运行嵌套函数捕获表达式, 所以 `expression` 中其他的操作符都比 `&` 的优先级高, 
那么不用括号, 获得的计算顺序和使用括号是一样, 因此可以省略 &__(__ expression __)__ 中的括号.

当需要把定义的函数赋值给一个变量的时候, 匹配操作符 `=` 的优先级高于 `&` 但是因为 `=` 是右结合的,
所以优先完成的是匿名函数的定义, 所以 `a=(& expression)` 中的小括号也可以省略.

<!-- livebook:{"disable_formatting":true} -->

```elixir
id2 = & &1
add_2 = & &1 + 1
sum = & &1 + &2
sub = & &1 - &2
id2.(1) |> IO.inspect(label: "  id2.(1)")
add_2.(1) |> IO.inspect(label: "add_2.(1)")
sum.(1, 2) |> IO.inspect(label: "sum.(1,2)")
sub.(1, 2) |> IO.inspect(label: "sub.(1,2)")
```

<!-- livebook:{"output":true} -->

```
  id2.(1): 1
add_2.(1): 2
sum.(1,2): 3
sub.(1,2): -1
```

<!-- livebook:{"output":true} -->

```
-1
```

所以和 `fn -> end` 语法定义函数几乎一样, 使用 `&` 定义匿名函数的也不需要小括号,
但是这里有一点点的不同.

1. `fn` 和 `end` 是作为特殊格式存在的, 优先级高于其他的操作符.
2. 匿名函数可以作为参数传递给其他函数的  
   当把匿名函数通过 `|>` 传递给其他高级函数的时候, 
   使用函数捕获操作符 `&` 定义的匿名函数就必须使用括号了.

例如 `(& &1 + &2 + &3) |> apply([1,2,3])`.

<!-- livebook:{"disable_formatting":true} -->

```elixir
(& &1 + &2 + &3) |> apply([1, 2, 3])
```

<!-- livebook:{"output":true} -->

```
6
```

因为管道操作符 `|>` 优先级高于函数捕获操作符 `&`, 所以要表达把匿名函数整体作为 `|>` 的左参数, 
就必须加上括号.
现在我们分析一下, 表达式 `& &1 + &2 + &3 |> apply([1,2,3])` 的语义.
把这个表达式输入 iex 中, 我们得到了一个匿名的三元函数.
如果我们以参数 `1,2,3` 来调用这个匿名函数, 得到一个错误:

> ** (BadFunctionError) expected a function, got: 6.

为什么会这样呢?

1. `&` 操作优先级最低, 所以整个表达式等于 `&(&1 + &2 + &3 |> apply([1,2,3]))`.
2. `+` 高于 `|>` 所以 `&1 + &2 + &3 |> apply([1,2,3])` 等于 `(&1 + &2 + &3) |> apply([1,2,3])`.
3. 因此整个表达式的意思就是: 这个一个三元函数, 参数求和后,
   把结果作为第一个参数传递给`apply/2`.

虽然我们获得了一个三元的匿名函数, 但是这个匿名函数无论我们输入什么参数都是要报错的.

三个参数按加法计算, 所以接受的参数只能是数值类型, 而结果也只能是 **数值**,
但是 `apply/2` 要求的第一个参数是一个 **函数**, 所以无论我们以什么参数来调用这个匿名函数都抛出报错.

**结论**: 在匿名函数定义上, 不需要小括号的参数, 只有涉及到 `&` 和 `|>` 的优先级问题是,
才必须使用括号, 但是在使用函数捕获操作符 `&` 的时候, 社区的推荐使用括号.

**社区的推荐**: 使用 `&` 定义匿名函数的时候, 使用括号把**表达式括起来**, 即使很多时候语法上是不必要的.

也就是说, 按照社区的规范上面的代码中对匿名函数 `id2`, `add_2` 等函数的定义, 
应该写作:

```elxir
id2 = &(&1)
add_2 = &(&2 + 1)
sum= &(&1 + &2)
sub = &(&1 - &2)
```

## 括号与 def*

使用 `def/2` `defp/2` `defmacro/2` 和 `defmacrop/2` 在模块中定义函数, 
模块私有函数, 宏以及私有宏. 还有对应的用来定义函数或宏签名的一元宏.

查看文档可以知道这些宏接受的第一个参数叫做 `call`, 
而我们知道这些一元函数对应的功能就是定义函数或宏的签名,
所以 `call` 对应于其他语言中的函数签名(function signature)或者函数头(function head).

但是为什么不叫函数签名或函数头, 而叫 call 呢?

我认为, 这是因为这些宏接受的第一个参数, 必须是函数调用的形式.

函数调用, 有两种形式:

1. `fun_name arg1, arg2`
2. `fun_name(arg1, arg2)`

所以 `call` 参数是说这些宏接受的第一个参数也必须符合这种模式.

但是为什么要有两种形式呢? 大部分的编程语言, 实际上都支持第 2 种形式.
Elxiir 所以支持第 1 种形式有两个原因:

1. 零元函数调用, 省略括号, 看起来像常数的引用.
2. 宏忽略小括号, 可以更像其他语言的关键字

Elxiir 很多功能是宏提供的, 这就使得必须支持宏调用的时候可以省略括号,
否则语言就非常的不协调. 那么为什么不只支持第一种形式的调用呢?

`def`, `defp`, `defmacro` 和 `defmacrop` 第一个参数 `call` 我们已经学习了,
他们的第二个参数是 `expression`, 也就是表达式, 但是实际上必须是 do_block, 
其他的表达式, 都是语法错误, 比如我们就不能这样写代码 `def add(a,b), a+b`,
这实际上也就是为什么, 在定义一行代码的的函数的时候, 我们也必须有有 `:do` 的原因.

<!-- livebook:{"break_markdown":true} -->

也就说, 这几个`def*/2` 函数接受的第二个参数必须是一个 `[do: expression]`. 
但是需要注意的是, `:do` 的值只能是一个表达式, 当函数体有不只一个表达式的时候, 
就需要用代码块, 或者说块表达式.

代码块概念上来说, 就是多个语句组合到一起, 当作一个语句来说用.

Elixir 中使用更具上下文的不同, 有多种代码块的写法:

1. 以 `()` 作为代码块的分界符  
   在需要块表达式的地方, 可以以 `()` 作为块的分界符号来创建块表达式, 而表达式之间的分隔符使用换行或者 `;`.
2. 以 `->` 作为块代码分界符号  
   这在 `fn`, `for`, `case` `cond` 中有意义.
3. `do` 和 `end` 作为代码块的分界符.

所以我们可以使用 `[do: (exp1;exp2)]`也就是 do 关键字列表,来作为 `def*` 的第二个参数;
或者使用 `do-end` 语法:

```
do
  ...
end
```

<!-- livebook:{"break_markdown":true} -->

这个几个 `def*/2` 函数, 2 个参数各有两种格式, 总共就有 4 种组合.
但是这四种组合中, **不带括号的函数调用** 和 **do 关键字列表** 的组合不能完全支持.
例如下面的代码:

```elixir
defmodule FunDefine do
  def add(a, b) do
    a + b
  end

  def sub(a, b), do: a - b

  def div(a, b) do
    if is_integer(a) and is_integer(b) do
      Kernel.div(a, b)
    else
      a / b
    end
  end

  # def times a, b, do: (a * b)
  # def times a,b do: (a * b)
  def e_and_pi, do: :math.exp(1) + :math.pi()
end
```

<!-- livebook:{"output":true} -->

```
{:module, FunDefine, <<70, 79, 82, 49, 0, 0, 7, ...>>, {:e_and_pi, 0}}
```

我试图通过定义 `add`, `sub`, `div` 和 `times` 来演示函数定义的全部 4 种组合样式.
但是第 4 种样式报错, 为什么呢?
`def times a, b, do: (a * b)` 不正确的原因在于无法区分**函数参数**什么时候结束.
那么

```
def add a,b do
   a + b
end
```

是怎么知道什么时候参数列表结束的呢? 这就是 `do` 的作用了, 从这方面来说,
`do` 作为 Special Form 和 `:do` 是不完全相同的. 
否者, 编译器只是判断 `:do` 原子前面是不是有逗号的话, 那么
`def times a,b do: (a*b)` 就应该通过编译的.

现在这样的代码不能通过编译, 说明在编译的词法分析阶段, 对 `do` 是做了特殊处理.
这是 `do` 所以为特殊表单的特殊之处吧.

**推荐规范**: 定义函数或宏的时候, 零元函数除外, 推荐带有括号的函数头的格式.

## 函数调用

命名的函数调用可以省略括号, 而匿名函数调用的时候必须使用括号.

### 命名函数的省略括号调用

我认为允许命名函数可以省略括号, 这是一个语言的涉及缺陷, 是对 Ruby 语法模仿而引入的错误决定.
理由如下:

1. 这样做使得命名函数, 不在是一等公民了, 一个函数式编程的语言, 
   命名函数不是一等公民, 总是些不协调的.
2. 允许不带括号调用函数, 使得不能直接以函数名来引用函数, 而必须使用 `&` 或者 `Function.capture/3`

有允许函数调用省略括号带来的好处非常的小, 但因此使得函数引用的语法非常不经济.
在我编码的时候, 首先思考的是哪个函数可以满足需求, 无论是要调用它, 
还是要把它作为参数传递其他高阶函数. 所以首先确定是函数的名字,
然后才是思考是 *调用* 还是 *引用*.

如果是要调用这个函数, 写括号也非常的流畅, 因为这是思维的运行步骤和我的代码的书写步骤是一致的.

但是如果是需要引用这个函数, 因为`&` 放在函数名的前面,当意识到需要这个函数的引用的时候,
必须把光标重新移动到函数名的前面, 更糟心的是, 引用命名函数(准确的说是捕获),
还需要指定函数的元数, 这意味着, 还需要再次把光标从新移动到函数名的后面. 
这样的代码, `&String.length/1`, 我往往是先写出中间的 `String.lenth` 
部分然后在左右移动光标完成整个表达式. 这种体验实在是太糟糕了.

很多时候, 看到代码种写 `&String.lenth(&1)` 忍不住感觉想修改为 `&String.lenth/1`,
也许 `&String.lenth/1` 更正确和高效, 但是 `&String.length(&1)` 更加符合思维的顺序.

我的期望, 应该禁止命名函数的无括号调用语法, 而只允许宏调用可以省略括号.
这样函数名直接就是对函数的应用, 命名函数可以作为第一个类公民了, 
或者非常接近第一类公民了. 考虑到命名函数, 可能有多个同名而元数不同的函数, 
引用命名函数的时候可以使用现在这样的语法 `String.length/1`. 
函数值是不能作为除法的运算数的, 所以这样就没必须使用函数捕获操作符了.
可是这是一个大工程, 必须在 Elixir 的源码级别改动, 且如此改动, 还会引发不兼容问题.

### 为什么匿名函数必须用括号

无论匿名函数还是命名函数, 都有引用函数值和调用的区别, 无论如何都必须有这两种语法.

命名函数通过抬高引用函数的语法代价实现了可以忽略括号. 匿名函数相反, 是便利了对函数的引用, 
所以必须使用`()` 来表明是函数调用.

## 特殊表单和宏

Elixir 的特殊表单在其他语言的对应物是关键字.
Elixir 的特殊表单非常的少.

* `case`
* `for`
* `cond`
* `with`
* `do`
* `end`
* `.`
* `->`
