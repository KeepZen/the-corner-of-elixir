# 异步编程

## 承诺(Promise)

Elixir 对异步编程的支持由 `Task` 模块支持. 但是我很少使用它,
`Task` 不是一个代数结构类型[^ast], 因此无法完成链式操作.
Javascipt 中的 Promise 不一样, 它成功的解决了回调地狱问题.
因此我希望能把这个类型引入到 Elixir 语言中.

[^ast]: 代数结构类型是一个相对抽象的概念.
要理解这个概念, 首先必须理解代数结构这个数学概念.
按照我的理解, 代数结构是说, 当操作符 $f$ 作用到数据集 $S$ 上后,
得到的结果还在 $S$ 中, 这样如果把数据集合 $S$ 看作一个空间,
输出和输出在这个空间中就形成了一定的结构.
代数结构最重要的概念是闭合性, 运算的闭合性, 使得编程可以使用链式操作.
操作符在数据集上具有闭合性, 数学上讲, 操作符在数据集上形成了闭包.
编程中也有闭包的概念, 这两个概念使用的是同一个英文单词, 但是意义不一样.
举个例子, $+$ 与整数集合 $N$, 整数加上整数得到的结果还是整数,
操作的输入和输出具有封闭性. 而 $\div$ 与整数集合 $N$ 不具有封闭性,
因为整数除以整数不能保证得到的还是整数. 甚至 $\div$ 与实数集合 $R$ 也不能构成闭包,
因为 0 是不能作为被除数的. 具有运算封闭性, 在数学上就构成了类群.

我们将要定义的 Promise 模块, 对外提供的接口有 8 个函数, 其中 6 个来源于
Javascript 的 Promise API, 但是这里没有定义 `catch`.
`catch` 在 Elixiir 中是保留字, 不允许用作函数名, 因此这里用 `on_error` 来代替.

最后的 2 个函数: `of/1` 和 `map(promise,fun/1)` 是函子的通用函数.

1. `Promise` 构造函数 `Promise.new((resolve,reject)->any)`
2. `Promise` 特化的构造函数 `Promise.resolve(v)` 把 `v` 转化为已完成的
    `Promise` 结构.
3. `Promise` 特化的构造函数 `Promise.reject(v)` 把 `v` 转化为已拒绝的
    `Promise` 结构.
4. `Promise` 的转化换函数 `Promise.then(promise,fun, error_hanlder\\nil)`
5. `Promise` 错误处理函数`Promise.on_error(promise,fun)`
6. `Promise` 解构函数 `await(promise)` 返回 `Promise` 中包含的类型
7. 函子构造函数 `Promise.of({:resolved|:rejected,v})` 把任意类型的值 `v`
   转化为一个 `Promise` 结构.
8. 函子通用转化换函数 `Promise.map(promise,fun)`

```elixir
defmodule Corner.Promise do
  @type state :: :pending | :fulfilled | :rejected
  @opaque t :: %__MODULE__{state: state, result: any()}
  defstruct state: :pending, result: nil

  @spec of({state, any}) :: t
  def of({tag, v}) when tag in [:fulfilled, :resolved, :rejected] do
    tag = if tag != :rejected, do: :fulfilled, else: tag
    %__MODULE__{state: tag, result: v}
  end

  def reslove(v) do
    of({:resolved, v})
  end

  def reject(v) do
    of({:rejected, v})
  end

  def new(fun, timeout \\ :infinity)
      when is_function(fun, 2) or is_function(fun, 1) do
    ref = make_ref()
    me = self()
    {_, arity} = Function.info(fun, :arity)
    reslover = &reslover(result: &1, ref: ref, pid: me)

    args =
      if arity == 2 do
        rejecter = &rejecter(result: &1, ref: ref, pid: me)
        [reslover, rejecter]
      else
        reslover
      end

    spawn(
      __MODULE__,
      :_run,
      [fun, [with: args, fun_result: :discard, notify: me, with: ref]]
    )

    receive do
      {^ref, p} ->
        if is_struct(p, __MODULE__) do
          p
        else
          %__MODULE__{state: :rejected, result: p}
        end
    after
      timeout -> %__MODULE__{state: :rejected, result: ref}
    end
  end

  for {name, state} <- [reslover: :fulfilled, rejecter: :rejected] do
    def unquote(name)(result: result, ref: ref, pid: pid) do
      send(pid, {ref, %__MODULE__{state: unquote(state), result: result}})
    end
  end

  def then(%__MODULE__{} = p, fun, on_error \\ nil) do
    case p.state do
      :pending ->
        chain(p, [fun, on_error])

      :fulfilled ->
        chain(p, [fun, nil])

      :rejected ->
        if on_error, do: chain(p, [nil, on_error]), else: p
    end
  end

  def map(%__MODULE__{} = p, fun) do
    chain(p, [fun, fun])
  end

  def on_error(%__MODULE__{state: state} = p, fun) do
    if state == :rejected, do: chain(p, [nil, fun]), else: p
  end

  defp chain(%__MODULE__{state: state} = p, funs)
       when state in [:fulfilled, :rejected] do
    ref = make_ref()
    do_chain(p, funs, ref)
  end

  defp chain(%__MODULE__{state: :pending} = p, funs) do
    {state, v} = do_await(p, :infinity)

    p =
      if state == :ok do
        %__MODULE__{state: :fulfilled, result: v}
      else
        %__MODULE__{state: :rejected, result: {state, v}}
      end

    ref = make_ref()
    do_chain(p, funs, ref)
  end

  defp do_chain(%{state: :rejected} = p, [_, nil], _ref), do: p

  defp do_chain(%{result: v, state: state}, [fun1, fun2], ref) do
    fun =
      case state do
        :fulfilled -> fun1
        :rejected -> fun2
      end

    me = self()

    spawn(
      __MODULE__,
      :_run,
      [fun, [with: v, fun_result: :send_back, notify: me, with: ref]]
    )

    %__MODULE__{state: :pending, result: ref}
  end

  def _run(fun, with: args, fun_result: how_to_do, notify: pid, with: ref) do
    {_, arity} = Function.info(fun, :arity)

    if arity == 1 do
      fun.(args)
    else
      apply(fun, args)
    end
  rescue
    error -> send(pid, {ref, {error, __STACKTRACE__}})
  else
    v ->
      case how_to_do do
        :send_back -> send(pid, {ref, {:ok, v}})
        _discard -> :ok
      end
  end

  def await(%__MODULE__{} = p, timeout \\ :infinity) do
    {_, v} = do_await(p, timeout)

    if is_struct(v, __MODULE__) do
      v = v.result

      if is_struct(v, __MODULE__) do
        await(v, timeout)
      else
        v
      end
    else
      v
    end
  end

  defp do_await(%{state: :pending, result: ref}, timeout) do
    receive do
      {^ref, ret} -> ret
    after
      timeout -> {:timeout, ref}
    end
  end

  defp do_await(%__MODULE__{} = p, _) do
    {:ok, p}
  end
end
```

我们首先来看看 `Promise` 的 API.

### 动态构造函数 `new(fun,timeout\\:infinity)`

每个 `Promise` 对象有三个状态: 待执行(`:pending`), 已完成(`:fulfilled`),
和已拒绝(`:rejected`). 调用者不用关心, Promise 的状态,
当需要提取 Promise 中的值的时候, 调用 `await/1` 函数就好了.
`await/1` 会永久等待 Promise 对象从待执行变为已执行的状态.
`await/2` 支持等待一定时间后放弃.
超时后, `await/2` 返回的为 `ref`, 等到 Promise 执行结束后,
Promise 的创建进程, 可能依旧会收到 `{ref,value}` 消息,
通过 `await/2` 返回的 `ref` 依旧可以拿到 Promise 的结果.

`Promsie.new/1` 接受一个函数 `fun`, 返回一个 `Promise` 透明结构.
`fun` 函数规范为: `fun(reslover,rejecter)::any` 或 `fun(reslover)::any`.
其中 `reslover`, `rejecter` 都是一元函数, 返回值为 `Promise` 结构.

`fun` 的返回值会被丢弃, 但是如果 `fun` 抛出了异常, 那么 `Promise.new/1`
会返回拒绝状态的 `Promise` 对象.
在 `fun` 中调用 `reslover/1` 或 `rejecter/1`, `Promise.new` 会分别返回:
**完成** 或 **拒绝** 状态的 Promise.

**警告**:
调用 `Promise.new(fun)` 时, 如果 `fun` 函数中既没有调用 `reslover/1`,
也有没有调用 `rejecter/1`, 且没有引发异常, 那么 `new/1` 函数会陷入永久等待.
可以使用 `new/2` 来设置等待时间, 解决这个问题.
超时后, `new/2` 会返回拒绝状态的 `Promise`, 其中包含的值为一个 Reference.

<!-- livebook:{"disable_formatting":true} -->

```elixir
ExUnit.start(atom_run: false)

defmodule PromiseTest.New do
  use ExUnit.Case
  alias Corner.Promise
  test "Promise.new(fun_is_arity_one)" do
    assert 1 ==
             Promise.new(fn reslove -> reslove.(1);2 end)
             |> Promise.await()
  end

  test "Promise.new(fun_is_arity_two)" do
    assert 1 ==
             Promise.new(fn reslove, _reject -> reslove.(1) end)
             |> Promise.on_error(fn _v ->  1 = 0 end)
             |> Promise.await()

    assert :good ==
             Promise.new(fn _reslove, reject -> reject.(1) end)
             |> Promise.then(fn _ -> :bad end)
             |> Promise.on_error(fn v -> v == 1 && :good end)
             |> Promise.await()
  end

  test "Promise.new(fun) timeout" do
    assert Promise.new(fn _, _ -> :ok end, 1000)
           |> Promise.await()
           |> is_reference()
  end
end

ExUnit.run()
```

### 数据构造函数

`Promise.of({tag,v})`, `Promise.resolve(v)` 和 `Promise.reject(v)`
是三个数据构造函数, 把 `v` 置于 `Promise` 对象之中. `Promise.resolve(v)` 是
`Promise.of({:resolved, v})` 代理; `Promise.rejcet(v)` 和
`Promise.of({:rejected, v})` 一样.

这些构造函数和 `new/1` 的最大差别在于, `new/1` 可能会阻塞调用者进程, 这 3
个函数都不会阻塞调用者进程.

### 数据转化函数

`map`, `then` 和 `on_error` 是三个函数转化函数.
其中 `then/1-2` 和 `on_error` 与 Javascript 的 Promise API
的对应函数功能相同[^js_promise]. `then/1` 只处理 **已完成** 状态的 Promise,
`then/2` 接受两个转化函数,
第一个处理 **已完成** 状态的, 第二个处理 **拒绝** 状态的. `on_error/1` 只处理
**拒绝状态** 的 Promise.

[^js_promise]: 见 MDN [Promise 参考页面](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)

`map` 是为了配合 Elixir 的函数子句而提供的 API.
当运行时错误发生时, `map` 的处理函数接受到的是 `{error, stack}` 数据,
其中 `error` 是运行时异常类型, 而 `stack` 是异常的调用栈.
但是对于 `of({tag,v})` 或 `reject/1` 构造的拒绝状态, 那需要用户自己在 `v`
中添加元数据, 以表明它是哪种状态获得的值.

```elixir
alias Corner.Promise

Promise.reject({:r, 3})
|> Promise.map(&if elem(&1, 0) == :r, do: elem(&1, 1) + 1, else: raise("error"))
|> Promise.await()
|> IO.inspect(label: "expect 4, in fact get")

Promise.reslove({:f, 3})
|> Promise.map(&if elem(&1, 0) == :f, do: elem(&1, 1) + 1, else: raise("error"))
|> Promise.await()
|> IO.inspect(label: "expect 4, in fact get")

Promise.new(fn _, _ -> 1 / 0 end)
|> Promise.map(fn {err, _} when is_exception(err) -> :bad end)
|> Promise.await()
|> IO.inspect(label: "expect get a :bad, in fact get ")
```

无论使用那个转化函数, 都立刻返回新的 `Promise` 结构, 而不会阻塞调用者进程.
但是这个返回的 `Promise` 对象处于待执行状态, 所以不能从中拿到转化后的结果.

### await

要拿到转化后的结果, 使用 `await/1-2`. 即使构造函数返回的 `Promise`
对象可以使用模式匹配获取, 也不推荐使用模式匹配. 因为 `Promise` 结构应该是不透明,
其内部实现, 后续版本可能会修改的.

**警告**:
使用 `await/1` 的时候,
调用者进程也有被卡住的风险, 就像 `new/1` 那样.

例如当某个转化函数陷入循环, 没有返回结果的时候, 那么这个 Promise 将永远处于待完成状态,
这时调用 `await/1`, 将会阻塞调用者进程.

最后要注意的是, 这里全部都是函数, 没有宏, 所以**不要使用 `import` 语句**,
如果使用 import 导入全部函数, 那么会引发 `Promise.then/1` 与 `Kernel.then/1`
的命名冲突.

## 流(Stream)

Generater 是 ES6 中引入的新的语法, 让我们可以通过 `function*` 来创建产生子.
有了这个语法, 在 Javascript 中, 我们就可以产生无限数量的序列了.

Elixir 标准库中, 提供了 `Stream` 模块.
任意的在枚举过程中, 一个接一个产生数据的可枚举数据类型, 都可以叫做 `Stream`[^stream].
虽说 Stream 模块提供**组合**和**创建** `Stream` 的函数.
但是从函数的数量上来说, 这个库中提供的, 创建 `Stream` 的函数只有 3 个,
堪堪占据全部函数的十分之一左右.

[^stream]: 见 [Stream 模块文档](elixir/1.13.0/Stream.html)

对于无限序列, `Stream` 模块提供的 API 非常方便.
比如让我们产生一个斐波那契数列的 `Stream`:

```elixir
Stream.unfold({1, 1}, fn {a, b} -> {a, {b, a + b}} end)
|> Stream.take(10)
|> Enum.to_list()
```

但是, 当要求产生特定的序列时, 就开始变得怪异了. 比如, 产生斐波那契数列中,
和小于 10000 的序列.

```elixir
Stream.unfold(
  {1, 1, 0},
  fn {a, b, sum} -> if sum < 1000, do: {a, {a + b, b, sum + a}}, else: nil end
)
|> Enum.to_list()
```

这样的 API, 虽然能完成工作, 但是代码的可读性非常差, 阅读这样的代码, 往往一头雾水.

这是因为控制流由 `Stream.unfold/2` 控制的.
`Stream.unfold(acc,fun)` 通过判断 `fun` 返回结果,
来决定为流中产生什么元素或者是否结束序列.
具体的说, 当 `fun` 返回的是 `nil` 的时候, 序列结束.
当 `fun` 返回一个二元元组的时候, 元组的第一个元素作为序列的元素,
第二个元素作为继续调用 `fun` 的参数.
这就是为什么, `Stream.unfold/2` 第二个参数的类型为
`(acc() -> {element(), acc()} | nil)` 的原因.

如果要完成更加复杂的工作, 例如写一个从文件中读取内容的 `Stream`,
那么就必须使用 `Stream.source/3`. 和 `Stream.unfold/2` 类似,
`Stream.soruce/3` 根据回调函数的返回结果来决定如何产生流的元素和什么时候结束流.
但是 `Stream.source(start_fun,next_fun,end_fun)`
因为要调用 `end_fun` 完成最后的资源清理工作,
所以不能仅要求 `next_fun` 返回 `nil` 来表示流结束.
`next_fun` 的类型规范是: `(acc() -> {[element()], acc()} | {:halt, acc()})`.
当返回的结果为`{:halt,acc()}` 的时候, `Stream.source` 调用 `end_fun(acc)`,
并结束流序列. 但为什么表示需要参数元素的时候, 不能直接返回 `{elememt(), acc()}`
而必须把要产生的序列放在列表中呢? 这是因为如果返回 `{element(),acc()}` 那么,
`Stream.unflod/2` 就无法产生一个包含 `:halt` 的 Stream 序列了.

Stream 让我想起了 Javascript 的产生子. 如果 Elixir 提供了产生子,
那么产生子函数结合上面定义的 Promise 就可以写出更加容易读的 Stream.

## 产生子(Generater)

定义产生子的宏, 就叫做 `defgen` 吧.

我们使用 Javascript 产生子函数类似的语法. 在 `defgen` 上下文中, 可以使用 `yield`.
表达式 `yield a` 会等待 `next/2` 的执行. 待 `next/2` 执行后, `next/2`
会得到返回值 `{:ok, a}`; 而在产生子内部, `yield a` 的返回值是 `next/2` 的第二个参数.
产生子函数中最后一个 `yield` 语句执行完成后, 再调用 `next/2` 会返回 `:done`.

在 Javascript 中, 产生子函数返回的迭代器(记为 `g`), 第一次调用 `g.next(v)` 时,
传给 `next` 方法的值 `v` 被丢弃了. 我一直认为这时一个实现的 bug.
现在有机会来自己实现产生子, 我希望, 第一次调用 `next(g,v)` 传入的值 `v` 不会被丢弃.
在第一次调用 `next/2` 的时候, 就可以为 `next/2` 的第二参数提供任意的值.

那么该如何来实现呢? Elixir 现有的语法中, 如何组合出这样的功能呢?
首先 `receive` 会暂停一个进程的执行, 直到收到需要的数据, 才接着执行.
所以, 产生子函数, 应该运行在另外的一个进程中, 当`defgen` 返回的匿名函数被调用的时候,
产生子函数开始执行, 直到遇到第一个 `yield` 语句, 停止执行. 等待 `next/2` 函数发送信号.
当产生子进程, 收到 `next/2` 的发送的信号后, 表达式 `yield a` 完成如下工作:

1. 参数 `a` 发送给 `next`
2. 把 `next` 发送过来的数据作为 `yeild a` 的返回值传递后其他语句
3. 继续执行其他语句, 直到遇到新的 `yeild` 语句

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
sequenceDiagram
    participant  主进程
    participant  产生子进程
    主进程->> 产生子进程: 启动产生子进程 g = generater.(...)
    产生子进程-->>产生子进程: 运行, 遇到 yield 后,<br>等待主进程发送信号
    主进程->> 产生子进程: v --- next(g,v)
    产生子进程->>主进程:  {:ok,b} --- yield b
    主进程-->> 产生子进程: ...
    产生子进程-->>主进程:  ...
    主进程 -->> 主进程: 子进程还活着吗?
    主进程 ->> 主进程: 没有
```

<!-- livebook:{"break_markdown":true} -->

所以 `defgen name do...end` 产生一个匿名函数, 这个匿名函数绑定给了变量 `name`.
调用匿名函数 `name` 会启动产生子进程, 并返回一个透明结构.
这个透明结构, 对应于 Javascript 的产生子迭代器,
但是, 在我们这里, 用它来作为主进程与产生子进程通信的信道.
如果我们愿意, 还可以为这个信道/迭代器实现枚举协议,
这样就可以使用 `Enum` 模块和 `for` 来处理产生的序列了.

`defgen fun(a,b) do...end` 和 第 5章
[&Lt;定制新结构&Gt;](ch5.new_constructor.livemd)
的递归匿名函数小节中, 定义的 `fn!/2` 宏有大量的功能是相同的:

1. 它们都定义匿名函数,
2. 在宏的上下文中, 都可以完成对定义的匿名函数的递归调用.
3. 还帮助我们把这个匿名函数绑定给了变量.

这些共同的功能, 表现在代码上就成了辅助模块 `Corner.Helpers`.

```elixir
defmodule Corner.Helpers do
  def clauses_arity_check([{:->, _, [args | _]} | others]) do
    args =
      case args do
        [{:when, _, args}] ->
          {_, args} = List.pop_at(args, -1)
          args

        args ->
          args
      end

    case others do
      [] ->
        {:ok, length(args)}

      [{:->, _, [args2 | _]} | _] when length(args) == length(args2) ->
        clauses_arity_check(others)

      true ->
        :error
    end
  end

  def make_fn(name, body, make_args) do
    new_body = Enum.map(body, &transe_recurrrent_call(make_args, name, &1))
    {:fn, [], new_body}
  end

  defp transe_recurrrent_call(
         make_args,
         name = {atom, _, _},
         {:->, meta, [args | body]}
       ) do
    new_body = Macro.postwalk(body, &fixed_current_call(atom, &1))

    new_args =
      if new_body != body do
        make_args.(args, name)
      else
        name = "_#{atom}" |> String.to_atom()
        make_args.(args, {name, [], nil})
      end

    {:->, meta, [new_args | new_body]}
  end

  defp fixed_current_call(name, {{:., m1, [{name, _, _} = fun]}, m2, args}) do
    {{:., m1, [fun]}, m2, [fun | args]}
  end

  defp fixed_current_call(_, ast), do: ast
end
```

在辅助模块的帮助下, 我们就可以专心写与 `defgen` 相关的核心功能了.

````elixir
defmodule Corner.Generater do
  defstruct ref: nil, pid: nil, async: false

  alias Corner.Helpers

  defmacro defgen(name, async \\ false, do: block) do
    case Helpers.clauses_arity_check(block) do
      {:ok, arity} ->
        tem_fun = {:TEM_fun, [], nil}
        tem_fun_ast = Helpers.make_fn(name, block, &make_args/2)
        params = Macro.generate_arguments(arity, nil)

        quote do
          # unquote(async_env)
          unquote(tem_fun) = unquote(tem_fun_ast)

          unquote(name) = fn unquote_splicing(params) ->
            ref = make_ref()
            me = self()
            async = unquote(async)

            fun = fn ->
              try do
                unquote(tem_fun).(unquote(tem_fun), me, ref, unquote_splicing(params))
              rescue
                error -> send(me, {ref, {:error, error, __STACKTRACE__}})
              end
            end

            pid = spawn(fun)
            struct(unquote(__MODULE__), pid: pid, ref: ref, async: unquote(async))
          end

          unquote(tem_fun) = nil
          unquote(tem_fun) || true
        end
        |> Macro.postwalk(&yield_to_send(async, &1))

      # |> tap(&(Macro.to_string(&1) |> IO.puts()))

      :error ->
        {:=, [name, {:fn, [], block}]}
    end
  end

  def next(%__MODULE__{} = m, v \\ nil) do
    if running?(m) do
      %{pid: pid, ref: ref} = m
      send(pid, v)

      receive do
        {^ref, [v]} -> {:ok, v}
        {^ref, v} -> v
      end
    else
      :done
    end
  end

  def running?(%__MODULE__{pid: pid}) do
    pid && Process.alive?(pid)
  end

  def done?(%__MODULE__{} = m), do: !running?(m)
  @pid {:pid, [], nil}
  @ref {:ref, [], nil}
  defp make_args([{:when, meta, args}], fun) do
    [{:when, meta, [fun, @pid, @ref | args]}]
  end

  defp make_args(args, fun) do
    [fun, @pid, @ref | args]
  end

  @doc """
       Transform `c = yield a`
       """ && false
  defp yield_to_send(async, {:=, m1, [left, {:yield, _, _} = yield_exp]}) do
    receive_and_send = yield_to_send(async, yield_exp)

    {:=, m1, [left, receive_and_send]}
  end

  @doc """
       Transform `yield a` to
       ```
       receive do
         v -> send(pid,{ref,[a]})
         v
       end
       ```
       """ && false
  defp yield_to_send(async, {:yield, _meta, exp}) do
    pid = @pid
    ref = @ref

    return_value =
      if async do
        quote do
          [Promise.resolve(unquote(exp))]
        end
      else
        quote do
          unquote(exp)
        end
      end

    quote do
      receive do
        v ->
          send(unquote(pid), {unquote(ref), unquote(return_value)})
          v
      end
    end
  end

  defp yield_to_send(_, a), do: a
end
````

下面, 让我们来演示一下, 如何使用产生子.
首先, 用 `defgen` 定义产生子函数.

```elixir
import Corner.Generater

defgen fun do
  a, b when a > b ->
    c = yield(a)
    d = yield(c + b)
    yield(d)

  a, b ->
    yield(a + b)
end

:fun in (binding() |> Keyword.keys())
true = is_function(fun, 2)
```

接着, 调用这个新产生的匿名函数 `fun`, 返回一个产生子结构 `g`.
然后调用 `next(g,v)` 来迭代产生子. 当产生子函数出现错误的时候,
`next/2` 会返回 `{:error,Exception,[stakcs]}`.

```elixir
g = fun.(3, 2)
# c is 1
{:ok, 3} = g |> next(1)
# d is 4
{:ok, 3} = g |> next(4)
{:ok, 4} = g |> next(:any)
true = g |> done?()
```

现在让我们给产生子结构提供提供枚举实现.

```elixir
defimpl Enumerable, for: Corner.Generater do
  alias Corner.Generater, as: G

  def reduce(%G{}, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  def reduce(%G{} = g, {:suspend, acc}, _fun) do
    {:suspended, acc, fn _acc -> Process.exit(g.pid, :kill) end}
  end

  def reduce(%G{} = g, {:cont, acc}, fun) do
    cond do
      G.done?(g) ->
        {:done, acc}

      true ->
        alias Corner.Promise

        case G.next(g) do
          {:ok, v} ->
            new_v =
              if g.async and is_struct(v, Promise) do
                [v] = Promise.await(v)
                if is_struct(v, Promise), do: Promise.await(v), else: v
              else
                v
              end

            reduce(g, fun.(new_v, acc), fun)

          {:error, error, stack} ->
            {:done, {:error, error: error, stack: stack}}

          :done ->
            {:done, acc}
        end
    end
  end

  def count(%G{} = g) do
    reduce(g, {:cont, 0}, fn _, {:cont, c} -> {:cont, c + 1} end)
  end

  def member?(%G{} = g, n) do
    reduce(g, {:cont, false}, fn
      v, _ when n == v -> {:halt, true}
      _, acc -> acc
    end)
  end

  def slice(%G{}) do
    {:error, __MODULE__}
  end
end
```

然后, 我们就是可以使用 `Enum` 模块, 甚至 `for` 结构来处理我们的产生子结构了.

```elixir
defgen gen2 do
  () ->
    yield(1)
    yield(2)
    yield(3)
end

g = gen2.()

[1, 2, 3] =
  for v <- g do
    v
  end

true = done?(g)
```

## 异步函数(async)

Javascript 中还有异步函数的概念.
为了和 Javascript 的异步编程 API 保持一致, 定义异步函数的宏,
我命名为 `async`. 在前面, 我们已经定义 `Corner.Promise` 模块.
`async` 要做的最主要的工作就是修改抽象语法树, 把抽象语法树的返回值,
封装成 `Corner.Promise` 结构.
`async` 在其上下文中, 还为 `Corner.Promise` 命名了别名,
并导入了 `Corner.Promise.await/1-2`.
这样, 在其内部就可以方便的处理 `Promise` 结构了.

```elixir
defmodule Corner.Async do
  defmacro async({:fn, meta, ast}) do
    new_ast = arrow_return_promise(ast)

    {:fn, meta, new_ast}
    # |> tap(&(Macro.to_string(&1) |> IO.puts()))
  end

  defmacro async({atom, _meta, args}, do: body) when atom in [:def, :defp] do
    new_body = return_promise(body)

    case atom do
      :def ->
        quote do
          def(unquote_splicing(args), do: unquote(new_body))
        end

      :defp ->
        quote do
          defp(unquote_splicing(args), do: unquote(new_body))
        end
    end

    # |> tap(&(Macro.to_string(&1) |> IO.puts()))
  end

  defmacro async({:defgen, _, [fun_name]}, do: block) do
    new_block = arrow_return_promise(block)

    quote do
      import Corner.Generater
      defgen(unquote(fun_name), true, do: unquote(new_block))
    end

    # |> Macro.to_string() |> IO.puts()
  end

  defp return_promise(ast) do
    quote do
      alias Corner.Promise
      import Corner.Promise, only: [await: 2, await: 1]

      try do
        unquote(ast)
      rescue
        err ->
          Promise.reject({err, __STACKTRACE__})
      else
        v ->
          if is_struct(v, Promise) do
            v
          else
            Promise.resolve(v)
          end
      end
    end
  end

  defp arrow_return_promise(abs) do
    walker = fn
      {:->, meta, [args, body]} ->
        new_body = return_promise(body)
        {:->, meta, [args, new_body]}

      ast ->
        ast
    end

    Macro.postwalk(abs, walker)
  end
end
```

现在我们为 `fn`, `def`, `defp` 和 `defgen` 提供异步编程的支持.

```elixir
import Corner.Async

async defgen(fun) do
  a, b ->
    yield(Promise.reslove(3))
    yield(a)
    yield(b)
end

is_function(fun, 2)

for v <- fun.(1, 2) do
  v
end
```
