# 第十三章 监管者

## 监管者

监管者是一个进程, 其职责就是监管其他进程. 被监管的进程, 相对于监管者来说, 被叫做子进程.

一个监管者的子进程可能还是一个监管者, 这样, 有监管者进程形成的进程树结构, 叫做监管树.

有两种方法来启动一个监控者进程:

* 可以通过向 `Supervisor.start_link/2` 中传递子进程列表(children list), 来其中一个监管者.

* 也可以定义一个模块, 实现对应的回调函数来, 来创建监管者.

但是无论是用哪种方法来创建监管者, 都必须首先执行子进程列表.
子进程列表, 是一个元素为 map 的列表, 这个 map 叫做子进程规范,
它控制了进程的行为. 接下来我们来学习子进程规范.

## 子进程规范

监管者要对子进程完成监管, 具体来说, 就是要做如下的工作:

1. 如何启动子进程
2. 如何关闭子进程
3. 如何重启子进程

所以子进程规范包含的信息必须提供这些信息. 具体来说, 表示子进程规范的 map 的字段有如下几个:

1. `:id` 任意类型的值, 监管者内部用来区分子进程规范.
   如果这个字段发生冲突, 监管进程拒绝启动. **必填**.
2. `:start` MFA (模块, 函数, 参数) 三元组. 这个元组指定了子进程运行代码的入口点. **必填**.
3. `:restart` 指定什么时候, 重启子进程. 默认值为 `:permanent`.
4. `:shutdown` 整数或原子, 提供子进程如何关闭的信息. 默认值为 5000.
5. `:type` 子进程的类型, `:worker` 和 `:supervisor`. 默认值是 `:worker`
6. `:module` 默认从 `:start` 的 M 中获取.

除了 `:id` 和 `:start` 外, 其他字段都是可选的.

### 重启

监管者进程发现子进程意外终止后, 才会重启子进程.
而子进程是否是意外终止, 需要

那么, 进程什么样的退出原因被认为意外终止, 什么原因有被认为是正常的终止呢?

| 退出原因                       | 退出日志          | 监管者反应    | 被链接程序反应                                                            |
| ---------------------------------- | --------------------- | ------------------ | -------------------------------------------------------------------------------- |
| `:normal`                          | 不记录             | 不重启子进程 | 不会退出                                                                     |
| `:shutdown` 或 `{:shutdown,term}` | 不记录             | 不重启子进程 | 如果没有退出捕获处理 (trapping exits) 的话, 以相同的原因退出 |
| 其他原因                       | 退出原因被记录 | 重启子进程    | 如果没有退出捕获处理的话, 以相同的原因退出                   |

<!-- livebook:{"break_markdown":true} -->

当监管者进程在一定的时间内对子进程重启一定次数后, 系统依旧不能正常工作,
这说明, 在这个监管者的管理范围内, 问题不能得到解决,这时监管者就会自己退出.
这样问题就反应到监管树中更高级别的监管者.
更好级别的监管者会以它认为合适的方式重启它的子进程, 只到系统稳定,
或者完全的关闭.

<!-- livebook:{"break_markdown":true} -->

`:restart` 选项值有以下几个:

* `:permanent` 始终重启, 无论退出原因是什么
* `:temporary` 不重启, 无论退出原因是什么
* `:transient` 当子进程依赖终结的时候, 重启子进程.
