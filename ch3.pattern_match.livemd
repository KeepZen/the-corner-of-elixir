# 模式匹配

## 术语

在 Erlang 和 Elixir社区中, 常常会看到 terms 这个词.
Elixir 是从Erlang 中继承的这个概念, 在Erlang 中这个词语由明确的定义, 
任意类型的数据片段都叫做 term[^term], 在 Elixir 文档中, 
只在类型规范的章节中对这个次的含有有所暗示. `term()` 是 `any()` 的别名.

和 Erlang 一样, 在 Elixir 中也不存在用户定义类型, 只有对内建类型的组合, 而不存在用户定义类型.

在 Elixir 文档的&Lt;类型规范&Gt;的[&Lt;内建的类型&Gt;](/elixir/1.13.1/typespecs.html#built-in-types)小节中, 有很多知识可以被挖掘出来.

[^term]: 见[Erlang参考手册数据类型](https://www.erlang.org/doc/reference_manual/data_types.html#terms)相关章节.

### 1. 函数参数的限制

> arity() 定义为 0..255.

这是说, 我们的函数参数个数最多 255个吗? 要写一个 写 255 个变量, 这还真的是个体力活.
但是我们是程序员, 对于这种重复性体力工作, 当然要用编程的方式来完成了. 
Elixir 提供了 `Code.compile_string/1` 和 `Code.eval_string/1` 函数,
这可以看作是 Elixir 语言为我们提供的编译器和解释器的 API.
我们可以使用这两个函数编译或解释执行对应 Elixir 代码.

通过调整生成的函数参数的个数, 可以找到函数参数个数的上限的设定.

```elixir
defmodule Explore.Arity do
  defp generate_code(arity, name_fun?) do
    params_list =
      1..arity
      |> Enum.map(&"p#{&1}")

    params_src = Enum.join(params_list, ",")
    body_src = Enum.join(params_list, " + ")

    if name_fun? do
      """
      defmodule A do
        def test(#{params_src}) do
          #{body_src}
        end
      end
      """
    else
      "fn #{params_src} -> #{body_src} end"
    end
  end

  @default_opt [fun_named?: false, compiled?: true]
  def check(arity, opt \\ []) do
    opt = Keyword.merge(@default_opt, opt)

    src = generate_code(arity, opt[:fun_named?])

    if opt[:compiled?] do
      Code.compile_string(src)
    else
      Code.eval_string(src)
    end
  rescue
    v ->
      error_tip = if opt[:compiled?], do: "compile error", else: "praser error"
      IO.inspect(v, label: error_tip)
      :bad
  else
    v ->
      IO.inspect(v, label: "check done")
      :ok
  end
end
```

```elixir
ExUnit.start(auto_run: false)

defmodule ArityTest do
  use ExUnit.Case, async: true
  alias Explore.Arity

  test "the uplimit of arity for anonymous function in complier " do
    assert Arity.check(255) == :ok
    assert Arity.check(256) == :bad
    IO.puts("")
  end

  test "the uplimie of arity for named function in complier " do
    assert Arity.check(255, fun_named?: true) == :ok
    assert 1..255 |> Enum.sum() == apply(A, :test, Enum.to_list(1..255))

    assert Arity.check(256, fun_named?: true) == :ok
    assert_raise UndefinedFunctionError, fn -> apply(A, :test, Enum.to_list(1..256)) end
    IO.puts("")
  end

  test "the uplimit of arity for anonymous function in parser" do
    assert Arity.check(20, compiled?: false) == :ok
    assert Arity.check(21, compiled?: false) == :bad
    IO.puts("")
  end

  # test "the uplimit of arity for named function in parser" do
  #   assert Arity.check(20,fun_named?: true, compiled?: false) == :ok
  #   assert  apply(A,:test, 1..20|> Enum.to_list()) == 1..20 |> Enum.sum()

  #   assert Arity.check(21,fun_named?: true, compiled?: false) == :ok
  #   assert_raise UndefinedFunctionError, fn -> A.test(Enum.to_list(1..21)) end
  #   IO.puts("")
  # end
end

ExUnit.run()
```

通过上面的实验, 可以得出以下结论:

* 在编译器中
  1. 对于匿名函数, 参数个数多于 255 个, 编译器报 UndefineFuntionError
  2. 对于命名函数, 参数个数多于 255 个, 编译器并不报错, 但是调用这个函数,
     运行时会产生 UndefineFuntionError
* 在解析器中
  1. 对于匿名函数, 参数个数多于 20 个, 解释器就会报 UndefinedFunctionError
  2. 对于命名函数, 参数个数多于 20 个, 解释器不会报错, 但是调用这个函数,
     运行时会产生 UndefineFunctionError

<!-- livebook:{"break_markdown":true} -->

### 模块

> module() 定义为 atom()

所以模块名, 本质上只是原子.

Elixir 代码是运行在 Erlang 虚拟机上的, 而 Erlang 中, 模块名就是原子.
Elixir 要像于 Erlang 代码实现相互调用, Elixir 也只能使用原子来做模块名.

但是这里有一个重要的概念, 模块和模块的名字不是一个东西. Elixir 中只有模块的名字,
而没有解释什么是模块.

模块不是 Elixir 的一个数据类型, 甚至也不是不是 Erlang 的数据类型. 模块是

Elixir 中有一种特殊的原子, 以 `Elixir.` 作为前缀的原子.
如果这种原子后面的内容以大写字母打头, 例如 `:"Elixir.Balabla"`, 那么就可以直接写做: `Balabla`.

实际上, erlang 中函数名也是原子. 但是函数

### 3. struct() 定义为 %

这说明结构真的就是一个 map.

回顾以下, 结构体是如何定义的.

## 列表

假设我们有列表 `list=[1,2,3,4,5]`.

1. 当我们需要提出列表前 3 个元素的时候  
   `[a,b,c|_] = list`.

2. 当我们需要去掉第一个元素后的剩余元素的时候  
   `[_|rest] = list`.

3. 申明并以列表元素初始化变量  
   我们需要声明多个变量, 这些变量的初始化值有 list 提供. 
   我们的变量个数和 list 的元素个数不一定匹配, 这个时候, 
   最方便的是使用 `destructure/2`.

   * 变量个数小于或等于 list 的长度  
     `destructure([a,b,c,d,e],list)` , `a` 的值为 1, `e` 的值为 5.
   * 变量个数大于 list 长度  
     `destructure([a,b,c,d,e,f],list)`, `e` 的值为 5, `f` 的值为 `nil`.

4. 从后匹配列表的 n 个元素  
   `[a,b,c] = [1,2,3,4] |> Enum.take(-3)`

## 键字列表

```elixir
kw = [hello: "hello", hi: "hi"]
```

单独的使用匹配来获取一个关键字列表的值得内容, 不太灵活.
例如, 对于`kw=[hello: "hello", hi: "hi"]`来说,
如果我们想要获取 `:hi` 键对应得值, 必须使用 `[_|{:hi, hi}] = kw`.
这样的语法, 相对来说比较琐屑, 不如直接使用 `hi= kw[:hi]` 直观快捷.

在处理关键字的时候, 我多次写这样的错误代码: `[hello: hello|_] = kw`
正确的写法应该是 `[{:hello, hello}|_] = kw`.
那么为什么 `|` 的实现不允许那样做呢?

元素为原子的二元元组, 如果不是连续出现,且一直延续到列表的结束的话,
是不能使用关键字语法糖的.

例如 `[0,{:first, 1},2]` 是不能写成 `[0, first: 1, 2]`的.
而 `a|b` 本质上是一个向 b 的头部加一个元素的操作.

对于 `[hello: v | rest]` 假如我们把他解释为:
向 `rest` 头部添加 `{:hello, v}`, 那么这个操作暗含了, 
操作后的结果是一个关键字列表; 否则就不应该允许出现关键字的语法糖.

可问题是, `|` 的操作是一个运行时的动作, 无法保证结果一定是关键字. 
所以 `|` 的左操作数不能是关键字的语法糖.

对关键字来说, 使用 `Acesss` 协议, 或者 `Keyword.get/2`
读取关键字的值更方便.

如果关键字的值有其他的嵌套结果, 可以使用 `get_in/2` 来获取嵌套值.

```elixir
keyword = [hello: "hello", person: [name: "Bob", age: 23]]
# 使用 Acess 协议获取
keyword[:hello]
|> IO.inspect(label: "hello")

get_in(keyword, [:person, :age])
|> IO.inspect(label: "person.age")
```

最后, `atom: value` 这样的语法糖, 不但在列表中可以使用, 而且可以在元组, map 或结构定义的时候使用.
相对来说, 在 map 和结构的定义中使用关键字的语法糖比较常见, 而在元组中也是可以使用的.
例如:

```elixir
{1, a: 1, b: 2}
%{1 => :one, one: 1, two: 2}
```

## 字符串

Elixir 中有两个操作符和字符串相关, 字符串链接操作符 `<>` 和 二进制操作符 `<<...>>`.
如果我们检查 Elixir 内置的谓词, 会发现, 缺少了 `is_string`, 但是有对应的 `is_binary`.
字符串是特殊的 binary. 这也就是为什么 `<<...>>` 加 二进制操作符的原因.

当我们知道字符串的前缀的时候, 可以是用 `<>` 完成匹配.
例如:

<!-- livebook:{"force_markdown":true} -->

```elixir
"Hello, " <> name = "Hello, Mr. Green"
```

有时候, 我们不知道或不关心数据前缀的确切值, 但是关心或知道前缀的长度,
那么, 这样的功能可以通过位串操作符(bitstring operator) `<<...>>` 来完成匹配.

<!-- livebook:{"force_markdown":true} -->

```elixir
<<_::binary-7, name::binary>> = "Hello, Mr. Green"
```

使用 `<<>>` 匹配的时候, 必须位变量指定单位和尺寸,
例如这里的`_` 的单位是 `binary`, 而单位是 7.
也就是说忽略 7 个字节. 最后的变量只指定了单位, 而没有指定长度, 
这样他可以匹配操剩余的所有的长度.

注意, 这里的单位都不能省略, 因为 `<<>>` 默认的单位是 `integer` 而不是 `binary`.

可惜的是, 单位 `utf*` 不支持尺寸, 所以只能匹配对应编码的一个字符. 
所以对于中文来说, 如果我们要完成忽略某几个字符这样的匹配, 
只能这样写:
`<<_::utf8, _::utf8,_::utf8,_::utf8, name:binary>> = "你好, 王先生"`
可惜我们无法通过库代码的形式来改善这个情况, 因为 `<<args>>` 是一个特殊形式.

但是实际上, 对于多字节的字符, 其实还有一种选择, 那就是字符列表.
例如:
`[_,_,_,_|name] = '你好, 王先生'`
但是需要注意, 如果字符列表表示的字符串都是 ASCII 字符, 
字符列表才以字符列表字面量的形式呈现; 否则就按照整数列表的形式打印.
所以如果我们要显示 `name` 绑定的中文内容, 还需要把它转化为字符串.
`name = to_string(name)`.
所以, 为了代码的简洁, 其实可以这样来写:

```
name = '你好, 王先生' |> Enum.drop(4) |> to_string()
```

## 结构

结构是特殊的 map. 我们可以通过 `is_map/1` 来确定这点. 所以我们可以使用 map 
的匹配语法来匹配结构.

```elixir
defmodule M do
  defstruct name: nil
end

a = %M{}
a.__struct__
is_map(a)
```
