# 模式匹配

## 模式匹配的作用

模式匹配完成以下的两个工作:

1. 确认数据具有某种模式
2. 以某种模式, 从数据中提出信息

在其他语言中, 这两个功能有着清晰的分界, 但是在 Elixir 中, 有清晰分界的情况是少数的,
大部分是两个功能混合在一起的.

## 模式确认

Elixir 特意提供了一个专门完成模式检查工作的宏 `match?/2`. 这个宏返回的是一个布尔值.

```elixir
true = match?({:ok, b}, {:ok, 1})
nil = binding()[:b]
false = match?({:ok, _}, :error)
```

上面的代码, 第 1 行表面, 当 `match?` 第一个参数作为模式, 可以匹配第二个值得时候, 返回值是 `true`.
第 2 行, 我们通过检查 `binding()`,确认了, 即使匹配成功, 这个宏并不在环境中引入新的变量.
第 3 行, 我们展示了, 当 `match?` 得两个参数匹配失败的时候, 返回 `false` 而不是引发一个异常.

和 `match?/2` 完成的工作非常相识, 但是只专注于字符串匹配得, 还有操作符 `=~`. `=~` 返回的也是布尔值.

```elixir
true = "hello" =~ "hello"
true = "hello" =~ ~r/hel.{2}/
```

`match?/2` 和匹配操作符 `=` 一样, 第一个参数作为模式, 第二个参数作为需要匹配的数值.
`=~` 的第二个参数是模式: 字符串或者正则表达式; 第一个参数是要匹配的字符串.
这不是一个特别大的差别.

其实我更希望, 能够使用操作符来完成更多的模式确认的工作.

下面, 让我们试着自定义自己的 `=~` 操作符.

```elixir
defmodule Corner.Operater do
  import Kernel, except: [=~: 2]

  defmacro __using__(_opt) do
    quote do
      import Kernel, except: [=~: 2]
      import Corner.Operater
    end
  end

  defmacro left =~ right do
    if is_binary(left) do
      quote do
        Kernel.=~(unquote(left), unquote(right))
      end
    else
      quote do
        match?(unquote(left), unquote(right))
      end
    end
  end
end
```

```elixir
ExUnit.start(auto_run: false)

defmodule OperaterTest do
  use ExUnit.Case
  use Corner.Operater

  test "pattern =~ expection" do
    c = "hello" =~ "hello"
    assert c
    c = "hello" =~ ~r/hell./
    assert c
    c = [_a, _b] =~ {1, 2}
    refute c
  end
end

ExUnit.run()
```

注意这里的测试代码, 必须首先把宏调用的结果存放到变量(这里是 `c`)里, 然后使用宏 `assert c` 来判断.
而不能直接使用 `assert pattern =~ expection`, 这应该是 `assert/1` 的一个 bug.

## 按模式提取信息

和 `match?/2` 以及 `~=` 相反, Elixir 中也通过了专注数据提取的函数:

1. destructure/2 针对列表
2. get_in/2 针对Access 协议的数据提取

这些函数的用法, 在 Elixir 的文档中有详细的说明, 而且我也不觉得, 
自己可以解释的更好了, 如果我说他们使用来提取数据的,
你(读者)不明白我说的是什么意思, 那么建议大家读一读 Elixir
[destructure](https://hexdocs.pm/elixir/Kernel.html#destructure/2) 和
[get_in](https://hexdocs.pm/elixir/Kernel.html#get_in/2) 的文档.

我喜欢 `descructure` 这个函数, 它让我怀念 JS 的结构操作符 `...`.
可惜 `descruture/2` 这个函数只支持对列表的解构.
那么我们来定义自己的解构操作符吧.

```elixir
defmodule Corner.Desructure do
  defmacro left <~ right do
    ast =
      cond do
        match?({:%{}, _, _}, left) ->
          destructure_map(left, right)

        is_ast_tuple(left) ->
          destructure_tuple(left, right)

        is_list(left) ->
          quote do: Kernel.destructure(unquote(left), unquote(right))

        true ->
          quote do: unquote(left) = unquote(right)
      end

    ast
    |> Macro.to_string()
    |> then(&IO.puts("L22: #{&1}"))

    ast
  end

  defp is_ast_tuple({:{}, _, _}), do: true
  defp is_ast_tuple({_, _}), do: 2
  defp is_ast_tuple(_), do: false

  defp destructure_map(left, right) do
    default_val = make_default(left)

    quote do
      unquote(left) = Map.merge(unquote(default_val), unquote(right))
    end
  end

  defp make_default(ast) do
    ast
    |> Macro.postwalk(&varable_to_nil/1)
  end

  defp varable_to_nil({atom, _, tag}) when is_atom(atom) and tag in [Elixir, nil], do: nil
  defp varable_to_nil(v), do: v

  defp destructure_tuple(left, right) do
    left_size = ast_tuple_size(left)

    quote do
      right = unquote(right)
      diff = unquote(left_size) - tuple_size(right)

      patch_right =
        cond do
          0 == diff ->
            right

          # left < right
          diff < 0 ->
            Tuple.drop(right, diff)

          # left > right
          true ->
            fun = fn
              f, tuple, 0 -> tuple
              f, tuple, n -> f.(f, Tuple.append(tuple, nil), n - 1)
            end

            fun.(fun, right, diff)
        end

      unquote(left) = patch_right
    end
  end

  defp ast_tuple_size(tuple_ast) do
    case is_ast_tuple(tuple_ast) do
      2 -> 2
      true -> length(elem(tuple_ast, 2))
      false -> raise "require a tuple, this is not a tuple."
    end
  end
end
```

让我们测试一下:

```elixir
ExUnit.start(auto_run: false)

defmodule DesructureTest do
  use ExUnit.Case, async: true
  import Corner.Desructure

  test "desturcture from map literal" do
    %{a: a, b: b} <~ %{a: 1, b: 2}
    assert a == 1
    assert b == 2
    %{a: a} <~ %{}
    assert a == nil
  end

  test "desturcture from map value" do
    map = %{a: 1, b: 2}
    %{a: a, b: b} <~ map
    assert a == 1
    assert b == 2
    map = %{}
    %{a: a} <~ map
    assert a == nil
  end

  test "desturcture nest from map not work very well" do
    map = %{a: %{b: 1}, c: 1}
    %{a: %{b: b}, c: c, d: d} <~ map
    assert b == 1
    assert c == 1
    assert d == nil

    assert_raise MatchError, fn -> %{a: %{c: c}} <~ map end
  end

  test "desturcture from tuple literal" do
    {a, b} <~ {1, 2}
    assert a == 1 and b == 2
    {a} <~ {}
    assert a == nil
  end

  test "desturcture from tuple value" do
    tuple = {1, 2}
    {a, b} <~ tuple
    assert a == 1 and b == 2
    tuple = {}
    {a} <~ tuple
    assert a == nil
    {a, b} <~ tuple
    assert a == nil and b == nil
    {a, b, c} <~ tuple
    assert a == nil and b == nil and c == nil
  end

  test "desturcture nest from tuple not work very well" do
    tuple = {1, c: 1}
    {a, [c: c], d} <~ tuple
    assert a == 1 and c == 1 and d == nil
    assert_raise MatchError, fn -> {a, [c: c, d: d]} <~ tuple end
  end

  test "destructure list as Kernel.desturcture" do
    [a, b] <~ [1]
    assert a == 1 and b == nil
  end

  test "<~ work as `=` for varable" do
    a <~ {}
    assert a == {}
  end
end

ExUnit.run()
```

我们定义的新的操作符 `<~` 可以完美的结果, 列表, 元组 和 Map 的单层解构, 
但是对于嵌套结构的支持还知识停留在了, 模式匹配操作符 `=` 的基础上, 就像 `destructer/2` 一样.

## 模式匹配与条件匹配操作符

首先, 我们来看 Elixir 中最常用的匹配操作符 `=`. 它的工作逻辑如下:

最常见的情形下, 按照 `=` 左侧的模式, 从右边的数据中提取信息.
但是当左边变量前中出现  pin 操作符 `^` 的时候, `=` 只完成模式确认模式确认的工作:
默认匹配成功了, 返回模式匹配操作符 `=` 右侧表达式的值; 而如果模式匹配失败了抛出异常.

在 Erlang OTP 25 中引入了一个新特性 maybe, 其中可以使用新的短路操作符 `?=`[^maybe],
叫做条件匹配操作符. 也许不久 Elixir 也会引入.
这个操作符实际上就是 `match?/2` 和模式匹配操作符 `=` 的混合体; 当模式匹配成功的时候, 
完成变量值得绑定, 模式匹配失败, 返回 `?=` 左边的值.

[^maybe]: 见 [&Lt;Erlang 参考手册&bullet;maybe &Gt;章节](https://www.erlang.org/doc/reference_manual/expressions.html#maybe)

很显然, 无论是模式匹配还是条件模式匹配, 都是模式匹配检查和模式匹配数据提供这两个工作的混合结果.
这种情况, 在控制结构中更加的明显. 根据控制结构对匹配结果处理逻辑和方式的不同, 我把 Elixir 的控制结构分成以下几类:

1. 处理逻辑类似 `=` 的控制结构
2. 处理逻辑类似与 `?=` 的控制结果
3. 错误处理中的模式匹配

## 控制结构中的模式匹配

1. 类似于 `=` 的结构

   * 函数分句
   * `case`
   * Elixir 的 `cond`, Erlang 的 `if`

   这些控制结果的大体的工作逻辑是这样的: 首先对模式做匹配, 如果不匹配, 接着匹配下一个模式,
   如果所有的模式都不匹配, 类似于模式匹配操作符 `=` 匹配失败那样, 抛出一个错误; 
   而一旦匹配成功了, 还要完成数据提取的工作, 并执行对应的代码段.

2. 类似于 `?=` 的控制结构

   * Elixir 的 `with`
   * Erlang 中的 `maybe`

   他们使用模式匹配是又是另外一个逻辑: 当模式匹配错误的时候, 返回匹配的数据; 匹配正确的时候, 
   按照模式提取数据, 然后执行对应的代码.

3. 异常处理中的模式匹配  
   异常处理时, `catch` 处理的是函数调用参数列表. 或者按照 Erlang 的术语叫做 TList.
   而且即使如此, 对 `:throw` 类型的错误, 还有语法糖加持.

   而 `rescue` 子句中, 模式匹配时只匹配异常名字. 而且对于运行时错误, 
   还可以使用 `ErlangError` 来统配的.

   也就是说, 他们都不是常规的模式匹配.

```elixir
ExUnit.start(auto_run: false)

defmodule MatchTest do
  use ExUnit.Case

  test "ErlangEroor is not same as OtherError" do
    refute ErlangError == FunctionClauseError
  end

  test "catch think throw match two diff pattern" do
    catch_a_value =
      try do
        throw(1)
      catch
        v -> v
      end

    catch_a_tuple =
      try do
        throw(1)
      catch
        :throw, v -> v
      end

    assert catch_a_value == catch_a_tuple
  end

  test "resuce think EralngError match all RuntimeError" do
    a =
      try do
        1 / 0
      rescue
        ArithmeticError -> :ok
        _ -> :try_do_not_know1
      end

    b =
      try do
        1 / 0
      rescue
        ErlangError -> :ok
        _ -> :try_do_not_know2
      end

    assert a == b
  end
end

ExUnit.run()
```
