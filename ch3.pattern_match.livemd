<!-- livebook:{"persist_outputs":true} -->

# 模式匹配

## 列表

假设我们有列表 `list=[1,2,3,4,5]`.

1. 当我们需要提出列表前 3 个元素的时候  
   `[a,b,c|_] = list`.

2. 当我们需要去掉第一个元素后的剩余元素的时候  
   `[_|rest] = list`.

3. 申明并以列表元素初始化变量  
   我们需要声明多个变量, 这些变量的初始化值有 list 提供. 
   我们的变量个数和 list 的元素个数不一定匹配, 这个时候, 
   最方便的是使用 `destructure/2`.

   * 变量个数小于或等于 list 的长度  
     `destructure([a,b,c,d,e],list)` , `a` 的值为 1, `e` 的值为 5.
   * 变量个数大于 list 长度  
     `destructure([a,b,c,d,e,f],list)`, `e` 的值为 5, `f` 的值为 `nil`.

4. 从后匹配列表的 n 个元素  
   `[a,b,c] = [1,2,3,4] |> Enum.take(-3)`

## 键字列表

```elixir
kw = [hello: "hello", hi: "hi"]
```

<!-- livebook:{"output":true} -->

```
[hello: "hello", hi: "hi"]
```

单独的使用匹配来获取一个关键字列表的值得内容, 不太灵活.
例如, 对于`kw=[hello: "hello", hi: "hi"]`来说,
如果我们想要获取 `:hi` 键对应得值, 必须使用 `[_|{:hi, hi}] = kw`.
这样的语法, 相对来说比较琐屑, 不如直接使用 `hi= kw[:hi]` 直观快捷.

在处理关键字的时候, 我多次写这样的错误代码: `[hello: hello|_] = kw`
正确的写法应该是 `[{:hello, hello}|_] = kw`.
那么为什么 `|` 的实现不允许那样做呢?

元素为原子的二元元组, 如果不是连续出现一直延续到列表的结束的话,
是不能使用关键字语法糖的.
例如 `[0,{:first, 1},2]` 是不能写成 `[0, first: 1, 2]`的.
而 `a|b` 本质上是一个向 b 的头部加一个元素的操作.

对于 `[hello: v | rest]` 假如我们把他解释为:
向 `rest` 头部添加 `{:hello, v}`, 那么这个操作暗含了, 
操作后的结果是一个关键字列表; 否则就不应该允许出现关键字的语法糖.

可问题是, `|` 的操作是一个运行时的动作, 无法保证结果一定是关键字. 
所以 `|` 的左操作数不能是关键字的语法糖.

对关键字来说, 使用 `Acesss` 协议, 或者 `Keyword.get/2`
读取关键字的值更方便.

如果关键字的值有其他的嵌套结果, 可以使用 `get_in/2` 来获取嵌套值.

```elixir
keyword = [hello: "hello", person: [name: "Bob", age: 23]]
# 使用 Acess 协议获取
keyword[:hello]
|> IO.inspect(label: "hello")

get_in(keyword, [:person, :age])
|> IO.inspect(label: "person.age")
```

<!-- livebook:{"output":true} -->

```
hello: "hello"
person.age: 23
```

<!-- livebook:{"output":true} -->

```
23
```

最后, `atom: value` 这样的语法糖, 不但在列表中可以使用, 而且可以在元组, map 或结构定义的时候使用.
相对来说, 在 map 和结构的定义中使用关键字的语法糖比较常见, 而在 元组中也是可以使用的.
例如:

```elixir
{1, a: 1, b: 2}
%{1 => :one, one: 1, two: 2}
```

<!-- livebook:{"output":true} -->

```
%{1 => :one, :one => 1, :two => 2}
```

## 字符串

Elixir 中有两个操作符和字符串相关, 字符串链接操作符 `<>` 和 二进制操作符 `<<...>>`.
如果我们检查 Elixir 内置的谓词, 会发现, 缺少了 `is_string`, 但是有对应的 `is_binary`.
字符串是特殊的 binary. 这也就是为什么 `<<...>>` 加 二进制操作符的原因.

当我们知道字符串的前缀的时候, 可以是用 `<>` 完成匹配.
例如:

<!-- livebook:{"force_markdown":true} -->

```elixir
"Hello, " <> name = "Hello, Mr. Green"
```

有时候, 我们不知道或不关心数据前缀的确切值, 但是关心或知道前缀的长度,
那么, 这样的功能可以通过位串操作符(bitstring operator) `<<...>>` 来完成匹配.

<!-- livebook:{"force_markdown":true} -->

```elixir
<<_::binary-7, name::binary>> = "Hello, Mr. Green"
```

使用 `<<>>` 匹配的时候, 必须位变量指定单位和尺寸,
例如这里的`_` 的单位是 `binary`, 而单位是 7.
也就是说忽略 7 个字节. 最后的变量只指定了单位, 而没有指定长度, 
这样他可以匹配操剩余的所有的长度.

注意, 这里的单位都不能省略, 因为 `<<>>` 默认的单位是 `integer` 而不是 `binary`.

可惜的是, 单位 `utf*` 不支持尺寸, 所以只能匹配对应编码的一个字符. 
所以对于中文来说, 如果我们要完成忽略某几个字符这样的匹配, 
只能这样写:
`<<_::utf8, _::utf8,_::utf8,_::utf8, name:binary>> = "你好, 王先生"`
可惜我们无法通过库代码的形式来改善这个情况, 因为 `<<args>>` 是一个特殊形式.

但是实际上, 对于多字节的字符, 其实还有一种选择, 那就是字符列表.
例如:
`[_,_,_,_|name] = '你好, 王先生'`
但是需要注意, 如果字符列表表示的字符串都是 ASCII 字符, 
字符列表才以字符列表字面量的形式呈现; 否则就按照整数列表的形式打印.
所以如果我们要显示 `name` 绑定的中文内容, 还需要把它转化为字符串.
`name = to_string(name)`.
所以, 为了代码的简洁, 其实可以这样来写:

```
name = '你好, 王先生' |> Enum.drop(4) |> to_string()
```

## 结构

结构是特殊的 map. 我们可以通过 `is_map/1` 来确定这点. 所以我们可以使用 map 
的匹配语法来匹配结构.

```elixir
defmodule M do
  defstruct name: nil
end

a = %M{}
a.__struct__
is_map(a)
```

<!-- livebook:{"output":true} -->

```
true
```
