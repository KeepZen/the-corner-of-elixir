# 错误处理

## 错误分类

Erlang 中把错误分成 4 类.

1. 编译时错误, 也就是语法错误
2. 逻辑错误
3. 运行时错误, 运行时产生的错误
4. 产生的错误, 也就是写代码中特意产生的错误.

前两种错误, 是在发生在语言之外的, 所以在代码层面没法对其做处理.

后两种错误又叫做异常. 所以代码层面, 能处理的其实都是异常.

异常以引发异常的机制和函数不同, 又可以分成三类:

1. 错误(error), 运行时的错误, 例如 `1 + :a` 或者有 `:erlang.error()` 引发的.
2. 退出(exit), 由 `:erlang.exit/1/2/3` 引发, 用来使进程退出执行
3. 抛出(throw), 由 `:erlang.throw` 引发.

Erlang 中用 `catch` 处理这些错误.
而 Elixir 中, 除了 `catch` 外, 还引入了 Ruby 中的 `rescue`.
那么自然的就由一个问题, `catch` 和 `rescue` 如何分工呢?

按照 [Elixir 文档](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1)的说法,
`rescue` 用来处理异常, 而 `catch` 可以用来捕获 `throw` 值和 `exit` 信号.
(The `rescue` clause is used to handle exceptions while the `catch` clause can
be used to catch thrown values and exits.)

但是什么是异常呢? Elixir文档中并没有明确的给出定义,
但是 [Erlang 文档](https://www.erlang.org/doc/reference_manual/errors.html#exceptions)
中有清晰的解释.

如果 Elixir 中的异常和 Erlang 中的是一个概念话,
那么我对 `rescue` 和 `catch` 的分工的理解,
就成了: `rescue` 能处理所有三种类型的异常, 而 `catch` 只能处理 `throw` 和 `exit`.
但是这样的理解是错误的.

例如下面的代码,`rescue` 在这里并没有把我们从 `throw` 引发的错误中拯救出来.

```elixir
try do
  throw(1)
rescue
  v -> IO.inspect(v)
end
```

使用 Erlang 对异常的分类, `rescue` 实际上只能处理错误 `error`.
Elixir 文档中也的确有提到 `rescue` 对 Erlang 的错误的处理,
所有的 Erlang 错误都被转化为 `ErlangError`.
这可以看作是一种暗示: Elixir 中异常对应于 Erlang 的错误.

理解了这一点, 对于 `catch` 的分工描述中的 **可以** 就有了不同的理解.
在 Erlang 中, `catch` 就可以用来捕获这三种类型的错误的,
Elixir 中还是一样, 只是因为 `rescue` 对于其中的一部分工作处理的更优雅, 
所以在 Elixir 中大部分情况下, 用它来处理 `throw` 和 `exit` 引发的错误,
但是 `catch` 并没有退化.

所以我原来的理解正好搞反了, `catch` 是全能处理者, 而 `rescue` 才是挑剔者.

## 怎么拯救

上一节我们讨论了, Elixir 中的 `rescue` 的使用场景, 
现在我们来讨论如何使用它.

比如定义一个条件匹配的宏,来模拟 Erlang 的 maybe 特性.

```elixir
defmodule Corner.Maybe do
  defmacro maybe(do: block) do
    quote do
      try do
        unquote(block)
      rescue
        e in [MatchError] -> e.term
        # %MatchError{term: term} -> term
        e -> reraise e, __STACKTRACE__
      end
    end
  end
end
```

不难推测, 还可以在第 7 行的列表中加入更多的错误类型.
如果只是不管异常的名字叫什么, 都要处理的话, 就可以向第 9 行那样处理.

但是像第 7 行中对对错误的处理, 如果需要提取异常的消息内容,
那么我忍不住要使用注释掉的第 8 行那样的代码.
但是第 8 行的代码是语法错误的. `rescue` 子句中 `->` 左侧的模式匹配,
只基于异常的名字来处理[^rescue].

这样的处理有些奇怪啊! 如果允许第 8 行那样写代码, 代码不是显的更整洁吗?
为什么 Elixir 这样处理这个问题? 现在还没有答案, 
但是不要这一个问题阻拦了我们探索的脚步. 也许后面的探索中, 答案自然就会浮出水面呢!

[^rescue]: Elixir 文档中的话, 翻译过来是: 除了以来模式匹配外, 
`rescue` 围绕异常提供了一些方便, 允许我们根据异常的名字来展开救援. 
原文见 Elixir 文档关于
[rescue 子句的描述](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1-rescue-clauses).

## 如何捕获

在我们讨论 `rescue` 和 `catch` 的分工时, 我们知道 `catch` 是三项全能.
现在让我们来看看 `catch` 的表现.

### 抛接游戏

Elixir 中 `throw` 可以抛出任意的数据类型, 就像 C++ 中那样,
而 `catch` 可以原封不动的接住所有被抛出的东西.
Elixir 中没有 `return` 语句, 使用 `throw` `catch` 可以模拟它.
例如像这样的 Js 代码:

```javascript
function fun(a){
  if(a > 3) return "a > 3"
  if(a < 0) return "a > 0"
  if(a == 2) return a
  return a+1
}
```

对应的Elixir 代码可以这样来写:

<!-- livebook:{"force_markdown":true} -->

```elixir
def fun(a) do
  if a > 3 ,do: throw "a > 3"
  if a < 0 ,do: throw "a < 0"
  if a == 2, do: throw a
  catch 
    v -> v
  else
   _ -> a + 1
end
```

### 信号捕获

但是在 Erlang 中, `catch` 实际上更加类似于 Linux 进程间通信机制中的信号.
也就是说, `catch` 的实际上是信号, Elixir 信号比 Linux 的信号通信高级的地方在于
Linux 的信号种类是固定的; 而 Elixir 中 `exit` 可以发送的信号, 
是由类型与加附带消息共同组成的. 信号的类型个数是固定的, 但是信号携带的信息数量上是无限多的.

`catch` 子句中完整的匹配语法是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
catch
  kind, message when guard -> ...
```

也就是说, `catch` 子句中 `->` 左边得是一个二元参数列表形式.
当然了, guard 子句可以省略. 而 `catch v -> ...` 不过 Elixir 为我们提供的代码
`catch :throw, v -> ...` 的语法糖.

我们用代码来探索一下, 看我们的理解是否正确:

```elixir
1 =
  try do
    throw(1)
  catch
    :throw, v -> v
  end

2.0 =
  try do
    throw(2.0)
  catch
    v -> v
  end
```

对 `throw` 产生的错误来说, `catch v ->..` 和 `catch :throw, v -> ...` 一样. 
这证实了我们的说法: `catch v -> ...` 只是 `catch :throw, v -> ...` 的语法糖.

```elixir
2 =
  try do
    exit(2)
  catch
    :exit, v -> v
  end
```

对 `exit` 引发的错误, 可以使用 `catch :exit, v ->` 捕获.

```elixir
3 =
  try do
    :erlang.error(3)
  catch
    :error, v -> v
  end

:reason =
  try do
    :erlang.error(:reason, [2])
  catch
    :error, v -> v
  end
```

Erlang 的 `:erlang.error/1/2/3`, `catch` 总是能捕获其异常的原因,
也就是 `:erlang.error` 的第一个参数.

```elixir
:badarith =
  try do
    1 / 0
  catch
    :error, v -> v
  end

{:badmatch, :error} =
  try do
    :ok = :error
  catch
    # not work
    # :error, %MatchError{}=v -> v 
    # now v is not a Error, but a tuple
    :error, v -> v
  end
```

使用 `catch :error, v -> v` 捕获运行时错误, v 绑定运行时发送的信息,
不同的错误运行时发送的信息也不同.
比如算术计算引发的错误是一个原子 `:badarith` 表示算术运算错误类型.
而匹配错误, 返回的是一个二元元组, 元组的第一个元素是原子 `:badmatch` 代表错误类型,
第二个元素是匹配操作符 `=` 的右操作数.

```elixir
:reason =
  try do
    exit(:reason)
  catch
    :exit, v -> v
  end

{:kill, 1} =
  try do
    exit({:kill, 1})
  catch
    :exit, v -> v
  end
```

无论传递给 `exit/1` 的是什么, `catch :exit, v ->` `v` 都能获取绑定的值.

```elixir
%MatchError{} =
  try do
    raise MatchError
  catch
    :error, %MatchError{} = v -> v
  end

%MatchError{} =
  try do
    raise MatchError, term: {:ok, 1}
  rescue
    v in MatchError -> v
  end
```

`catch` 和 `rescue` 都可以用来处理 `raise` 引发的错误. 
在 `catch` 的语法可以让我更方便的使用匹配语法. 而 `rescue` 只能匹配变量名.

但是, 注意对比运行时产生的匹配错误, 和我们使用 `raise` 产生的匹配错误.

运行时参数的匹配错误, 使用 `catch :error, v -> ..`, `v` 绑定的是一个二元元组.
而 `rasie` 产生的错误 `catch :error, v ->...` `v` 绑定的是 %MatchError{} 异常结构.

## 更优雅的拯救

在探索 `catch` 对异常的捕获是, 我们发现 `catch` 对运行时错误和 `raise` 产生的错误有区分,
这使得 `catch` 对由不同的机制产生的相同异常, 必须使用不一致的语法来处理. 
我想真是这种不一致, 所以 Elixir 中才引入 `rescue` 的吧.
运行时错误和产生的错误统称为异常. Elixir 中更多的使用 `rescue` 来处理异常.

可是 `rescue` 子句中的匹配的语法, 只支持对异常名匹配. 
这样在需要提取异常消息的时候, 代码就不够简洁了.

但是变量可以匹配任意给定的值, 这个匹配规则没有打破.
所以 `rescue v ->` 可以用来匹配任意的类型的异常.

当变量 `v` 绑定异常结构后, 在 `->` 的右侧, 就可以使用结构的匹配语法来对异常做匹配了.
也就是说, 对于异常, 我们可以使用下面的代码来完成匹配:

<!-- livebook:{"force_markdown":true} -->

```elixir
try do
   do_block_code
rescue v -> 
    case v do
     %ErrorName{field: field_v} -> field_v
     ...
    end
...
end
```

我们就可以定义自己的语法糖, 来让 `rescue` 语法可以使用更强大的模式匹配语法.

`try` 是 Elixir 特殊表单, 大家对他的语法有一致的预期, 
为了让不熟悉我们的库的程序员不至于感到迷惑, 不是使用 `try` 来作为我们的宏的名字.
这个要定义的宏是要增强 `rescue` 的匹配功能, 所以可以把这个宏命名为 `super_try`.
就像动漫中, 超级英雄拯救世界一样, `super_try` 用来拯救我的代码洁癖症.

```elixir
defmodule Corner.SuperTry do
  defmacro super_try(do: block, rescue: rescue_ast) do
    quote do
      try do
        unquote(block)
      rescue
        v ->
          case v do
            unquote(rescue_ast)
          end
      end
    end
  end
end
```

最后使用我们新定义的 `super_try` 来重构我们的 `maybe` 宏.

```elixir
defmodule Corner.Maybe do
  defmacro maybe(do: block) do
    quote do
      import Corner.SuperTry, only: [super_try: 1]

      super_try do
        unquote(block)
      rescue
        %MatchError{term: term} -> term
      end
    end
  end
end
```

测试一下:

```elixir
ExUnit.start(autorun: false)

defmodule Corner.MaybeTest do
  use ExUnit.Case
  import Corner.Maybe

  test "maybe" do
    result_maybe =
      maybe do
        {:ok, a} = {:ok, 2}
        {:ok, b} = {:error, a + 1}
        b + 1
      end

    assert result_maybe == {:error, 3}
  end
end

ExUnit.run()
```

## 错误处理子句的顺序

最后, 讨论一下 `try` 结构中子句的顺序. 在 Elixir 文档中, 最完整的错误处理块为
`try`...`rescue`...`catch`...`else`...`after`.
在 Elixir 文档中, 我们看到过省略部分子句的情况,
但是这些子句的相对顺序还是保持的, 那么能不能改变这些子句的相对顺序呢?
比如, 把 `rescue` 放在 `catch` 后.

```elixir
try do
  raise :error
catch
  v -> v |> IO.inspect(label: "catch v")
rescue
  v -> v |> IO.inspect(label: "rescue")
else
  v -> v |> IO.inspect(label: "else")
after
  IO.puts("after")
end
```

注意, 这里编译器给出的警告, 警告的内容是 `catch` 应该放在 `resuce` 的后面,
不过代码依旧可以运行. 但是为什么应该那样呢? 前面的讨论, 我们知道 `catch` 是全能捕手,
我们上面的代码中, 用到的是它捕获 `throw value` 的语法, 
所以`rescue` 有机会捕获 `raise` 产生的错误. 但是如果使用的最通用 `catch` 的语法呢?
比如:

<!-- livebook:{"force_markdown":true} -->

```elixir
catch 
:error, v -> ...
rescue 
  rescue_code
```

在上面的代码中, `rescue` 子句就是死代码, 永远不用有机会执行.
这就是为什么, 编译器给出警告的原因.

那么除了 `rescue` 和 `catch` 的相对位置外, 其他的子句呢? 能改变顺序码?
比如, 我们把 `after` 子句放在 `resuce` 前面, 可以吗?

```elixir
try do
  1 / 0
after
  IO.puts("after")
rescue
  v ->
    v |> IO.inspect(label: "rescue")
    :rescue
catch
  v ->
    v |> IO.inspect(label: "catch")
    :catch
else
  v -> v |> IO.inspect(label: "else")
end
```

这次不但顺利通过编译, 而且警告都没有. 也就是说, 这是完全合法的代码.
`after` 在代码中出现的顺序, 不影响其功能. 进一步的, 不难推测, 
`else` 也可以放在 `resuce` 子句前.

```elixir
try do
  2
rescue
  v -> IO.inspect(v, label: "resuce v")
else
  v -> v |> IO.inspect(label: "else")
catch
  :error, v ->
    IO.inspect(v, label: "catch :error ,v")
end
```

最后提醒读者, 我们这里是对语法规则的探索, 才故意打乱其顺序的, 但是绝对不是鼓励大家在实际的编码中也这样做.

## 什么时候必须 try

在 Elixir 的官方文档中, 我们看到可以省略 `try` 关键字, 而直接处理错误的例子.
例如在命名函数中:

<!-- livebook:{"force_markdown":true} -->

```elixir
def fun() do
   ...
catch
  :error, v -> v
after 
  ...
end
```

那么什么时候, 可以省略 `try` 呢? 是不是所有后面需要 `do-block` 的语法结构中, 
都可以使用省略 `try` 而直接使用错误处理子句呢? 不是的, 实际上, 只有在函数定义中才可以如此使用.

例如, 我们就不可以给 `if` 语句加一个 `catch` 子句. 例如像下面的代码就是错误的.

```elixir
if 3 < 4 do
  1 -> 1 / 0
catch
  :error, _ -> "1/0"
else
  "how it can be 3 not less than 4"
end
```

我们看到命名函数中, 可以直接使用错误处理的子句, 那么是不是在匿名函数中也可以直接使用呢?
答案也是否定的, 而且 Elixir &Lt;语法参考&Gt;文档的
[&Lt;保留字&Gt;](https://hexdocs.pm/elixir/syntax-reference.html#reserved-words)小结也给出了提示:

> `do`, `end`, `catch`, `rescue`, `after`, `else` - 在 do-end 块中使用.

`fn` 的语法是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
fn a -> ... end
```

当这里的 `...` 多余一个表达式的时候, 这里实际上是一个暗含的块, 但是并不是一个 `do-block`.
这一点我们可以通过 `quote` 语句, 在 AST 层面上看清.

```elixir
quote do
  fn a ->
    a + 1
    a - 1
  end

  def f(a) do
    a + 1
    a - 1
  end
end
```

`fn` 的块结构在 AST 层面的表示是:

<!-- livebook:{"force_markdown":true} -->

```elixir
{:__block__, [],
  [
    {:+, [context: Elixir, import: Kernel], [{:a, [], Elixir}, 1]},
    {:-, [context: Elixir, import: Kernel], [{:a, [], Elixir}, 1]}
  ]}
```

而函数 f(a) 定义的块结果的 AST 表示是:

<!-- livebook:{"force_markdown":true} -->

```elixir
[do: {:__block__, [],
  [
    {:+, [context: Elixir, import: Kernel], [{:a, [], Elixir}, 1]},
    {:-, [context: Elixir, import: Kernel], [{:a, [], Elixir}, 1]}
  ]}]
```

<!-- livebook:{"break_markdown":true} -->

知道了这些知识, 就不难理解为什么 `fn` 定义匿名函数的时候, `try` 不能省略了.

**结论**: 只有在 `def` 和 `defp` 中可以省略 `try`, 其他情形下对 `try` 的省略, 
都是对这个特定规则的天真推广.
