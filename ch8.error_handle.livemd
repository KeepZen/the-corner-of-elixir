# 错误处理

## 错误分类

Erlang 中把错误分成 4 类.

1. 编译时错误, 也就是语法错误
2. 逻辑错误
3. 运行时错误, 运行时产生的错误
4. 产生的错误, 也就是写代码中特意产生的错误.

前两种错误, 是在发生在语言之外的, 所以在代码层面没法对其做处理.

后两种错误又叫做异常. 所以代码层面, 能处理的其实都是异常.

异常以引发异常的机制和函数不同, 又可以分成三类:

1. 错误(error), 运行时的错误, 例如 `1 + :a` 或者有 `:erlang.error()` 引发的.
2. 退出(exit), 由 `:erlang.exit/1/2/3` 引发, 用来使进程退出执行
3. 抛出(throw), 由 `:erlang.throw` 引发.

Erlang 中用 `catch` 处理这些错误.
而 Elixir 中, 除了 `catch` 外, 还引入了 Ruby 中的 `rescue`.
那么自然的就由一个问题, `catch` 和 `rescue` 如何分工呢?

按照 [Elixir 文档](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1)来说, `rescue` 用来处理异常, 而 `catch` 可以用来捕获 `throw` 值和 `exit` 信号.
(The `rescue` clause is used to handle exceptions while the `catch` clause can
be used to catch thrown values and exits.)

但是什么是异常呢? Elixir文档中并没有明确的给出定义,
但是 [Erlang 文档](https://www.erlang.org/doc/reference_manual/errors.html#exceptions)
中有清晰的解释.

如果 Elixir 中的异常和 Erlang 中的是一个概念话, 那么我对 `rescue` 和 `catch` 的分工的理解,
就成了, `rescue` 能处理所有三种类型的异常, 而 `catch` 只能处理 `throw` 和 `exit`.
但是这样的理解是错误的. 例如下面的代码,`rescue` 在这里并没有把我们从 `throw` 引发的错误中拯救出来.

```elixir
try do
  throw(1)
rescue
  v -> IO.inspect(v)
end
```

使用 Erlang 对异常的分类, `rescue` 实际上只能处理错误 `error`.
Elixir 文档中也的确有提到 `rescue` 对 Erlang 的错误的处理,
所有的 Erlang 错误都被转化为 `ErlangError`.
这可以看作是一种暗示: Elixir 中异常对应于 Erlang 的错误.

理解了这一点, 对于 `catch` 的分工描述中的 **可以** 就有了不同的理解.
在 Erlang 中, `catch` 就可以用来捕获这三种类型的错误的,
Elixir 中还是一样, 只是因为 `rescue` 对于其中的一部分工作处理的更优雅, 
所以在 Elixir 中大部分情况下, 用它来处理 `throw` 和 `exit` 引发的错误,
但是 `catch` 并没有退化.

所以我原来的理解正好搞反了, `catch` 是全能处理者, 而 `rescue` 才是挑剔者.

## 怎么拯救

上一节我们讨论了, Elixir 中的 `rescue` 的使用场景, 
现在我们来讨论如何使用它.

比如定义一个条件匹配的宏,来模拟 Erlang 的 maybe 特性.

```elixir
defmodule Corner.Maybe do
  defmacro maybe(do: block) do
    quote do
      try do
        unquote(block)
      rescue
        e in [MatchError] -> e.term
        # %MatchError{term: term} -> term
        e -> reraise e, __STACKTRACE__
      end
    end
  end
end
```

不难推测, 还可以在第 7 行的列表中加入更多的错误类型.
如果只是不管异常的名字叫什么, 都要处理的话, 就可以向第 9 行那样处理.

但是像第 7 行中对对错误的处理, 如果需要提取异常的消息内容,
那么我忍不住要使用注释掉的第 8 行那样的代码.
但是第 8 行的代码是语法错误的. `rescue` 子句中 `->` 左侧的模式匹配,
只基于异常的名字来处理[^rescue].

这样的处理有些奇怪啊! 如果允许第 8 行那样写代码, 代码不是显的更整洁吗?
为什么 Elixir 这样处理这个问题? 现在还没有答案, 
但是不要这一个问题阻拦了我们探索的脚步. 也许后面的探索中, 答案自然就会浮出水面呢!

[^rescue]: Elixir 文档中的话, 翻译过来是: 除了以来模式匹配外, `rescue` 围绕异常提供了一些方便, 允许我们根据异常的名字来展开救援. 原文见 Elixir 文档关于[rescue 子句的描述](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1-rescue-clauses).

## 如何捕获

在我们讨论 `rescue` 和 `catch` 的分工时, 我们知道 `catch` 是三项全能.
现在让我们来看看 `catch` 的表现.

### 抛接游戏

Elixir 中 `throw` 可以抛出任意的数据类型, 就像 C++ 中那样,
而 `catch` 可以原封不动的接住所有被抛出的东西.
Elixir 中没有 `return` 语句, 使用 `throw` `catch` 可以模拟它.
例如像这样的 Js 代码:

```javascript
function fun(a){
  if(a > 3) return "a > 3"
  if(a < 0) return "a > 0"
  if(a == 2) return a
  return a+1
}
```

对应的Elixir 代码可以这样来写:

<!-- livebook:{"force_markdown":true} -->

```elixir
def fun(a) do
  if a > 3 ,do: throw "a > 3"
  if a < 0 ,do: throw "a < 0"
  if a == 2, do: throw a
  catch 
    v -> v
  else
   _ -> a + 1
end
```

### 信号捕获

但是在 Erlang 中, `catch` 实际上更加类似于 Linux 进程间通信机制中的信号.
也就是说, `catch` 的实际上是信号, Elixir 信号比 Linux 的信号通信高级的地方在于
Linux 的信号种类是固定的; 而 Elixir 中 `exit` 可以发送的信号, 
是由类型与加附带消息共同组成的. 信号的类型个数是固定的, 但是信号携带的信息数量上是无限多的.

`catch` 子句中完整的匹配语法是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
catch
  kind, message when guard -> ...
```

也就是说, `catch` 子句中 `->` 左边得是一个二元参数列表形式.
当然了, guard 子句可以省略. 而 `catch v -> ...` 不过 Elixir 为我们提供的代码
`catch :throw, v -> ...` 的语法糖.

我们用代码来探索一下, 看我们的理解是否正确:

```elixir
1 =
  try do
    throw(1)
  catch
    :throw, v -> v
  end

2.0 =
  try do
    throw(2.0)
  catch
    v -> v
  end
```

对 `throw` 产生的错误来说, `catch v ->..` 和 `catch :throw, v -> ...` 一样. 
这证实了我们的说法: `catch v -> ...` 只是 catch :throw, v -> ...` 的语法糖.

```elixir
2 =
  try do
    exit(2)
  catch
    :exit, v -> v
  end
```

对 `exit` 引发的错误, 可以使用 `catch :exit, v ->` 捕获.

```elixir
3 =
  try do
    :erlang.error(3)
  catch
    :error, v -> v
  end

:reason =
  try do
    :erlang.error(:reason, [2])
  catch
    :error, v -> v
  end
```

Erlang 的 `:erlang.error/1/2/3`, `catch` 总是能捕获其异常的原因,
也就是 `:erlang.error` 的第一个参数.

```elixir
:badarith =
  try do
    1 / 0
  catch
    :error, v -> v
  end

{:badmatch, :error} =
  try do
    :ok = :error
  catch
    # not work
    # :error, %MatchError{}=v -> v 
    # now v is not a Error, but a tuple
    :error, v -> v
  end
```

使用 `catch :error, v -> v` 捕获运行时错误, v 绑定运行时发送的信息,
不同的错误运行时发送的信息也不同.
比如算术计算引发的错误是一个原子 `:badarith` 表示算术运算错误类型.
而匹配错误, 返回的是一个二元元组, 元组的第一个元素是原子 `:badmatch` 代表错误类型,
第二个元素是匹配操作符 `=` 的右操作数.

```elixir
:reason =
  try do
    exit(:reason)
  catch
    :exit, v -> v
  end

{:kill, 1} =
  try do
    exit({:kill, 1})
  catch
    :exit, v -> v
  end
```

无论传递给 `exit/1` 的是什么, `catch :exit, v ->` `v` 都能获取绑定的值.

```elixir
%MatchError{} =
  try do
    raise MatchError
  catch
    :error, %MatchError{} = v -> v
  end

%MatchError{} =
  try do
    raise MatchError, term: {:ok, 1}
  rescue
    v in MatchError -> v
  end
```

`catch` 和 `rescue` 都可以用来处理 `raise` 引发的错误. 
在 `catch` 的语法可以让我更方便的使用匹配语法. 而 `rescue` 只能匹配变量名.

但是, 注意对比运行时产生的匹配错误, 和我们使用 `raise` 产生的匹配错误.

运行时参数的匹配错误, 使用 `catch :error, v -> ..`, `v` 绑定的是一个二元元组.
而 `rasie` 产生的错误 `catch :error, v ->...` `v` 绑定的是 %MatchError{} 异常结构.

## 更优雅的拯救

在探索 `catch` 对异常的捕获是, 我们发现 `catch` 对运行时错误和 `raise` 产生的错误有区分,
这使得 `catch` 对由不同的机制产生的相同异常, 必须使用不一致的语法来处理. 
我想真是这种不一致, 所以 Elixir 中才引入 `rescue` 的吧.
运行时错误和产生的错误统称为异常. Elixir 中更多的使用 `rescue` 来处理异常.

可是 `rescue` 子句中的匹配的语法, 只支持对异常名匹配. 
这样在需要提取异常消息的时候, 代码就不够简洁了.

但是变量可以匹配任意给定的值, 这个匹配规则没有打破.
所以 `rescue v ->` 可以用来匹配任意的类型的异常.

当变量 `v` 绑定异常结构后, 在 `->` 的右侧, 就可以使用结构的匹配语法来对异常做匹配了.
也就是说, 对于异常, 我们可以使用下面的代码来完成匹配:

<!-- livebook:{"force_markdown":true} -->

```elixir
try do
   do_block_code
rescue v -> 
    case v do
     %ErrorName{file: v} -> v
     ...
    end
...
end
```

我们就可以定义自己的语法糖, 来让 `rescue` 的语法更加的统一.
`try` 是 Elixir 的保留字, 所以我们不能使用 `try` 来定义我们的宏, 那么我们定义为 `try_` 吧.

```elixir
defmodule Corner.Try do
  defmacro try_(do: block, rescue: rescue_ast) do
    quote do
      try do
        unquote(block)
      rescue
        v ->
          case v do
            unquote(rescue_ast)
          end
      end
    end
  end
end
```

最后使用我们新定义的 `try_` 宏来重构我们的 `maybe` 宏.

```elixir
defmodule Corner.Maybe do
  defmacro maybe(do: block) do
    quote do
      import Corner.Try

      try_ do
        unquote(block)
      rescue
        %MatchError{term: term} -> term
      end
    end
  end
end
```

测试以下:

```elixir
ExUnit.start(autorun: false)
defmodule Corner.MaybeTest do
  use ExUnit.Case
  import Corner.Maybe
  test "maybe" do
    result_maybe =  maybe do
      {:ok, a} = {:ok,2}
      {:ok, b} m= {:error, a + 1}
      b + 1
    end
    assert result_maybe == {:error, 3}
  end
end
ExUnit.run()
```

最后, 讨论以下 `try` 接受的参数. 在 Elixir 文档中, 最完整的错误处理块为
`try`...`rescue`...`catch`...`else`...`after`.
在 Elixir 文档中, 我们看到过, 省略部分子句的情况,
但是这些子句的相对顺序错乱的情况, 没有见过, 
那么能不能改变这些子句的相对顺序呢?
比如, 把 `rescue` 放在 `catch` 后.

```elixir
try do
  raise :error
catch
  v -> v |> IO.inspect(label: "catch")
rescue
  v -> v |> IO.inspect(label: "rescue")
else
  v -> v |> IO.inspect(label: "else")
after
  IO.puts("after")
end
```

编译器给出的警告, 但是代码依旧可以运行. 甚至, 我们把 `after` 和 `else` 的相对位置调换,
也依然可以通过编译, 而且代码执行的顺序和正常顺序是一样.

```elixir
try do
  1
catch
  v -> v |> IO.inspect(label: "catch")
rescue
  v -> v |> IO.inspect(label: "rescue")
after
  IO.puts("after")
else
  v -> v |> IO.inspect(label: "else")
end
```

我原本预期 `try` 接受的是一个关键字列表, 所以子句间的关系必须相对固定, 现在发现不是啊.
`try` 的确检查关键字列表, 以及其中的键必须只能是 `:do`, `:resuce`, `:catch`, `:else`, `:after`.
但是不要求这些键位置固定.

最后提醒读者, 我们这里是说语法规则的探索, 才故意打乱其顺序的, 但是绝对不是鼓励大家在实际的编码中也这样做.
