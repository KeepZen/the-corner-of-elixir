# 定制新结构

## 定义自己的控制控制结构

Elixir 是一个特别灵活的语言, 这样说, 不但是说, Elixir 本身提供的语法结构非常灵活, 
更加重要的是, 如果我们不满意 Elixir 提供的控制结构, 那么可以按照自己的意图,
来定义自己的控制结构.

## 赋值与思维流

确切的说, `=` 叫做匹配操作符, 而不是赋值表达式. 
但是变量可以匹配任意的值, 所以实际上, elixir 中还是用 `=` 来做赋值的操作.

在其他编程语言中, 赋值是一个非常简单的操作, 因为赋值语句非常简短,
基本上一眼就能看清楚赋值的结果是什么.

其他语言中, 块语句不是表达式, 但是在 elixir 中语句块也是表达式. 
当赋值语句的右侧出现的是语句块的时候, 代码序列往往和我的思维序列不协调.

首先让我来描述一下, 我阅读这样代码时的思维过程.
因为是一个块语句, 也就是说右多个步骤, 多个操作才能完成最后的结果,
阅读代码的时候, 思维自然要跟随代码, 以理解代码的意图. 
当多个步骤执行完成后, 在我的思维中, 往往忘记了 `=` 的左边的表达式
是什么了, 因为最后结果和变量之间的距离太远了, 这个距离既是物理上的, 
也是心理上的.

而写一个块语句的时候, 在完成整个功能之前, 实际上我也不知道最后的结果会是什么,
甚至不知道, 这个块语句就是函数最后的结果, 还是只是计算的中间过程.
所以基本上, 我也是先完成快语句然后再决定是否需要把结果赋值给一个变量的.
当我意识到需要把块语句的结果赋值给一个变量的时候, 
这时候光标往往是停留在块语句的尾部的, 要完成赋值语法, 只好移动光标, 
这让我有些烦恼.

我更希望写出的代码能和思维流一致, 这样写代码的时候流畅, 阅读的时候也更轻松.

## 设计赋值语句

Elixir 支持宏编程, 这就给我们提供了设计自己的赋值语句提供了可能.
但是 `=` 是一个特殊形式, 所以不能从新定义它, 而只能利用 `=` 
提供的功能, 来重新设计新的语法糖.

首先让我来描述清楚, 我想要的语法是什么样的.

<!-- livebook:{"force_markdown":true} -->

```elixir
if exprestion do
  :zero
else
  :is_not_zero
end
|> assign(to: v)
```

这样简单的, 可以使用 Elixir 提供的语法直接转化成为一行的代码:
 `v = if exprestion, do: :zero, else: :is_not_zero`.
这个时候使用 `assign/2` 是没有必要的. 但是当 `if` 语句不能转化成一行的代码时候,
或者当需要把 `case` 或 `cond` 结果赋值为一个变量的时候, 
代码序列和思维流之间的阻抗就更加的明显了.

假设我们要控制一个机器人, 机器人使用一个 GenServer 表示, 它的状态是 `%{x: x, y: y, diriction: direction}` 表示机器人所在的位置 `x, y` 和面对的方向
(`:E`, 东方; `:W`, 西方;`:N`, 北方; `:S`, 南方).
当机器人接受到转弯的指令后, 就会按照指令转弯, 从而改变自己的状态.
那么处理右转的代码就是这样:

<!-- livebook:{"force_markdown":true} -->

```elixir
def handler_cast({:trun, :right}, %{direct: direct}=state) do
   direct = case direct do
     :N -> :E
     :E -> :S
     :S -> :W
     :W -> :N
   end

   {:noreply, %{state| direct: dircet}}
end
```

那么在 `assign/2` 的帮助下, 可以把上面的代码重构为:

<!-- livebook:{"force_markdown":true} -->

```elixir
def handler_cast({:trun, :right}, %{direct: direct}=state) do
   case direct do
     :N -> :E
     :E -> :S
     :S -> :W
     :W -> :N
   end
   |> assign(to: direct)

   {:noreply, %{state| direct: dircet}}
end
```

看起来不错吧, 现在让我们来看看, 如何来实现 `assgin/2`.

## 赋值实现

我们需要把 `assgin/2` 定义为一个宏, 这个宏的功能非常的简单, 只是 `=` 的语法糖嘛, 所以可以这样来实现.

```elixir
defmodule Demo do
  defmodule Helpers do
    defmacro assign(value, to: var) do
      quote do
        unquote(var) = unquote(value)
      end
    end
  end
end
```

这个实现, 完成了我们期望的工作.

这里 `assign/2` 并不改变直接使用 `=` 的语义代码的语义.
调用 `assign(value, to: var)`, 
当 var 和 value 不匹配的时候, 依旧会抛出匹配错误,

因为 `assign(value, to: var)` 本质上就是 `var = value`,
所以任意可以作为 `=` 左值的语法都可以作为 `assign` 的 `:to` 的值,
虽然, 我们把这个参数命名为 `var`, 单并不限于变量.
毕竟 `assign/2` 仅仅是语法糖.

这样的语法糖, 让代码更简洁, 美观, 如此而已.

`assgin/2` 现在帮助我们减少了代码的序列和思维流之间的阻抗, 
但是像上面对 `hanlder_cast/2` 的重构那样, 
最后的返回语句不能使用 `|>` 链接起来, 这样的代码序列, 
反映到思维流上, 就是思维流的打断.

如果 `assign/2` 能帮助我们把思维流也接续起来, 那么写 elixir 
代码就更加愉悦了.

能让思维流保持连续的代码, 我认为是这样的:

<!-- livebook:{"force_markdown":true} -->

```elixir
def handler_cast({:trun, :right}, %{direct: direct}=state) do
   case direct do
     :N -> :E
     :E -> :S
     :S -> :W
     :W -> :N
   end
   |> assign(to: direct, do: %{state| direct: direct})
end
```

再假设有现在我们有三个函数, 分别是 `step1/0` `step2/1` 和 `step3`.
`step1` 的结果作为 `step2` 的输入, `step2` 返回 `{:ok,v}|{:error, String.t}`.
`step3` 输入为 `v`.
那么无论是

```elxiir
{:ok, v} = step1()
|> step2()

step3(v)
```

还是:

<!-- livebook:{"force_markdown":true} -->

```elixir
step1()
|> step2()
|> assign(to: {:ok, v})

step3(v)
```

阅读的时候, 思维流都是被打断的.
但如果 `assign/2` 允许我们写下面的代码, 就能让思维流保持连续.

<!-- livebook:{"force_markdown":true} -->

```elixir
step1()
|> step2()
|> assign(to: {:ok, v}, do: v)
|> step3()
```

也就是说, 需要把 `assign(value, to: var)` 变成 `assign(value, to: var, do: expression)`.

这个实现也非常的容易, 当我们完成 `var = value` 的赋值后, 再计算 `expression` 的值可以了.

```elixir
defmodule Demo do
  defmodule Helpers do
    defmacro assign(value, to: var, do: expression) do
      quote do
        unquote(var) = unquote(value)
        unquote(expression)
      end
    end
  end

  defp step1(), do: 1
  defp step2(v), do: {:ok, v + 1}
  defp step3(v), do: IO.inspect(v, label: "in step3 v")
  import Helpers

  def do_work() do
    step1()
    |> step2()
    |> IO.inspect(label: "after setp2")
    |> assign(to: {:ok, v}, do: v)
    |> IO.inspect(label: "after assign/2")
    |> step3()
  end
end

Demo.do_work()
```

在 `assign/2` 的帮助下, 我们写的 Elixir 代码, 几乎也可以叫做到 free-point 了.

## with 结构

如果要选**最不喜欢的语言结构**, Elixir 的 `with` 是我的答案.

我所以不喜欢这个语句结构, 首先是像 `with` 语句中的 `<-` 暗示的那样, 
其中的代码序列和思维流之间存在阻抗. 其次, `with` 结构的代码布局非常的不美观.

例如代码:

<!-- livebook:{"force_markdown":true} -->

```elixir
with {:ok, a} <- fun1(), # with 头部开始
     {:ok, b} <- fun2(a) # with 头部结束 
do # with 体开始
     action_with_a_and_b #with 体结束
else #尾部开始
   patter1 -> hanlder_error1
   patter2 -> hanlder_error2 # 尾部结束
end
```

这个 `with` 结构, 像代码中注释的那样, 可以分成 3 部分, 分别是**头**, **体**和**尾**.
通常情况下, `with` 代码就像上面的片段展示的这样, `with` 头往往有多个语句,
而 `with` 体却只有一行或很少的几行代码. 像这样的头部或者参数部分, 多于体或者正文的语法结构,
除了 `with` 语句外大概没有别的了. 这样的布局, 给我的感觉就是头重脚轻, 极度不协调.
看到这样的代码, 不由自主地, 我的脑海中总是浮现出有染色体缺陷的畸形儿的形象.

所以我非常的不喜欢这个语法结构.

如果不使用 `with` 语句, 等价的代码应该如何写呢? 我认为可以写成这样:

<!-- livebook:{"force_markdown":true} -->

```elixir
try do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
rescue
  %MatchError{term: term}-> 
    case term do
      pattern1 -> handler_error1
      pattern2 -> handler_error2
    end  
end
```

对于没有 `else` 的 `with` 更加简单:

<!-- livebook:{"force_markdown":true} -->

```elixir
try do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
rescue
  %MatchError{term: term} -> term  
end
```

而如果语句已经在一个块结构中了, 代码还可以进一步的精简:

<!-- livebook:{"force_markdown":true} -->

```elixir
def fun do
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  atction_with_a_and_b
rescue
  %MatchError{term: term} -> term
end
```

所以我认为本质上, `with` 语句只是帮助我们写了 `try` 块. 
我认为理想的 `with` 语句应该只要 **体** 和 **尾** 两部分就可以了.

## 特殊表达与保留字

在前面的章节中, 已经多次出现 **特殊表单** (Special Forms)这个短语了, 
但是特殊表单到底意味着什么呢?

我最初的理解, 特殊表单就像是别的语言中的关键字或者保留字. 这些符号和词汇, 
不但有语言规定的意义而且不能用作变量名和函数名, 现在不少的语言, 
对保留字的限制有所放宽, 比如 Javascript 中, 保留字虽然还不允许作为变量存在,
但是已经可以作为对象的方法或者字段名了.

在 Elixir 中, 特殊表单更多的不是语言对于这些保留字的限制, 
而在于这些特殊表单提供的语法, 在 Elixir 的语法中, 无法以正确的语法表示.

比如 `with` 特殊表单, 它的特殊就在于其头部的语句个数是不定的, 
而 Elixir 中, 无论是函数还是宏的定义, 都不运行有不定参数存在的, 
所以使用 Elixir 自身的语法是没法定义 `with` 这样的参数个数不定的宏.
但是 `with` 可以作为变量吗? 可以作为我们的函数名吗?
让我们来探索一下.

```elixir
with = 2
IO.inspect(with == 2, label: "with can used as variable")

with {:ok, a} <- {:ok, 1},
     {:ok, b} <- {:ok, a + 2} do
  a + b
end
|> then(&(&1 == 4))
|> IO.inspect(label: "with can still work")

defmodule A do
  def with(a, b), do: a + b
end

A.with(1, 2)
|> then(&(&1 == 1 + 2))
|> IO.inspect(label: "with can use as function name")
```

特性表单和保留字在 Elixir 中是两个概念, Elixir 有保留字. 
比如 `do`, `in` `and` `or`等, 但是 `with` 不是, 只要不是保留字, 
都可以作为变量, 以及函数名, 甚至模块名.

从上面的代码的输出中, 我们可以看出, 实际上 Elixir 对 `with` 几乎没有做限制.
但是我们不能把我们定义的 `with` 函数或宏导入到当前环境中, 
因为 `Kernel` 模块中已经导入了 `with` 宏了.

例如在下面的代码中, 我们只是导入了上面的代码中定义的模块 A, 就引发了编译器的报错.

```elixir
import A
```

回到对 `with` 的讨论上.

我们不满意 `with` 结构, 现在我们明白, 我们可以定义自己的 `with` 宏.
但是这样定义的不能直接导入到客户端的上下文中, 
就算通过 `import` 的 `:expcet` 选项来排除 `Kernel` 模块的 `with` 宏,
从来导入我们的定义的 `with` 宏. 但是因为定义的 `with` 和 
`Kernel` 定义的 `with` 宏是不兼容的, 这样的导入后, 写出的代码会引发困惑.

Erlang 的新版本 OTP 25 中引入了新的特性 Maybe[^erlang-maybe].
实际上解决的就是 `with` 语句在 Elixir 中解决的问题.
为此, Erlang 引入了新的操作符 `?=`, `Exp1 ?= Exp2` 叫做条件匹配表达式.

因此, 为了向 Erlang 靠拢, 我们可以把宏命名为 maybe.
[^erlang-maybe]: 详细内容见, https://www.erlang.org/doc/reference_manual/expressions.html#maybe

## 我们的宏的用法

首先, 让我们确定如何使用 `maybe`.
对于使用 `with` 的代码:

<!-- livebook:{"force_markdown":true} -->

```elixir
with {:ok, a} <- fun1(), # with 头部开始
     {:ok, b} <- fun2(a) # with 头部结束 
do # with 体开始
     action_with_a_and_b #with 体结束
else #尾部开始
   patter1 -> hanlder_error1
   patter2 -> hanlder_error2 # 尾部结束
end
```

和

<!-- livebook:{"force_markdown":true} -->

```elixir
with {:ok, a} <- fun1(), # with 头部开始
     {:ok, b} <- fun2(a) # with 头部结束 
do # with 体开始
     action_with_a_and_b #with 体结束
end
```

使用 `maybe` 应该改写成:

<!-- livebook:{"force_markdown":true} -->

```elixir
maybe do 
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
else 
   patter1 -> hanlder_error1
   patter2 -> hanlder_error2 # 尾部结束
end
```

和

<!-- livebook:{"force_markdown":true} -->

```elixir
maybe do 
  {:ok, a} = fun1()
  {:ok, b} = fun2(a)
  action_with_a_and_b
end
```

需要注意的是:

1. 我们的 `maybe` 中使用的是 `=` 而不再是 `<-`, 而且也不用引入新的条件匹配操作符.
2. 因为取消了 `with` 头部, 所以 `action_with_a_and_b`
   对应的代码中匹配错误也会被捕获, 这和 `with` 中的语义是不一样的.

## 我们宏的定义

现在让我们定义我们的 `maybe` 宏.

我们的 `maybe` 接受一个参数, `[do: body, else: tail]`,
`maybe` 宏把代码转化成为对应的 `try` 语句块.

```elixir
defmodule With do
  defmacro maybe(do: body) do
    quote do
      try do
        unquote(body)
      catch
        :error, {:badmatch, v} -> v
      end
    end
  end

  defmacro maybe(do: body, else: tail) do
    quote do
      try do
        unquote(body)
      catch
        :error, {:badmatch, v} ->
          case v do
            unquote(tail)
          end
      end
    end
  end
end
```

## 测试我们的定义

现在让我们测试我们的定义.

```elixir
import With
# test case 1
with_result =
  with {:ok, a} <- {:ok, 1},
       {:ok, b} <- {:error, a + 1} do
    b
  end

maybe do
  {:ok, a} = {:ok, 1}
  {:ok, b} = {:error, a + 1}
  b
end
|> then(&(with_result == &1))
|> IO.inspect(label: "same as with_result")

# case 2

with_result =
  with {:ok, a} <- {:ok, 1},
       {:ok, b} <- {:error, a + 1} do
    b
  else
    {:error, b} -> b
  end

maybe do
  {:ok, a} = {:ok, 1}
  {:ok, b} = {:error, a + 1}
  b
else
  {:error, b} -> b
end
|> then(&(with_result == &1))
|> IO.inspect(label: "have :else, same as with_result")
```

## 可递归的匿名函数

<!-- livebook:{"force_markdown":true} -->

```elixir
fn! fun(n, acc) do
  if n == 0 do
   acc
  else
    fun.(fun,n-1, acc + n)
  end
end
fun.(1,2)
```

->

<!-- livebook:{"force_markdown":true} -->

```elixir
fun = fn(fun, n,acc) ->
  if n == 0 do
    acc
  else
    fun.(fun,n-1,acc + n)
  end
end
fun = fn(n,acc) ->
  fun.(fun,n,acc)
end
```

```elixir
defmodule Corner.Fn do
  defmacro fn!({:when, _, [call, guard]}, do: block), do: make_fn(call, guard, block)
  defmacro fn!(call, do: block), do: make_fn(call, nil, block)

  defp replace(name, with: with_atom, in: block) do
    # TODO
    block
  end

  defp make_fn(call, guard, block) do
    {name, args} = Macro.decompose_call(call)
    block = replace(name, with: :tem_fun, in: block)

    outer_fun =
      if guard do
        quote do
          fn unquote_splicing(args) when unquote(guard) ->
            tem_fun.(tem_fun, unquote_splicing(args))
          end
        end
      else
        quote do
          fn unquote_splicing(args) ->
            tem_fun.(tem_fun, unquote_splicing(args))
          end
        end
      end

    # IO.inspect(outer_fun)
    ast =
      quote do
        tem_fun = fn fun, unquote_splicing(args) -> unquote(block) end
      end

    # IO.inspect(ast)
    # {a, b, block} = ast
    assign_name = {:=, [], [{name, [], nil}, outer_fun]}

    quote do
      unquote(ast)
      unquote(assign_name)
    end
    |> Code.eval_quoted()
    |> IO.inspect()
  end
end
```

然后我们就可以这样来使用我们代码了:

```elixir
import Corner.Fn

fn! fun(n, acc) do
  if n == 0 do
    acc
  else
    fun.(fun, n - 1, acc + n)
  end
end
```
